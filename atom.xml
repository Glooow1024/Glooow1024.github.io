<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你是下雨天</title>
  
  
  <link href="https://glooow1024.github.io/atom.xml" rel="self"/>
  
  <link href="https://glooow1024.github.io/"/>
  <updated>2022-06-14T08:35:31.933Z</updated>
  <id>https://glooow1024.github.io/</id>
  
  <author>
    <name>Glooow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无线通信标准杂谈</title>
    <link href="https://glooow1024.github.io/2022/06/14/communication/communication-specification/"/>
    <id>https://glooow1024.github.io/2022/06/14/communication/communication-specification/</id>
    <published>2022-06-14T08:24:03.000Z</published>
    <updated>2022-06-14T08:35:31.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="g-lte">4G LTE</h2><p>采用OFDM调制，支持的带宽有（大带宽）10MHz、15MHz、20MHz，（窄带）1.4MHz、3MHz、5MHz。正常情况下子载波间隔15KHz，符号周期66.7us，加上循环前缀长度为71.35us。LTE在时域上的最小单位为时隙，以0.5ms为周期，在15KHz下，0.5ms*15KHz=7.5个正弦波，因此一个时隙内可以容纳7个symbol，多余出来的时间分配给各个符号的循环前缀<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Angel_YJ/article/details/89001077">[3]</span></a></sup>。</p><p>各个子载波可以根据信道状况采用不同的调制方式，如BPSK，QPSK，8PSK，16QAM，64QAM等；当信道条件好时采用高阶调制方式，而当信道条件差时采用抗干扰能力强的低阶调制方式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/jyqxerxes/article/details/78981109">[2]</span></a></sup>。</p><h2 id="g-nr">5G NR</h2><p>在5GNR中，定义了两种频段范围，FR1和FR2，FR1表示低频频段，FR2表示毫米波高频频段。具体FR1和FR2表示的频段范围如下表所示：</p><table><thead><tr class="header"><th>Frequency range</th><th>Frequency range</th></tr></thead><tbody><tr class="odd"><td>FR1 (Sub-6GHz)</td><td>410MHz - 7125MHz</td></tr><tr class="even"><td>FR2 (mmWave)</td><td>24250MHz - 52600MHz</td></tr></tbody></table><p>其中Sub6G频段以3.5GHz为主（3.2GHz-4.2GHz），最大带宽为100MHz。mmWave频段以28/39/60/73GHz为主，带宽50MHz-400MHz<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="5G - Wikipedia">[6]</span></a></sup>。</p><p>5G仍旧采用OFDM调制，但是不同于4GLTE在于设置了多个不同的子载波间隔，也即<spanclass="math inline">\(\Delta f=2^\mu \cdot 15\)</span>[kHz]，其中<spanclass="math inline">\(\mu=0,1,2,3,4\)</span>，也就是子载波间隔<spanclass="math inline">\(\Delta f\)</span>取值为15/30/60/120/240kHz。</p><p>在5G和4G中，帧的长度都是10ms，子帧长度都是1ms。在LTE中，一个子帧包含了14个符号。5G中，当调制符号时间变短时，一个子帧长度1ms内也就有了更多的符号<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/u010202588/article/details/94360185">[4]</span></a></sup>。与4G不同，5G中的时隙长度不是固定的，每个时隙内都有14个符号，但是随着子载波间隔的不同，对应的时隙不再是固定的0.5ms<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_39702335/article/details/110309294">[5]</span></a></sup>。</p><p>这些参数看起来很多很复杂，实际上只需要关注两件事。第一个是符号周期，这是由子载波间隔决定的；第二个是帧长度，这个是由5GNR标准规定的固定长度10ms。前者是最小单位，后者是最大单位。至于中间的时隙长度、符号个数等参数，就是在一个帧内对这么多个符号进行组合，至于怎么组合全看协议规定。</p><p>在OFDM接收端需要进行时域采样并FFT，这里涉及到两个参数：采样频率和FFT点数。采样频率<spanclass="math inline">\(f_s\)</span>由带宽<spanclass="math inline">\(B\)</span>决定，FFT点数<spanclass="math inline">\(N=2B\ast T_{\text{symbol}}=2B/\Deltaf\)</span>，因此FFT点数大约是子载波个数的2倍，和子载波间隔大小无直接关系。尽管如此，子载波间隔越大，符号周期越短，这就要求FFT在更短的时间内完成，并且同等子载波个数情况下信号带宽越大，采样频率越高，对处理器的速度要求越高。</p><p>4G以子帧为单位进行调度，而5G则以时隙为单位进行调度。</p><p>资源块（RB, Resource block）</p><p>还没太搞懂多用户的时频资源是怎么分配的，网上大多语焉不详。</p><h2 id="g-毫米波通信">5G 毫米波通信</h2><p>看到一篇博客（2019）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.edn.com/mmwave-and-ofdm-is-phy-research-dead/">[1]</span></a></sup>，讲的是5G mmWave的物理层信号PHYs（physicallayers）设计。主要观点是现有的物理层信号基本都是基于OFDM，但是当载频高于某个点之后，OFDM就不适合了，需要研究新的物理层信号。3GPP组织目前推出了Release15和16，频点都低于52.6GHz，在此频段下仍旧采用OFDM波形，但是超过某个频点（也许52.6GHz并不是确切的阈值点）之后，由于实际的物理器件难以实现OFDM信号所需的峰均比、增益平坦度和效率等，在更高频点上不得不设计新的物理信号波形。Nokia、NI等公司在73GHz频点上研究了2GHz带宽的单载波信号波形，在2信道MIMO系统中演示了14.6Gbps的吞吐量。另外802.11ad就是一个单载波调制的毫米波通信协议。</p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.edn.com/mmwave-and-ofdm-is-phy-research-dead/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/jyqxerxes/article/details/78981109<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/Angel_YJ/article/details/89001077<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/u010202588/article/details/94360185<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://blog.csdn.net/weixin_39702335/article/details/110309294<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/5G">5G- Wikipedia</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;g-lte&quot;&gt;4G LTE&lt;/h2&gt;
&lt;p&gt;采用OFDM调制，支持的带宽有（大带宽）10MHz、15MHz、20MHz，（窄带）1.4MHz、3MHz、5MHz。正常情况下子载波间隔15KHz，符号周期66.7us，加上循环前缀长度为71.35us。LTE在时域</summary>
      
    
    
    
    <category term="Communication and Networks" scheme="https://glooow1024.github.io/categories/Communication-and-Networks/"/>
    
    
    <category term="OFDM" scheme="https://glooow1024.github.io/tags/OFDM/"/>
    
    <category term="4G LTE" scheme="https://glooow1024.github.io/tags/4G-LTE/"/>
    
    <category term="5G NR" scheme="https://glooow1024.github.io/tags/5G-NR/"/>
    
    <category term="毫米波通信" scheme="https://glooow1024.github.io/tags/%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>信号调制与解调</title>
    <link href="https://glooow1024.github.io/2022/05/21/communication/modulation/"/>
    <id>https://glooow1024.github.io/2022/05/21/communication/modulation/</id>
    <published>2022-05-20T16:16:24.000Z</published>
    <updated>2022-05-23T07:43:25.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇文章的起因是我一直对数字调制和模拟调制这两个概念比较模糊，对于相应的通信系统结构也觉得比较混乱，所以在网上查了很多资料来理清楚这件事情。本文引用了诸多网络上的博客、文章中的文字和图片，引用之处都标注了参考出处，若有侵权请告知我，我会删除侵权部分。</p></blockquote><p>信号的调制简单来说，就是用基带信号去控制（调制）单频载波信号的某个或某几个参数，从而使得调制后的信号中嵌入了希望传递的信息<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html">[1]</span></a></sup>。这个载波往往是一个高频信号，便于传输。解调则是调制的逆过程。之所以要这么做是因为：1）高频信号更容易收发传输，天线尺寸需要是波长的1/4，使用高频信号可以减小天线尺寸；2）通过调制不同频率的载波信号，可以将基带信号搬移到不同频段的载波上，便于同时传输多路不同的基带信号<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/SilenceBurster/article/details/53126468">[2]</span></a></sup>。</p><h2 id="移动通信发展历史">1. 移动通信发展历史</h2><p>我们主要关注无线通信。移动通信最开始的目的是打电话，上世纪80年代出现了第一代（1G）移动通信网络，传输的是人的语音信号，1G使用模拟调制，多址技术为FDMA。当时使用的都是大哥大，采用模拟电路，因此手机都比较大，使用的频段在800MHz，所以天线长度大概要10cm，所以也能看到大哥大外面露出来的很长的天线，这个阶段摩托罗拉风光无限。传输速率只有2.4Kbps，要知道人的语音要想保证比较好的质量需要的速率是64Kbps，因此1G的语音通话质量也不太行<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/ziv669/article/details/122453973">[22]</span></a></sup>。</p><p>上世纪90年代，形成2G移动通信，大致可以分为两类，一类是基于TDMA的GSM标准，主要使用地区是我国和欧洲；另一类是基于CDMA的IS-95标准（也被称为cdmaOne），主要使用地区是美国。欧洲（芬兰）提出的通信标准GSM中采用了GMSK调制，而IS-95则采用QPSK和OQPSK调制，这三种都是数字调制，因此2G也将移动通信带入了数字时代。由于处理和传输的是数字信号，数字电路取代了模拟电路，能够集成在一个小小的芯片上，因此手机体积大大的减小了，诺基亚在这个阶段大杀四方。并且除了语音信号，其他的多媒体数据例如文字、图片也能传输了。GSM，工作在900MHz和1800MHz频点附近；CDMA工作在800MHz频点附近。2G移动通信，带宽有25MHz，峰值数据速率能达到14.4Kbps<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup><sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/CDMAOne/7525860">[21]</span></a></sup>。</p><p>在2G和3G中间经过了2.5G，是二者的衔接，2.5G相比于2G提供了更高的速率和更多的功能。蓝牙等技术都是2.5G技术<sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="2.5G_百度百科(baidu.com)">[23]</span></a></sup>。</p><p>到3G时代，CDMA技术大行其道，作为CDMA技术的提出者，高通握着大量专利，简直是躺着赚钱。为了绕开高通的专利，欧洲日本联合起来成立了3GPP组织，提出了W-CDMA；中国搞了一个TD-SCDMA；高通与韩国组成3GPP2组织，推出了CDMA2000<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。前两个可以看作是从GSM演化而来；CDMA2000则是从IS-95继承而来。3G的工作频段在2100MHz附近，带宽有25MHz，上行链路采用BPSK调制，下行链路采用QPSK，数据速率能达到3.1Mbps<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Code-division_multiple_access">[19]</span></a></sup><sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup>。苹果2007年发布的iPhone也带动了3G的推广和发展。</p><p>在进入4G时代之前，插入一段关于WiFi和WiMax的历史。1999年，IEEE分别推出了802.11b与802.11a两种WiFi标准，分别使用2.4GHz和5GHz频段，彼此标准不相容。2003 年，IEEE引入正交频分复用技术(OFDM)，推出802.11b的改进版802.11g使传输速度从原先的11Mbps提升至54Mbps。现在我们使用的WiFi主要为802.11n，与802.11a、802.11b、802.11g皆兼容，并采用MIMO技术，使传输速度及距离都有所提升，速度甚至可达600Mbps。现在我们使用的WiFi主要为802.11n，与802.11a、802.11b、802.11g皆兼容，并采用MIMO技术，使传输速度及距离都有所提升，速度甚至可达600Mbps<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>随着版图不断扩大，IT业巨头们开始觊觎起蜂窝移动通信市场大饼——4G。OFDM说起来也不是新技术，早在1960年代贝尔实验室发明OFDM后，技术框架约在1980年代便已建立完成。然而当时能支持OFDM的硬件不成熟，CDMA又由高通领军一时红火，便淘汰在3G标准之外。简单来说就是CDMA太红，如果Intel和IT大厂没有在WiFi上将OFDM技术发扬光大，电信业没有一家注意到早期不被重视的OFDM。由于WiMax的关系，OFDM才又重新进入电信业和学术界的视野中。简单来说就是CDMA太红，如果Intel和IT大厂没有在WiFi上将OFDM技术发扬光大，电信业没有一家注意到早期不被重视的OFDM。由于WiMax的关系，OFDM才又重新进入电信业和学术界的视野中<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>2008年时，3GPP提出了长期演进技术 (Long Term Evolution, LTE)作为3.9G技术标准。又在2011年提出了长期演进技术升级版 (LTE-Advanced)作为4G技术标准，准备把W-CDMA汰换掉，转而采用OFDM。全球覆盖率最高的基站正是W-CDMA，因此，各大运营商无不纷纷决定采用LTE-Advanced当作第四代通信技术标准。如同高通败在W-CDMA基站的广覆盖上，LTE可兼容WCDMA，且利用现有基站配套设备，而WiMax基站却要从头建起，Intel也在2010年宣布放弃WiMax，加入LTE阵营<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>到4G时代，高通摆烂了，CDMA2000也没有后续向4G的演化，所以4G主要有两支，一个是从W-CDMA演化来的LTE-FDD/LTE-FDD-Advanced，另一个是从TD-SCDMA演化来的TD-LTE/TD-LTE-Advanced。4G采用的OFDM技术可以看成是多址技术，也可以看成是调制技术，实际上就是用多个相互正交的子载波同时传递多路数据，大大提高了频谱效率。FDD-LTE的工作频点在1800MHz附近，TD-LTE的工作频点在1890MHz、2350MHz、2600MHz附近，带宽有100MHz，数据速率可达100Mbps<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup><sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://norstc.blog.csdn.net/article/details/80504263">[26]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/standard.jpg"alt="Mobile communication standards" /><figcaption aria-hidden="true">Mobile communicationstandards</figcaption></figure><h2 id="调制的分类">2. 调制的分类</h2><p>调制信号的大致分类如下图所示<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/Modulation_categorization.png"alt="Modulation_categorization" /><figcaption aria-hidden="true">Modulation_categorization</figcaption></figure><p>按照载波信号（也被称为被调信号）可以分为三类：正弦波调制、脉冲调制与强度调制。调制的载波分别是正弦波，脉冲和光波。</p><p>无线通信中一般使用的载波信号都是高频正弦波，而调制过程中改变的就是正弦波的3个参数：幅度、相位、频率<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html">[1]</span></a></sup>。也就是3种基本的调制方式：调幅（AM）、调相（PM）、调频（FM）。除此之外还有一些变异的调制方法，比如正交幅度调制（QAM），单边带调幅（SM）、残留边带调幅（SSB）等<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>。 <span class="math display">\[{\color{red}A_c} \cos(2\pi {\color{orange}f_c} t +{\color{blue}\varphi_c})\]</span>按照基带信号（也被称为调制信号）可以分为两类：模拟调制与数字调制。顾名思义，模拟调制中基带信号是模拟信号，数字调制中基带信号是数字信号。</p><p>模拟调制的中所控制的幅度、频率、相位参数是连续变化的，在解调的过程中也需要估计这个连续变化的波形；而数字调制中这些被改变的参数只是一些离散的值。模拟调制与数字调制各自的优缺点为<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/SilenceBurster/article/details/53126468">[2]</span></a></sup>：</p><table><thead><tr class="header"><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td><strong>数字调制</strong></td><td>抗干扰能力强；<br>易于加密，保密性强；<br>便于计算机对数字信息进行处理；<br>便于集成化。</td><td>需要较宽的频带；<br>进行数/摸转换时会带来量化误差；<br>要求的技术和设备复杂。</td></tr><tr class="even"><td><strong>模拟调制</strong></td><td>直观且容易实现；</td><td>保密性差，抗干扰能力差。</td></tr></tbody></table><p>调制的另一种分类方法是角度调制和幅度调制，其中角度调制包括调频和调相，幅度调制包括调幅AM、双边带调制DSB、单边带调制SSB、残留边带调制VSB和正交幅度调制QAM<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>。</p><p>根据已调信号的频谱结构是否保留了原来消息信号的频谱模样，可以分为线性调制与非线性调制<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。幅度调制一般都是线性调制，角度调制都是非线性调制。</p><h2 id="解调的分类">3. 解调的分类</h2><p>相干解调与非相干解调。相干解调（也被称为同步检波）适用于所有线性调制信号的解调<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/m0_51288996/article/details/121340840">[4]</span></a></sup>。</p><h2 id="模拟调制与解调">4. 模拟调制与解调</h2><p>我们都假设基带信号是 <spanclass="math inline">\(m(t)\)</span>，载波频率是 <spanclass="math inline">\(f_c\)</span>，调制后的信号是 <spanclass="math inline">\(s(t)\)</span>。本部分主要参考了博客<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><h3 id="常规调幅am">4.1 常规调幅AM</h3><p>先将基带信号加上一个直流分量，然后乘以载波得到已调信号 <spanclass="math display">\[s(t) = (A_0 + m(t))\cos(2\pi f_c t)\]</span> 对应的波形和频谱如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/AM.png"alt="AM" /><figcaption aria-hidden="true">AM</figcaption></figure><p>解调阶段只需要通过一个低通滤波器即可检出信号包络：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/AM-demodulation.png"alt="AM-demodulation" /><figcaption aria-hidden="true">AM-demodulation</figcaption></figure><h3 id="抑制载波的双边带调制dsb-sc">4.2 抑制载波的双边带调制DSB-SC</h3><p>上面的调幅方法由于直流的存在，会导致输出的已调信号中含有载波分量<spanclass="math inline">\(\cos(2\pi f_ct)\)</span>，抑制载波的双边带调制方法就是去除这个直流分量，也简称为双边带调制。<span class="math display">\[s(t) = m(t) \cos(2\pi f_c t)\]</span> <imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB.png"alt="DSB" /></p><p>由于DSB已调信号的包络不再与基带信号<spanclass="math inline">\(m(t)\)</span>成正比，因此不能使用包络检测器进行解调。通常采用的是相干解调。也就是在接收端生成一个与发送端同频同相的相关载波信号，与接收信号相乘，即可将接收信号频谱再搬到基带，通过低通滤波器后即可解调出基带信号。</p><table><thead><tr class="header"><th></th><th>调制</th><th>解调</th></tr></thead><tbody><tr class="odd"><td>系统框图</td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-modulation.png"alt="DSB-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-demodulation.png"alt="DSB-demodulation" /></td></tr><tr class="even"><td>频谱</td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-modulation-spectrum.png"alt="DSB-modulation-spectrum" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-demodulation-spectrum.png"alt="DSB-demodulation-spectrum" /></td></tr></tbody></table><h3 id="单边带调制ssb">4.3 单边带调制SSB</h3><p>前面的双边带调制基带信号是对称的，搬移到载波之后实际上有一半的频谱资源是浪费掉的，没有携带有效的信息，因此单边带调制就是在DSB的基础上，要去掉一半没用的频谱，节省频谱资源。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/SSB.png"alt="SSB" /><figcaption aria-hidden="true">SSB</figcaption></figure><p>上面通过低通滤波法获得单边带已调信号对滤波器有较高的要求，需要其在载频处具有陡峭的截止特性。这难以实现，因此实际中往往是通过项移法产生SSB信号，如下图所示，推导过程可以参考博客<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/SSB-modulation.png"alt="SSB-modulation" /><figcaption aria-hidden="true">SSB-modulation</figcaption></figure><h3 id="残留边带调制vsb">4.4 残留边带调制VSB</h3><p>单边带调制需要陡峭的低通滤波器，为了解决这个问题，残留边带调制的想法虽然理想的陡峭滤波器不可实现，但是圆滑滚降的滤波器还是可以的，那就用这样的滤波器。不过这样不能将其中一半的频谱去除干净，那么是否还能够解调出基带信号呢？也是可以的，不过这个滚降滤波器的频谱需要满足一定性质，也就是在载频处具有对称性<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB.png"alt="VSB" /><figcaption aria-hidden="true">VSB</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB-modulation-1.png"alt="VSB-modulation-1" /><figcaption aria-hidden="true">VSB-modulation-1</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB-modulation-2.png"alt="VSB-modulation-2" /><figcaption aria-hidden="true">VSB-modulation-2</figcaption></figure><h3 id="调相pm与调频fm">4.5 调相PM与调频FM</h3><p>可以参考博客<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114694510">[6]</span></a></sup>。调频信号的包络恒定，而噪声往往是作用在信号幅度上，因此FM信号抗噪声能力强；但是FM信号需要占用较大的信号带宽，频谱利用率低。</p><h2 id="数字调制">5. 数字调制</h2><p>在开始本节之前，需要明晰的一点是，相比于模拟调制，数字调制当中“调制”的概念已经被扩展了。具体而言，在模拟调制当中，基带模拟信号与高频载波通过前面介绍的几种调制方式混合之后，得到的就直接是待发送的射频信号。而在数字调制中通常包含三个阶段：</p><ol type="1"><li>第一个阶段将二进制比特流映射为某种效率更高的数字信号（通常被称为码流），这个过程被称为基带调制；</li><li>第二个阶段将码流通过脉冲成型滤波器，将会突变的数字信号变成连续光滑的模拟信号，得到的就是基带信号；</li><li>第三个阶段将基带信号搬移到高频载波上，这个过程被称为载波调制/带通调制/射频调制。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/digital-communication-system-diagram.png"alt="digital-communication-system-diagram" /><figcaptionaria-hidden="true">digital-communication-system-diagram</figcaption></figure><p>在本节的几个子小节中，5.3IQ调制属于第三阶段载波调制，5.7脉冲成型滤波器属于第二阶段，其余的部分则属于第一阶段基带调制。为了讲述的方便以及前后逻辑的顺畅，这里将他们穿插起来，但是希望读者在脑海里能够明确他们在系统中的位置以及各自的作用。</p><blockquote><p>实际上，笔者在写本文之前对模拟和数字调制感到困惑、不理解也是源于此。</p></blockquote><h3 id="二进制数字调制">5.1 二进制数字调制</h3><p>最简单的数字调制系统中，基带信号是0-1二进制数字波形，通过控制开关实现对载波的调制，因此这里面的调幅AM、调相PM、调频FM也分别被称为幅度键控ASK/通-断键控OOK、相位键控PSK、频移键控FSK。他们各自图示如下<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.eecs.yorku.ca/course_archive/2010-11/F/3213/CSE3213_07_ShiftKeying_F2010.pdf">[8]</span></a></sup>：</p><table><thead><tr class="header"><th>2ASK</th><th>2PSK</th><th>2FSK</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2ASK.png"alt="2ASK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2PSK.png"alt="2PSK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2FSK.png"alt="2FSK" /></td></tr></tbody></table><h3 id="多进制数字调制">5.2 多进制数字调制</h3><p>二进制数字调制中，每一个符号只能表示0-1两个数值，为了提高数据传输效率，可以在一个符号内传输更多的比特，从而提高频带利用率。简单来说就是把原来的0-1比特流进行分组，例如两个bit为一组映射到一个符号（symbol、码元）上，那么一个符号就有00,01, 11, 10这4种取值，再去调制：</p><ul><li>幅度：0，1，2，3这4个振幅；</li><li>相位：0，<span class="math inline">\(\pi/2\)</span>，<spanclass="math inline">\(\pi\)</span>，<spanclass="math inline">\(3\pi/2\)</span>这4个相位；</li><li>频率：4个不同的载波频率。</li></ul><p>想要传输的信号从bit流映射为了symbol流，symbol同样是只有有限个离散的取值，这个时候引入星座图会更直观更方便。什么是星座图呢？首先我们传输的正弦信号可以表示为一个复信号的实部，也就是<span class="math display">\[{A_c} \cos(2\pi {f_c} t + {\varphi_c}) = \operatorname{Re}\{{\color{blue}A_c \exp(\varphi_c)}\exp (2\pi {f_c} t)\}\]</span> 可以看到无论是调制信号幅度还是相位，都是在单频载波<spanclass="math inline">\(\exp(2\pi f_c t)\)</span>上乘以了一个复幅度<spanclass="math inline">\(A_c\exp(\varphi_c)\)</span>。因此如果是幅度或者相位调制，那么我们只需要看这个复幅度就得到了想要传输的信息（symbol流）。一个复数可以映射为一个x-y二维平面上的点，那么如果我们把所有的symbol取值画出来，那么就是多个离散的点，就像是星座一样，故名星座图。BPSK（也就是2PSK）、QPSK（也就是4PSK）和8PSK示意图如下<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/58119209">[9]</span></a></sup><sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-MPSK.jpg"alt="constellation-MPSK" /><figcaption aria-hidden="true">constellation-MPSK</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/QPSK-BPSK.png"alt="QPSK-BPSK" /><figcaption aria-hidden="true">QPSK-BPSK</figcaption></figure><p>其实QPSK还有另外一种方式，就是星座图旋转45°<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114735043">[7]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-QPSK2.png"alt="constellation-QPSK2" /><figcaption aria-hidden="true">constellation-QPSK2</figcaption></figure><p>除了MPSK，幅度也是可以控制的，例如下面这个16APSK<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Amplitude_and_phase-shift_keying">[10]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-16APSK.png"alt="constellation-16APSK" /><figcaption aria-hidden="true">constellation-16APSK</figcaption></figure><p>不过这里有一个问题就是：我们实际系统中只能产生实信号，而这里转换到复数域虽然看起来很简洁，但是实际系统如何实现呢？答案就是用两路信号，分别表示复信号的实部和虚部，也就是I路（In-phase）和Q路（Quadrature）。这就引出了下面的正交幅度调制QAM。</p><h3 id="iq调制">5.3 IQ调制</h3><p>说白了IQ调制就是把复的基带信号搬移到高频载波上，仅此而已。前面我们已经提到了symbol可以用复数表示，那么我们要传输的码流就是一个复基带信号，记为<spanclass="math inline">\(s_0(t) = a(t) + j b(t)\)</span>，其中 <spanclass="math inline">\(a(t)\)</span> 和 <spanclass="math inline">\(b(t)\)</span>分别是实部和虚部，那么调制信号可以表示为 <span class="math display">\[s(t) = \operatorname{Re}\{s_0(t) \exp(2\pi f_c t)\} = a(t)\cos(2\pi f_ct) - b(t) \sin(2\pi f_c t)\]</span> 在信号发射阶段，I路的基带信号就是<spanclass="math inline">\(a(t)\)</span>，将其乘以<spanclass="math inline">\(\cos(2\pi f_ct)\)</span>，Q路的基带信号是<spanclass="math inline">\(b(t)\)</span>，将其乘以<spanclass="math inline">\(\sin(2\pi f_ct)\)</span>，再将二者求和即可得到要发送的已调信号。可以参考我之前的一篇博客<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/">[11]</span></a></sup>，系统框图如下<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-i-q-signals-and-quadrature-modulation/">[12]</span></a></sup><sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-quadrature-demodulation/">[13]</span></a></sup>：</p><table><thead><tr class="header"><th>IQ调制</th><th>IQ解调</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/diagram-IQ-modulation.jpg"alt="diagram-IQ-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/diagram-IQ-demodulation.jpg"alt="diagram-IQ-demodulation" /></td></tr></tbody></table><p>IQ调制在数学上是如此的漂亮，实际系统中又是如此的方便好用，因此在现代无线通信系统中几乎是必备的。后面介绍的各种基带调制方式也基本都会配合IQ调制来使用。</p><h3 id="正交幅度调制qam">5.4 正交幅度调制QAM</h3><p>有了IQ调制，我们只需要分别控制I、Q两路基带信号的幅度，就能得到星座图上任意一个点，所以各种MPSK、MASK以及MAPSK等都能通过这种方式获得，这种调制方式也被称为正交幅度调制QAM。</p><p>其实也不难发现QPSK实际上就是两路（载波）相互正交的BPSK，实际上也是4QAM。</p><h3 id="偏移四相位键控offset-qpsk">5.5 偏移四相位键控Offset-QPSK</h3><p>在一般的QPSK基础上有一些变种，比如OQPSK，与QPSK的区别就在于I、Q两路的码流在时间上错开了半个码元周期，这样可以避免出现两个支路同时出现极性翻转的情况，好处是：1）避免180°的相位跳变，这种情况下最多只有90°相位跳变；2）避免I、Q两路信号同时过零点，降低信号峰均比PAR<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114735043">[7]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/QPSK-drawback.png"alt="QPSK-drawback" /><figcaption aria-hidden="true">QPSK-drawback</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OQPSK.png"alt="OQPSK" /><figcaption aria-hidden="true">OQPSK</figcaption></figure><p>除此之外，还有其他的变种，例如<spanclass="math inline">\(\pi/4\)</span>-QPSK等，不再赘述。</p><h3 id="最小频移键控msk">5.6 最小频移键控MSK</h3><p>前面介绍的不管是二进制还是多进制，码流信号都认为是矩形波，实际上这种矩形波性能并不好。因为矩形波从时域来看会导致相位跳变，波形不光滑、不连续，从频域来看就是矩形波旁瓣幅度较大，会出现频谱扩展，对相邻信道产生干扰。为了解决这个问题，那就把矩形波换掉！换成边缘光滑的波形！</p><p>最小频移键控MSK（Minimum-shiftkeying）可以看成是一种特殊的OQPSK，把原来的矩形方波换成半正弦波。如果从另一个角度来看，也可以认为是频率分离为比特率二分之一的连续相位频移键控CP-BFSK（一般通过开关实现的FSK信号在边沿处也会出现波形不连续，而MSK中波形/相位总是连续的）。如下图所示<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="MinimumShift Keying (MSK) - A Tutorial - Qasim Chaudhari">[15]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-class.png"alt="MSK-class" /><figcaption aria-hidden="true">MSK-class</figcaption></figure><p>那么他的数学原理是什么样的呢？首先从时域来看，实际上就是将OQPSK中的矩形方波换成半正弦波，这样相邻码元的相位变化就为0。如下图所示<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup><sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://ppt-online.org/1039280">[17]</span></a></sup>，一个脉冲的宽度为<spanclass="math inline">\(2T\)</span>，正弦波的周期为<spanclass="math inline">\(4T\)</span>。</p><table><thead><tr class="header"><th>MSK对比O-QPSK</th><th>MSK的波形是连续的</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-OQPSK.png"alt="MSK-OQPSK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-half-sin.png"alt="MSK-half-sin" /></td></tr></tbody></table><p>用三角函数表示出来就是<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup> <span class="math display">\[s(t) = a_I(t)\cos(\frac{\pi t}{2T}) \cos(2\pi f_c t) -a_Q(t)\sin(\frac{\pi t}{2T})\sin(2\pi f_c t)\]</span> 其中<span class="math inline">\(a_I(t),a_Q(t)\)</span>还是矩形方波，<span class="math inline">\(\cos(\pi t/2T),\sin(\pi t/ 2T)\)</span>就是周期为<spanclass="math inline">\(4T\)</span>的正弦波，一个码元周期内半个正弦波。对这个式子应用三角恒等式，就能得到<span class="math display">\[\begin{aligned}s(t) &amp;= \cos\left( 2\pi f_c t + b_k(t)\frac{\pi t}{2T} + \phi_k\right) \\b_k(t) &amp;= \begin{cases} 1, &amp; a_I(t)=a_Q(t) \\ -1, &amp;\text{others} \end{cases} \\\phi_k &amp;= \begin{cases} 0, &amp; a_I(t)=1 \\ \pi, &amp;\text{others} \end{cases}\end{aligned}\]</span>从频域来看，MSK是频率分离为比特率二分之一的连续相位频移键控CPFSK，也就是在一般的BFSK基础上，MSK的两个载波频率间隔恰好是码元波特率的二分之一。假设FSK的两个载波频率为<spanclass="math inline">\(f_1,f_2\)</span>，码元周期为<spanclass="math inline">\(2T\)</span>，由于一个码元可以传输2个比特，因此波特率为<spanclass="math inline">\(1/T\)</span>，那么就有<spanclass="math inline">\(|f_1-f_2| = 1/2T\)</span>。</p><p>从频谱来看，MSK的旁瓣幅度相比于BPSK和QPSK也更低，因此， MSK情况下的信道间干扰较低<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-spectrum.png"alt="MSK-spectrum" /><figcaption aria-hidden="true">MSK-spectrum</figcaption></figure><p>发射接收机如下图所示<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup>，解调也需要相干载波。</p><table><thead><tr class="header"><th>发射机</th><th>接收机</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-modulation.png"alt="MSK-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-demodulation.png"alt="MSK-demodulation" /></td></tr></tbody></table><h3 id="脉冲成型滤波器">5.7 脉冲成型滤波器</h3><p>MSK当中将矩形波换成了半正弦波，在实现的时候直接用一个正弦波发生器加上开关就可以了，但如果我们想换成其他形状的光滑波形呢？就没有这么简单了，这里就引出了数字传输中的脉冲成型滤波器。</p><p>数字调制之后得到的码流是矩形波，从时域来看存在跳变，从频域来看频谱宽度无穷大，这在实际系统当中是不可能实现的，原因是我们无法生成跳变的信号，并且信道和收发机的通带也不是无穷带宽的。因此我们需要将码流脉冲转化为模拟信号，这个模拟信号从时域来看是连续光滑的，从频域来看是带限的，如下图所示<sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://wirelesspi.com/pulse-shaping-filter/">[29]</span></a></sup>。思路很简单，将码流脉冲通过一个脉冲成型滤波器，输出信号就是滤波器冲激响应的叠加。不过关键的问题在于这个脉冲成型滤波器要怎么设计？</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/rectangular-sa.png"alt="rectangular-sa" /><figcaption aria-hidden="true">rectangular-sa</figcaption></figure><p>设计的关键在于不能有符号间串扰（Inter Symbol Interference,ISI）。什么意思呢？频域带限会导致时域扩展，要想当前码元对相邻的码元没有干扰，如下图所示<sup id="fnref:30" class="footnote-ref"><a href="#fn:30" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://dsp.stackexchange.com/questions/36340/nyquist-criterion-for-zero-isi">[30]</span></a></sup>，需要其时域波形在相邻码元的采样时刻幅值为0，这就是Nyquist准则。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/zero-ISI.png"alt="zero-ISI" /><figcaption aria-hidden="true">zero-ISI</figcaption></figure><p>记经过基带调制的复码流为 <span class="math inline">\(\{a_k\}\)</span>，码元间隔（采样周期）为 <spanclass="math inline">\(T_s\)</span>，脉冲成型滤波器的冲激响应为 <spanclass="math inline">\(g(t)\)</span>，那么脉冲成型之后的模拟基带信号为<span class="math display">\[s_0(t) = \sum_{k=-\infty}^{\infty} a_k g(t-kT_s)\]</span> 对应的Nyquist无码间串扰条件即为： <spanclass="math display">\[g(kT_s) = \begin{cases}1, &amp; k=0 \\ 0, &amp; k\ne 0 \end{cases}\]</span> 等价的频域条件为（<spanclass="math inline">\(G(f)\)</span>为<spanclass="math inline">\(g(t)\)</span>的傅里叶变换）<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Nyquist_ISI_criterion">[31]</span></a></sup>： <span class="math display">\[\frac{1}{T_s} \sum_{k=-\infty}^{\infty} G\left(f-\frac{k}{T_S}\right) =1, \forall f\]</span> 实际系统中常用的就是升余弦滤波器（Raised CosineFilter），不同滚降系数的RC滤波器频谱如下图所示<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Nyquist_ISI_criterion">[31]</span></a></sup>，他两侧的边沿是余弦曲线。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/raised-cosine-filter.png"alt="raised-cosine-filter" /><figcaption aria-hidden="true">raised-cosine-filter</figcaption></figure><p>除此之外还有Sinc filter（频谱是理想矩形），Gaussianfilter（时域冲激响应是高斯的PDF）。第二代移动通信标准GSM中就采用高斯滤波器。</p><h3 id="高斯最小频移键控gmsk">5.8 高斯最小频移键控GMSK</h3><p>终于到了GMSK，其被应用于GSM通信标准、蓝牙、卫星通信当中。GMSK是在MSK的基础上，为了改善信号的旁瓣衰减性能，增加了一个高斯滤波器进行整形<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup>。其实现方式可以是首先将基带码流通过高斯滤波器得到高斯脉冲，然后再通过MSK调制器。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-spectrum.png"alt="GMSK-spectrum" /><figcaption aria-hidden="true">GMSK-spectrum</figcaption></figure><p>系统框图如下所示<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996)."&gt;[18]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-diagram.png"alt="GMSK-diagram" /><figcaption aria-hidden="true">GMSK-diagram</figcaption></figure><p>下面的图片当中<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996)."&gt;[18]</span></a></sup>，第一行是已调信号相位轨迹随着非归零码序列（-1,-1,-1,+1,+1,-1,+1,+1,+1,+1,-1,+1,-1,+1,-1,-1）的变化，可以看到GMSK输出的信号相位变化更加平缓。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-phase.png"alt="GMSK-phase" /><figcaption aria-hidden="true">GMSK-phase</figcaption></figure><h3 id="正交频分复用ofdm">5.9 正交频分复用OFDM</h3><p>OFDM本身又是一个非常精妙的调制技术。简单来理解，就是同时传输多路IQ调制的信号，不同路的载波频率不同，在一个符号周期内他们相互正交，互不干扰。</p><p>再详细一点的解释。首先对于IQ调制来说，I、Q两路本身是相互正交的，但是他们的载波还是位于同一个频点上，把两路放在一起看就是把基带信号的复频谱搬移到单一载波频点上<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/">[11]</span></a></sup>。而OFDM可以理解为在N个不同的载波频点上，并行传输了N个这样的IQ调制信号。需要注意这些子载波也不是随意选取的，需要满足在一个符号周期内的正交性，子载波之间不能有干扰。示意图如下<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/madongchunqiu/article/details/18614233">[27]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OFDM-parallel.png"alt="OFDM-parallel" /><figcaption aria-hidden="true">OFDM-parallel</figcaption></figure><p>但是实际系统中直接这样实现会有很多麻烦，所以人们想出了一种非常巧妙的办法。要传输的串行二进制比特流首先转化为N路并行的比特流，每一路比特流在经过QAM映射为码流，这些码流控制了不同频点载波的复幅度，所以同一时刻不同支路的码元，实际上就是要发送信号的频谱，那么对这些系数进行IFFT，我们就把他们从频域变换到了时域，N路并行的码元映射为了1路串行的N个时刻的（复）信号，然后再将得到时域波形实部和虚部送入一个IQ调制，即可得到要发送的射频信号。示意图如下<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/madongchunqiu/article/details/18614233">[27]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OFDM-FFT.png"alt="OFDM-FFT" /><figcaption aria-hidden="true">OFDM-FFT</figcaption></figure><p>OFDM的系统框图如下所示<sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://ecse.monash.edu/staff/eviterbo/OTFS-VTC18/Tutorial_ICC2019___OTFS_modulation.pdf">[28]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/OFDM.jpg"alt="OFDM" /><figcaption aria-hidden="true">OFDM</figcaption></figure><p>除此之外，OFDM中还包括了循环前缀以及其他细节的设计，在这里不再详细展开了，可以参考网上相关资料。LTE中OFDM采用的调制方式最高能达到256QAM，NR中能达到1024QAM<sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/m0_52840978/article/details/123674928">[25]</span></a></sup>。</p><h2 id="数字解调">6. 数字解调</h2><p>解调是调制的逆过程，所以数字解调也包括三个阶段：</p><ol type="1"><li>第一阶段将信号从载波频段搬回到基带，如果调制的时候采用的是IQ调制，那么解调就采用IQ解调就好了；</li><li>第二阶段从模拟的基带波形中恢复出数字信号，最佳接收方案为匹配滤波并以<spanclass="math inline">\(1/T_s\)</span>的频率进行采样；</li><li>第三阶段从数字信号中解调出原本想传输的比特流，需要根据星座图对得到的采样进行判决。</li></ol><h2 id="总结">7. 总结</h2><p>QAM和IQ调制yyds！OFDM yyds!</p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/SilenceBurster/article/details/53126468<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Modulation">Modulation- Wikipedia</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/m0_51288996/article/details/121340840<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114679288<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114694510<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114735043<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://www.eecs.yorku.ca/course_archive/2010-11/F/3213/CSE3213_07_ShiftKeying_F2010.pdf<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/58119209<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10"class="footnote-text"><span>https://en.wikipedia.org/wiki/Amplitude_and_phase-shift_keying<a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:11"class="footnote-text"><span>https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/<a href="#fnref:11" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:12"class="footnote-text"><span>https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-i-q-signals-and-quadrature-modulation/<a href="#fnref:12" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:13"class="footnote-text"><span>https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-quadrature-demodulation/<a href="#fnref:13" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:14"class="footnote-text"><span>https://en.wikipedia.org/wiki/Minimum-shift_keying<a href="#fnref:14" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:15"class="footnote-text"><span><a href="https://www.dsprelated.com/showarticle/1016.php">MinimumShift Keying (MSK) - A Tutorial - Qasim Chaudhari</a><a href="#fnref:15" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:16"class="footnote-text"><span>http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/<a href="#fnref:16" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:17"class="footnote-text"><span>https://ppt-online.org/1039280<a href="#fnref:17" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:18" class="footnote-text"><span>Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996).<a href="#fnref:18" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:19"class="footnote-text"><span>https://en.wikipedia.org/wiki/Code-division_multiple_access<a href="#fnref:19" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:20"class="footnote-text"><span>https://www.zseries.in/telecom%20lab/telecom%20generations/<a href="#fnref:20" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:21"class="footnote-text"><span>https://baike.baidu.com/item/CDMAOne/7525860<a href="#fnref:21" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:22"class="footnote-text"><span>https://blog.csdn.net/ziv669/article/details/122453973<a href="#fnref:22" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:23"class="footnote-text"><span><a href="https://baike.baidu.com/item/2.5G/1192973">2.5G_百度百科(baidu.com)</a><a href="#fnref:23" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:24"class="footnote-text"><span>https://blog.csdn.net/zuochao_2013/article/details/78337600<a href="#fnref:24" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:25"class="footnote-text"><span>https://blog.csdn.net/m0_52840978/article/details/123674928<a href="#fnref:25" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:26"class="footnote-text"><span>https://norstc.blog.csdn.net/article/details/80504263<a href="#fnref:26" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:27"class="footnote-text"><span>https://blog.csdn.net/madongchunqiu/article/details/18614233<a href="#fnref:27" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:28" class="footnote-text"><span>https://ecse.monash.edu/staff/eviterbo/OTFS-VTC18/Tutorial_ICC2019___OTFS_modulation.pdf<a href="#fnref:28" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:29"class="footnote-text"><span>https://wirelesspi.com/pulse-shaping-filter/<a href="#fnref:29" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:30"class="footnote-text"><span>https://dsp.stackexchange.com/questions/36340/nyquist-criterion-for-zero-isi<a href="#fnref:30" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:31"class="footnote-text"><span>https://en.wikipedia.org/wiki/Nyquist_ISI_criterion<a href="#fnref:31" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写这篇文章的起因是我一直对数字调制和模拟调制这两个概念比较模糊，对于相应的通信系统结构也觉得比较混乱，所以在网上查了很多资料来理清楚这件事情。本文引用了诸多网络上的博客、文章中的文字和图片，引用之处都标注了参考出处，若有侵权请告知我，我会删除侵权</summary>
      
    
    
    
    <category term="Communication and Networks" scheme="https://glooow1024.github.io/categories/Communication-and-Networks/"/>
    
    
    <category term="IQ调制" scheme="https://glooow1024.github.io/tags/IQ%E8%B0%83%E5%88%B6/"/>
    
    <category term="调制与解调" scheme="https://glooow1024.github.io/tags/%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/"/>
    
    <category term="移动通信" scheme="https://glooow1024.github.io/tags/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/"/>
    
    <category term="模拟调制" scheme="https://glooow1024.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/"/>
    
    <category term="数字调制" scheme="https://glooow1024.github.io/tags/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6/"/>
    
    <category term="QAM" scheme="https://glooow1024.github.io/tags/QAM/"/>
    
    <category term="OFDM" scheme="https://glooow1024.github.io/tags/OFDM/"/>
    
  </entry>
  
  <entry>
    <title>IEEE论文爬虫及数据统计</title>
    <link href="https://glooow1024.github.io/2022/03/19/diy/paper-collector/"/>
    <id>https://glooow1024.github.io/2022/03/19/diy/paper-collector/</id>
    <published>2022-03-19T05:51:48.000Z</published>
    <updated>2022-05-01T09:52:53.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ieee论文爬虫">1. IEEE论文爬虫</h2><p>爬虫代码网上有很多了，这部分是直接用的网上可以跑通的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/wp7xtj98/article/details/112711465">[1]</span></a></sup>。使用的时候直接调用<code>get_article_info()</code>，其中参数 <code>conferenceID</code>需要手动在 IEEE 上查询会议的 ID 号，参数 <code>saceFileName</code>为希望保存的 <code>csv</code> 文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取issueNumber</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_issueNumber</span>(<span class="hljs-params">conferenceID</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Get the issueNumber from the website.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    conferenceID = <span class="hljs-built_in">str</span>(conferenceID)<br>    gheaders = &#123;<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/xpl/conhome/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/proceeding&#x27;</span>,<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#x27;</span><br>    &#125;<br>    md_url = <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/rest/publication/home/metadata?pubid=&#x27;</span>+conferenceID<br>    md_res = requests.get(md_url, headers = gheaders)<br>    md_dic = json.loads(md_res.text)<br>    issueNumber = <span class="hljs-built_in">str</span>(md_dic[<span class="hljs-string">&#x27;currentIssue&#x27;</span>][<span class="hljs-string">&#x27;issueNumber&#x27;</span>])<br>    <span class="hljs-keyword">return</span> issueNumber<br><br><span class="hljs-comment"># 爬取论文及其下载链接</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">conferenceID, saveFileName</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Collect the published paper data, and save into the csv file &quot;saveFileName&quot;.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获取issueNumber</span><br>    issueNumber = <span class="hljs-built_in">str</span>(get_issueNumber(conferenceID))<br>    conferenceID = <span class="hljs-built_in">str</span>(conferenceID)<br><br>    <span class="hljs-comment"># 记录论文数据</span><br>    dataframe = pd.DataFrame(&#123;&#125;)<br>    paper_title = []<br>    paper_author = []<br>    paper_year = []<br>    paper_citation = []<br>    paper_abstract = []<br>    paper_ieee_kwd = []<br><br>    <span class="hljs-comment"># 从第一页开始下载</span><br>    pageNumber = <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>        <span class="hljs-comment"># 获取会议文章目录</span><br>        toc_url = <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/rest/search/pub/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/issue/&#x27;</span>+issueNumber+<span class="hljs-string">&#x27;/toc&#x27;</span><br>        payload = <span class="hljs-string">&#x27;&#123;&quot;pageNumber&quot;:&#x27;</span>+<span class="hljs-built_in">str</span>(pageNumber)+<span class="hljs-string">&#x27;,&quot;punumber&quot;:&quot;&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;&quot;,&quot;isnumber&quot;:&#x27;</span>+issueNumber+<span class="hljs-string">&#x27;&#125;&#x27;</span><br>        headers = &#123;<br>            <span class="hljs-string">&#x27;Host&#x27;</span>: <span class="hljs-string">&#x27;ieeexplore.ieee.org&#x27;</span>,<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36&#x27;</span>,<br>            <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/xpl/conhome/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/proceeding?pageNumber=&#x27;</span>+<span class="hljs-built_in">str</span>(pageNumber),<br>        &#125;<br>        toc_res = requests.post(toc_url, headers = headers, data=payload)<br>        toc_dic = json.loads(toc_res.text)<br>        <span class="hljs-keyword">try</span>:<br>            articles = toc_dic[<span class="hljs-string">&#x27;records&#x27;</span>]<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:<br>                title = article[<span class="hljs-string">&#x27;highlightedTitle&#x27;</span>]<br>                paper_link = IEEE_root_url + article[<span class="hljs-string">&#x27;htmlLink&#x27;</span>]<br>                paper_info = requests.get(url=paper_link, headers=headers, timeout=<span class="hljs-number">10</span>)<br>                soup = BeautifulSoup(paper_info.text, <span class="hljs-string">&#x27;lxml&#x27;</span>)                  <span class="hljs-comment"># 解析</span><br>                <span class="hljs-comment"># 正则表达式 创建模式对象</span><br>                pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;xplGlobal.document.metadata=(.*?)&quot;&#125;;&#x27;</span>, re.MULTILINE | re.DOTALL)<br>                script = soup.find(<span class="hljs-string">&quot;script&quot;</span>, text=pattern)                     <span class="hljs-comment"># 根据模式对象进行搜索</span><br>                <span class="hljs-keyword">try</span>:<br>                    res_dic = pattern.search(script.string).group(<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;&quot;&#125;&#x27;</span>      <span class="hljs-comment"># 配合search找到字典，匹配结尾字符串，降低文章摘要中也出现这种字符串的概率</span><br>                    <span class="hljs-comment"># 解析异常，一般是因为文章 abstract 中出现了字符串 &#x27;&quot;&#125;;&#x27;</span><br>                    json_data = json.loads(res_dic)                            <span class="hljs-comment"># 将json格式数据转换为字典</span><br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(pattern.search(script.string).group(<span class="hljs-number">0</span>))<br>                    <span class="hljs-built_in">print</span>(res_dic)<br>                <span class="hljs-comment"># 保存文章信息</span><br>                paper_title.append(title)<br>                paper_year.append(json_data[<span class="hljs-string">&#x27;publicationYear&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(json_data.keys())<br>                <span class="hljs-comment">#a = input(&#x27;input anything...&#x27;)</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;author&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_author.append(json_data[<span class="hljs-string">&#x27;author&#x27;</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    paper_author.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;abstract&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_abstract.append(json_data[<span class="hljs-string">&#x27;abstract&#x27;</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    paper_abstract.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;keywords&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_ieee_kwd.append(json_data[<span class="hljs-string">&#x27;keywords&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;kwd&#x27;</span>])       <span class="hljs-comment"># ieee有三种 key words</span><br>                <span class="hljs-keyword">else</span>:<br>                    paper_ieee_kwd.append(<span class="hljs-literal">None</span>)<br>                count=count+<span class="hljs-number">1</span><br>                <span class="hljs-comment">#link = &#x27;https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=&#x27;+article[&#x27;articleNumber&#x27;]+&#x27;&amp;ref=&#x27;</span><br>                <span class="hljs-comment">#alf.write(title.replace(&#x27;\n&#x27;,&#x27;&#x27;)+&#x27;&gt;_&lt;&#x27;+link+&#x27;\n&#x27;)</span><br>            <br>            <span class="hljs-comment"># 写入csv文件</span><br>            dataframe = pd.DataFrame(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:paper_title, <span class="hljs-string">&#x27;year&#x27;</span>:paper_year, <span class="hljs-string">&#x27;abstract&#x27;</span>:paper_abstract, <span class="hljs-string">&#x27;key words&#x27;</span>:paper_ieee_kwd&#125;)<br>            dataframe.to_csv(saveFileName, index=<span class="hljs-literal">True</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Page &#x27;</span>, pageNumber, <span class="hljs-string">&#x27;, total &#x27;</span>, count, <span class="hljs-string">&#x27;papers.&#x27;</span>)<br>            pageNumber = pageNumber+<span class="hljs-number">1</span><br>            <span class="hljs-comment"># 停一下防禁ip</span><br>            <span class="hljs-keyword">import</span> time<br>            time.sleep(<span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment"># 写入csv文件</span><br>    dataframe = pd.DataFrame(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:paper_title, <span class="hljs-string">&#x27;year&#x27;</span>:paper_year, <span class="hljs-string">&#x27;abstract&#x27;</span>:paper_abstract, <span class="hljs-string">&#x27;key words&#x27;</span>:paper_ieee_kwd&#125;)<br>    dataframe.to_csv(saveFileName, index=<span class="hljs-literal">True</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="ieee论文数据统计">2. IEEE论文数据统计</h2><h2 id="写一个图形界面">3. 写一个图形界面</h2><h3 id="弹出提示窗口">3.1 弹出提示窗口</h3><p>在写代码过程中有时候需要测试功能是否成功实现，于是想要加一个弹出窗口的函数可以显示调试信息，用以验证想要的功能是否正常实现。主要难点在于根据内容自动调整窗口大小，以获得较好的显示效果。</p><p>采用的方法是利用 <code>QLabel.adjust()</code>函数获取文本显示的宽度，并据此调整窗口的大小<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> (QWidget, QDialog, QLabel, QPushButton)<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> (QSize, QRect)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.dialog_btn = QPushButton(<span class="hljs-string">&#x27;Click&#x27;</span>)<br>        self.dialog_btn.clicked.connect(self.click_callback)<br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">click_callback</span>(<span class="hljs-params">self</span>):</span><br>        self.show_dialog(<span class="hljs-string">&#x27;You clicked me!&#x27;</span>)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_dialog</span>(<span class="hljs-params">self, info</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Pop up dialogs for debug.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        hint_dialog = QDialog()<br>        hint_dialog.setWindowTitle(<span class="hljs-string">&#x27;Hint info&#x27;</span>)<br>        <span class="hljs-comment">#hint_dialog.setWindowModality(PyQt6.QtCore.Qt.NonModal)</span><br><br>        hint_info = QLabel(info, hint_dialog)<br>        hint_info.adjustSize()<br>        padding = <span class="hljs-number">20</span><br>        max_width = <span class="hljs-number">360</span><br>        <span class="hljs-comment"># set the maximum width</span><br>        <span class="hljs-keyword">if</span> hint_info.size().width() &gt; max_width:<br>            hint_info.setGeometry(QRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, max_width, <span class="hljs-number">80</span>))<br>            hint_info.setWordWrap(<span class="hljs-literal">True</span>)<br>        hint_info.move(padding, padding)<br><br>        hint_dialog.resize(hint_info.size() + QSize(padding*<span class="hljs-number">2</span>, padding*<span class="hljs-number">2</span>))<br>        hint_dialog.<span class="hljs-built_in">exec</span>()<br></code></pre></td></tr></table></figure><h3 id="文本框显示爬取日志">3.2 文本框显示爬取日志</h3><p>我希望在窗口中增加一个文本框，将爬取过程中的日志信息打印出来，便于用户实时监测。</p><p>采用的思路是定义一个<code>logging.Logger</code>，将其日志信息同时输出到窗口的文本框和控制台中打印，通过自定义<code>logging.Handler</code>可以实现这一功能<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.gitbook.io/p/360306588">[3]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://stackoverflow.com/questions/41176319/python-logging-output-on-both-gui-and-console">[5]</span></a></sup><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://stackoverflow.com/questions/24371274/how-to-dynamically-update-qtextedit">[6]</span></a></sup>。实现方式为：</p><ol type="1"><li><p>继承 <code>logging.Handler</code>类，并初始化阶段将整个窗口(<code>QWidget</code>类)作为参数传入，便于后续修改窗口的信息；</p></li><li><p>自定义实现 <code>emit</code> 函数，在 <code>emit</code> 函数中将log 信息同时输出到窗口文本框、打印到控制台；</p></li><li><p>创建 <code>logger</code> 的时候设置Handler<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/qq_37541097/article/details/108317762">[4]</span></a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ex = PaperCollector()<br>logger = logging.getLogger(<span class="hljs-string">&quot;logger&quot;</span>)<br>handler = LogHandler(ex)<br>logger.addHandler(handler)<br></code></pre></td></tr></table></figure></li></ol><p>下面是这部分功能相关的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogHandler</span>(<span class="hljs-params">logging.Handler</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.parent = parent<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">emit</span>(<span class="hljs-params">self, record</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">print</span>(self.<span class="hljs-built_in">format</span>(record))<br>            self.parent.print_log(self.<span class="hljs-built_in">format</span>(record))<br>            QApplication.processEvents()<br>        <span class="hljs-keyword">except</span> Exception:<br>            self.handleError(record)<br>            <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the UI playout.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># button to start crawing</span><br>        self.startCrawling_button = QPushButton(<span class="hljs-string">&#x27;Start&#x27;</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;Click and wait for collecting published paper data.&#x27;</span>)<br>        self.startCrawling_button.clicked.connect(self.start_collect_paper)<br>        <span class="hljs-comment"># print log</span><br>        self.process = QTextEdit(readOnly=<span class="hljs-literal">True</span>)<br>        self.process.setFont(QFont(<span class="hljs-string">&quot;Source Code Pro&quot;</span>,<span class="hljs-number">9</span>))<br>        <br>        grid = QGridLayout()<br>        grid.setSpacing(<span class="hljs-number">10</span>)<br>        grid.addWidget(self.startCrawling_button, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        grid.addWidget(self.process, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>        self.setLayout(grid)<br>        <br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">700</span>, <span class="hljs-number">300</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">global</span> logger<br>        <span class="hljs-comment">#self.show_dialog(&#x27;start!&#x27;)</span><br>        get_article_info(self.conferenceID_edit.text(), self.saveFile_edit.text(), logger)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_log</span>(<span class="hljs-params">self, s</span>):</span><br>        self.process.append(s)<br>        <br>logger = <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    app = QApplication(sys.argv)<br>    ex = PaperCollector()<br><br>    <span class="hljs-keyword">global</span> logger<br>    logger = logging.getLogger(<span class="hljs-string">&quot;logger&quot;</span>)<br>    logger.setLevel(logging.INFO)<br>    formater = logging.Formatter(fmt=<span class="hljs-string">&quot;%(asctime)s [%(levelname)s] : %(message)s&quot;</span><br>                ,datefmt=<span class="hljs-string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>)<br>    handler = LogHandler(ex)<br>    handler.setFormatter(formater)<br>    logger.addHandler(handler)<br><br>    sys.exit(app.<span class="hljs-built_in">exec</span>())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>爬取论文的主函数如下，其中一个参数为<code>logger</code>，在函数内部需要打印日志信息的地方添加<code>logger.info(...)</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">conferenceID, saveFileName, logger</span>):</span><br>    logger.info(<span class="hljs-string">&#x27;collecting paper......&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="多线程避免卡顿">3.3 多线程避免卡顿</h3><p>上述打印日志的方法不能做到实时输出信息到窗口文本框，而是会等到所有论文爬取完毕之后再一股脑的更新，这是因为PyQt的界面线程是主线程，当爬虫开始工作时，也是运行在主线程中，这时主界面就无法更新，看起来就像是卡死了。解决方法就是开一个子线程运行爬虫工作<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客"&gt;[7]</span></a></sup>。</p><p>具体实现细节为：</p><ol type="1"><li>新建类 <code>SpiderThread</code> 继承 <code>QObject</code>，自定义<code>run</code> 函数，在其中运行爬虫程序；</li><li>在 <code>SpiderThread</code> 类中定义一个<code>_spider_finish = pyqtSignal()</code>，该信号用于告知主线程爬虫子线程已完成工作</li><li>在 <code>PaperCollector</code> 类中定义一个<code>_start_spider = pyqtSignal(str, str, logging.Logger)</code>，该信号用于启动爬虫子线程<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/gong_xufei/article/details/89786272">[8]</span></a></sup><sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/qq_39560620/article/details/105711799">[9]</span></a></sup>；</li><li>通过 <code>pyqtSignal.connect</code>分别将各个信号连接到对应的槽（处理函数）上；</li></ol><p>下面是这部分功能相关的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> (QObject, pyqtSignal, QThread)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderThread</span>(<span class="hljs-params">QObject</span>):</span><br>    _spider_finish = pyqtSignal()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.flag_running = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt; __del__&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, conference_ID, save_filename, logger</span>):</span><br>        get_article_info(conference_ID, save_filename, logger)<br>        self._spider_finish.emit()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    _start_spider = pyqtSignal(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, logging.Logger)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <span class="hljs-comment">#sys.stdout = LogStream(newText=self.onUpdateText)</span><br><br>        self.spiderT = SpiderThread()<br>        self.thread = QThread(self)<br>        self.spiderT.moveToThread(self.thread)<br>        self._start_spider.connect(self.spiderT.run)        <span class="hljs-comment"># 只能通过信号槽启动线程处理函数</span><br>        self.spiderT._spider_finish.connect(self.finish_collect_paper)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        <br>        self.startCrawling_button.setEnabled(<span class="hljs-literal">False</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;I\&#x27;m trying very hard to collect papers &gt;_&lt;&#x27;</span>)<br>        <span class="hljs-comment"># 先启动QThread子线程</span><br>        self.thread.start()<br>        <span class="hljs-comment"># 发送信号，启动线程处理函数</span><br>        <span class="hljs-comment"># 不能直接调用，否则会导致线程处理函数和主线程是在同一个线程，同样操作不了主界面</span><br>        <span class="hljs-keyword">global</span> logger<br>        self._start_spider.emit(self.conferenceID_edit.text(), self.saveFile_edit.text(), logger)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        self.startCrawling_button.setEnabled(<span class="hljs-literal">True</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;Click and wait for collecting published paper data ^o^&#x27;</span>)<br>        self.thread.quit()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        self.thread.quit()      <span class="hljs-comment"># 退出</span><br>        self.thread.wait()      <span class="hljs-comment"># 回收资源</span><br>        self.show_dialog(<span class="hljs-string">&#x27;stop!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="流畅中止子线程">3.4 流畅中止子线程</h3><p>有时候我们需要中途停止爬虫工作，比如发现会议ID设置错误、希望先对已经爬取的部分数据进行统计分析等。在上面的实现中，尽管线程正常运行很流畅，但是如果在爬虫运行中途点击停止按钮，程序就会卡死。</p><p>在原本的爬虫脚本中，<code>get_article_info()</code>函数内部的爬虫采用了 <code>while(True)</code> 死循环，主线程中直接用<code>self.thread.quit()</code>强制退出，从控制台来看这样确实可以停掉，但是Qt窗口却总是会卡死。原因我也不太清楚，采用的解决方法是：</p><ol type="1"><li>定义一个爬虫类 <code>IEEESpider</code>，设置成员变量<code>flag_running</code>，将函数 <code>get_article_info</code>也设置为类成员函数；</li><li>将 <code>get_article_info</code> 中的循环改为<code>while(self.flag_running)</code>；</li><li>在主线程中想要停止爬虫子线程的时候，只需要首先设置<code>flag_running=False</code>，那么爬虫子线程在当前一次循环结束后就自动结束，这个时候主线程调用<code>self.thread.quit()</code> 就不会导致界面卡死。需要注意的是设置<code>flag_running=False</code> 一定要 <code>sleep</code>一段时间，以保证爬虫子线程能够结束当前循环，否则还是容易卡死。</li></ol><p>下面是这部分功能的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IEEESpider</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.flag_running = <span class="hljs-literal">False</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">self, conferenceID, saveFileName, logger</span>):</span><br>        <span class="hljs-keyword">while</span>(self.flag_running):<br>            <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderThread</span>(<span class="hljs-params">QObject</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment">#self.flag_running = False</span><br>        self.ieee_spider = IEEESpider()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, conference_ID, save_filename, logger</span>):</span><br>        self.ieee_spider.flag_running = <span class="hljs-literal">True</span><br>        self.ieee_spider.get_article_info(conference_ID, save_filename, logger)<br>        self._spider_finish.emit()<br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        self.spiderT.ieee_spider.flag_running = <span class="hljs-literal">False</span><br>        time.sleep(<span class="hljs-number">15</span>)<br>        self.thread.quit()      <span class="hljs-comment"># 退出</span><br>        <span class="hljs-comment">#self.thread.wait()      # 回收资源</span><br>        self.show_dialog(<span class="hljs-string">&#x27;stop!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="增加侧边导航栏">3.5 增加侧边导航栏</h3><p>前面只有爬取论文的页面，现在我想加上数据分析的页面，那么就需要设置一个侧边导航栏，以切换两种不同的任务。</p><p>实现方式为左侧设置多个按钮，右侧添加一个<code>QTabWidget()</code>，将不同的页面设置为子标签页，通过按钮的点击回调函数切换不同的标签页<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebarUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the UI playout of sidebar.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.sidebar_btn_1 = QPushButton(<span class="hljs-string">&#x27;Collector&#x27;</span>, self)<br>        self.sidebar_btn_1.clicked.connect(self.sidebar_button_1)<br>        self.sidebar_btn_2 = QPushButton(<span class="hljs-string">&#x27;Analyzer&#x27;</span>, self)<br>        self.sidebar_btn_2.clicked.connect(self.sidebar_button_2)<br>        self.sidebar_btn_3 = QPushButton(<span class="hljs-string">&#x27;Reserved&#x27;</span>, self)<br>        self.sidebar_btn_3.clicked.connect(self.sidebar_button_3)<br><br>        sidebar_layout = QVBoxLayout()<br>        sidebar_layout.addWidget(self.sidebar_btn_1)<br>        sidebar_layout.addWidget(self.sidebar_btn_2)<br>        sidebar_layout.addWidget(self.sidebar_btn_3)<br>        sidebar_layout.addStretch(<span class="hljs-number">5</span>)<br>        sidebar_layout.setSpacing(<span class="hljs-number">20</span>)<br><br>        self.sidebar_widget = QWidget()<br>        self.sidebar_widget.setLayout(sidebar_layout)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_1</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_2</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_3</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">2</span>)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the overall UI playout.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.sidebarUI()<br>        self.spiderUI()<br>        self.analyzerUI()<br>        self.reservedUI()<br>        <br>        <span class="hljs-comment"># 多个标签页</span><br>        self.right_widget = QTabWidget()<br>        self.right_widget.tabBar().setObjectName(<span class="hljs-string">&quot;mainTab&quot;</span>)<br><br>        self.right_widget.addTab(self.spider_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br>        self.right_widget.addTab(self.analyzer_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br>        self.right_widget.addTab(self.reserved_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br><br>        <span class="hljs-comment"># 隐藏标签部件的标签并初始化显示页面</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">0</span>)<br>        self.right_widget.setStyleSheet(<span class="hljs-string">&#x27;&#x27;&#x27;QTabBar::tab&#123;width: 0; height: 0; margin: 0; padding: 0; border: none;&#125;&#x27;&#x27;&#x27;</span>)<br><br>        <span class="hljs-comment"># overall layout</span><br>        main_layout = QHBoxLayout()<br>        main_layout.addWidget(self.sidebar_widget)<br>        main_layout.addWidget(self.right_widget)<br>        main_layout.setStretch(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)<br>        main_layout.setStretch(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>)<br>        self.setLayout(main_layout)<br><br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">850</span>, <span class="hljs-number">300</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br></code></pre></td></tr></table></figure><h3 id="next-...">3.6 next ...</h3><p>接下来考虑：写数据分析页面 ......</p><h1 id="referencce">Referencce</h1><p>这里关于参考文献的部分，本来我想按照下面格式来写，希望实现的效果是都像<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>一样，每一条引用列出来的是超链接，而不是直接写出来链接地址，但是我发现除了第<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>条，其他条这么写话都会像现在的第<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客"&gt;[7]</span></a></sup>条一样，格式会乱，也不知道为什么。有人知道的话可以告诉我嘛&gt;_&lt;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">[^<span class="hljs-number">1</span>]:[Python爬虫——爬取IEEE论文 - 乐 ShareLe的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wp7xtj98/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">112711465</span>)<br>[^<span class="hljs-number">2</span>]:[PyQt 中文教程 (gitbook.io)](https:<span class="hljs-regexp">//m</span>aicss.gitbook.io<span class="hljs-regexp">/pyqt-chinese-tutoral/</span>)<br>[^<span class="hljs-number">3</span>]:[python日志：logging模块使用 - 知乎](https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">360306588</span>)<br>[^<span class="hljs-number">4</span>]:[python3 自定义logging.Handler, Formatter, Filter模块 - 太阳花的小绿豆的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_37541097/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">108317762</span>)<br>[^<span class="hljs-number">5</span>]:[python logging output on both GUI and console - stackoverflow](https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">41176319</span>/python-logging-output-on-both-gui-and-console)<br>[^<span class="hljs-number">6</span>]:[How to dynamically update QTextEdit - stackoverflow](https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">24371274</span>/how-to-dynamically-update-qtextedit)<br>[^<span class="hljs-number">7</span>]:[PyQt - 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/bailang_zhizun/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">109240670</span>)<br>[^<span class="hljs-number">8</span>]:[pyqt 带单个参数<span class="hljs-regexp">/多个参数信号&amp;槽总结 - gong xufei的博客 - CSDN博客](https:/</span><span class="hljs-regexp">/blog.csdn.net/g</span>ong_xufei<span class="hljs-regexp">/article/</span>details/<span class="hljs-number">89786272</span>)<br>[^<span class="hljs-number">9</span>]:[PyQt5 pyqtSignal: 自定义信号传入的参数方法 - Mic28的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_39560620/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">105711799</span>)<br>[^<span class="hljs-number">10</span>]:[PyQt5 侧边栏布局 • Chang Luo (luochang.ink)](https:<span class="hljs-regexp">//</span>www.luochang.ink<span class="hljs-regexp">/posts/</span>pyqt5_layout_sidebar/)<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://blog.csdn.net/wp7xtj98/article/details/112711465<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://maicss.gitbook.io/pyqt-chinese-tutoral/">PyQt中文教程 (gitbook.io)</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.gitbook.io/p/360306588<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/qq_37541097/article/details/108317762<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://stackoverflow.com/questions/41176319/python-logging-output-on-both-gui-and-console<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://stackoverflow.com/questions/24371274/how-to-dynamically-update-qtextedit<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客</a><a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://blog.csdn.net/gong_xufei/article/details/89786272<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9"class="footnote-text"><span>https://blog.csdn.net/qq_39560620/article/details/105711799<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10"class="footnote-text"><span><a href="https://www.luochang.ink/posts/pyqt5_layout_sidebar/">PyQt5侧边栏布局 • Chang Luo (luochang.ink)</a><a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ieee论文爬虫&quot;&gt;1. IEEE论文爬虫&lt;/h2&gt;
&lt;p&gt;爬虫代码网上有很多了，这部分是直接用的网上可以跑通的&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span</summary>
      
    
    
    
    <category term="DIY" scheme="https://glooow1024.github.io/categories/DIY/"/>
    
    
    <category term="spider" scheme="https://glooow1024.github.io/tags/spider/"/>
    
    <category term="PyQt" scheme="https://glooow1024.github.io/tags/PyQt/"/>
    
    <category term="多线程" scheme="https://glooow1024.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SLAM综述</title>
    <link href="https://glooow1024.github.io/2022/03/02/research/SLAM-survey/"/>
    <id>https://glooow1024.github.io/2022/03/02/research/SLAM-survey/</id>
    <published>2022-03-02T03:14:56.000Z</published>
    <updated>2022-03-03T10:57:13.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于SLAM（simultaneous localization andmapping）问题一个很粗糙的总结。</p></blockquote><p>对于SLAM的发展历程，Leonard和Reid大佬将SLAM到目前为止的发展过程总结为三个阶段：</p><ol type="1"><li>classicalage（1986-2004）：早期阶段，SLAM问题的定义、基于概率框架的建模和求解方法；</li><li>algorithm-analysisage（2004-2015）：深入研究SLAM问题的一些性质，比如稀疏性、收敛性、一致性等，更多样、更高效的算法也被相继提出；</li><li>robust-perceptionage（2015-）：开始考虑算法的鲁棒性、可扩展性、资源约束下的高效算法、高层语义认知任务导向等；</li></ol><p>SALM系统主要包括前端和后端两部分，前端负责从传感器数据中提取特征、dataassociation（如特征提取、回环检测）等，后端负责最大后验估计、滤波等；</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/slam-1.png"alt="SLAM" /><figcaption aria-hidden="true">SLAM</figcaption></figure><p>根据<strong>感知手段</strong>可以分为几类：</p><ul><li>测距测角：传感器比如毫米波雷达、声纳等；</li><li>视觉相机：各种相机，比如RGB-D相机等；需要从图像中提取特征点，例如SIFT等；纯视觉导航有专门的研究方向，即VO（VisualOdometry），VO+全局地图优化（例如回环检测）=visual SLAM；</li><li>激光雷达；</li><li>惯性导航：IMU，配合视觉传感器可以实现VIO；</li></ul><p>根据<strong>地图结构</strong>可以分为几类（地图结构与感知手段紧密相关）：</p><ul><li>基于landmarkd的，传感器通常是测距测角的，或者视觉中提取特征点；</li><li>栅格地图（2D）、点云地图（3D），主要是激光雷达；</li><li>基于边/表面的几何地图；</li></ul><p>根据<strong>求解方法</strong>可以分为几类：</p><ul><li>基于贝叶斯框架递归滤波的：如EKF、PF、Information Filter等；</li><li>基于优化的：一种是光束平差法（用于视觉，实际上是最小二乘）；另一种是图优化（graphSLAM，实际上就是概率图模型，似乎是现在的主流）；</li><li>Set Membership 类的方法、以及定性方法等；</li></ul><p>要考虑的科学问题包括：</p><ul><li>地图构建和机器人位姿估计，因此实际上是参数估计/求解问题；</li><li>多传感器数据融合，以及与已有地图信息的融合；</li><li>回环检测，纠正累积误差；</li><li>降低复杂度，比如每次只更新相关的部分地图和状态，而不是所有参数一起更新；</li><li>数据关联；</li></ul><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/slam-2.jpg"alt="SLAM" /><figcaption aria-hidden="true">SLAM</figcaption></figure><p>除了基本的SLAM问题，还有一些发展方向：</p><ul><li>ActiveSLAM：同时考虑机器人的运动控制，与exploration-exploitation问题相关；</li><li>多机SLAM，相比于单机需要考虑的问题：<ul><li>多机协作的架构：集中式（online or offline？）、分布式；</li><li>相邻机器之间的数据交互，防止数据伦理问题，即一个数据在多个机器上重复使用多次；</li><li>每个机器的地图更新方法；</li><li>数据关联问题；</li><li>通信负载、数据压缩、地图结构优化等；</li></ul></li></ul><h2 id="reference">Reference</h2><ol type="1"><li>Dissanayake, MWM Gamini, et al. "A solution to the simultaneouslocalization and map building (SLAM) problem." <em>IEEE Transactions onrobotics and automation</em> 17.3 (2001): 229-241.</li><li>Durrant-Whyte, Hugh, and Tim Bailey. "Simultaneous localization andmapping: part I." <em>IEEE robotics &amp; automation magazine</em> 13.2(2006): 99-110.</li><li>Bailey, Tim, and Hugh Durrant-Whyte. "Simultaneous localization andmapping (SLAM): Part II." <em>IEEE robotics &amp; automationmagazine</em> 13.3 (2006): 108-117.</li><li>Bresson, Guillaume, et al. "Simultaneous localization and mapping: Asurvey of current trends in autonomous driving." <em>IEEE Transactionson Intelligent Vehicles</em> 2.3 (2017): 194-220.</li><li>Taketomi, Takafumi, Hideaki Uchiyama, and Sei Ikeda. "Visual SLAMalgorithms: A survey from 2010 to 2016." <em>IPSJ Transactions onComputer Vision and Applications</em> 9.1 (2017): 1-11.</li><li>Cadena, Cesar, et al. "Past, present, and future of simultaneouslocalization and mapping: Toward the robust-perception age." <em>IEEETransactions on robotics</em> 32.6 (2016): 1309-1332.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于SLAM（simultaneous localization and
mapping）问题一个很粗糙的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于SLAM的发展历程，Leonard和Reid大佬将SLAM到目前为止的发展过程总</summary>
      
    
    
    
    <category term="Research" scheme="https://glooow1024.github.io/categories/Research/"/>
    
    
    <category term="SLAM" scheme="https://glooow1024.github.io/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>我的电脑（不时更新）</title>
    <link href="https://glooow1024.github.io/2022/01/24/software/prepare-my-pc/"/>
    <id>https://glooow1024.github.io/2022/01/24/software/prepare-my-pc/</id>
    <published>2022-01-24T14:32:33.000Z</published>
    <updated>2022-02-21T01:05:53.362Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了电脑，很多软件都要重装，遂记录一下自己电脑常用的软件。</p><h2 id="日常必备">1. 日常必备</h2><ul><li><strong>通讯类</strong>：微信、TIM、Foxmail；</li><li><strong>办公类</strong>：Office、Onenote、Foxit、腾讯会议；</li><li><strong>浏览器</strong>：Edge、Chrome；</li><li><strong>影音娱乐</strong>：网易云音乐、PotPlayer、Irfan View；</li><li><strong>其他</strong>：WinRAR、KeePass2；</li></ul><h2 id="学习科研">2. 学习科研</h2><ul><li><strong>编程</strong>：VSCode、Matlab、Python、Emeditor、Git；</li><li><strong>阅读器</strong>：知云文献翻译、Pdf Xodo、CAJ Viewer；</li><li><strong>写作</strong>：Typora、Texlive + Summatra、Mathpix SnippingTool、IguanaTex（ppt插件）、Aurora（word插件）；</li><li><strong>云盘</strong>：百度云盘、Seafile、坚果云；</li></ul><h2 id="效率工具">3. 效率工具</h2><ul><li>MobaXterm：远程连接工具；</li><li>向日葵：远程桌面；</li><li>Everything：文件搜索；</li><li>Calibre：电子书阅读器；</li><li>Beyond Compare：文本文件对比；</li><li>Space Sniffer：磁盘空间统计；</li><li>Captura：录屏；</li><li>Hexo：个人静态博客（需要nodejs，最好装个nvm）；</li><li>Pic Go：图床管理工具；</li><li>Gitbook：个人书籍；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近换了电脑，很多软件都要重装，遂记录一下自己电脑常用的软件。&lt;/p&gt;
&lt;h2 id=&quot;日常必备&quot;&gt;1. 日常必备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通讯类&lt;/strong&gt;：微信、TIM、Foxmail；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;办公类&lt;/st</summary>
      
    
    
    
    <category term="Software" scheme="https://glooow1024.github.io/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>【高等数值分析】Krylov子空间方法</title>
    <link href="https://glooow1024.github.io/2022/01/24/advanced-numerical-analysis/ada-krylov/"/>
    <id>https://glooow1024.github.io/2022/01/24/advanced-numerical-analysis/ada-krylov/</id>
    <published>2022-01-24T13:35:19.000Z</published>
    <updated>2022-01-24T09:37:22.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>现在需要求解一个大规模稀疏方程组 <spanclass="math inline">\(Ax=b\)</span>，可以用迭代法比如 Jacobi迭代法、Gauss-Seidel 迭代法等，不过这一节要讨论的是 Krylov子空间方法，核心部分是 Arnoldi 迭代。</p><span id="more"></span><h3 id="krylov-子空间">1.1 Krylov 子空间</h3><p><strong>定理（Cayley-Hamilton）</strong>：设 <spanclass="math inline">\(A\in{\mathbb C}^{n\times n}\)</span>，则 <spanclass="math inline">\(A\)</span> 的特征多项式 <spanclass="math inline">\(\chi(z)\)</span> 是 <spanclass="math inline">\(A\)</span> 的零化多项式，也即 <spanclass="math inline">\(\chi(A)=0\)</span>。</p><p>假设特征多项式 <span class="math inline">\(\chi(z)=z^n +c_{n-1}z^{n-1} + \cdots + c_1 z+ c_0=(-1)^n\operatorname{det}(A)\)</span>，那么根据 <spanclass="math inline">\(\chi(A)=0\)</span> 可以得到 <spanclass="math display">\[A^{-1} = -\frac{1}{c_0} A^{n-1} - \frac{c_{n-1}}{c_0} A^{n-2} + \cdots-\frac{c_1}{c_0} I = q_{n-1}(A)\]</span> 利用这个等式，在求解线性方程组的时候，给定任意初值 <spanclass="math inline">\(x_0\)</span>，都有 <spanclass="math inline">\(Ax^{\ast}-Ax_0=b-Ax_0 \equiv r_0\)</span>，于是<span class="math inline">\(x^{\ast} = x_0 +q_{n-1}(A)r_0\)</span>，因此理论上可以在空间 <spanclass="math display">\[\mathcal{K}=\left\{\boldsymbol{r}_{0}, A \boldsymbol{r}_{0}, \cdots,A^{m} \boldsymbol{r}_{0}, \cdots, A^{n-1} \boldsymbol{r}_{0}\right\}\]</span> 中找到方程组的准确解，但是科学与工程计算问题中 <spanclass="math inline">\(n\)</span> 可以达到 <spanclass="math inline">\(10^6\)</span>量级，直接求解代价太高。因此希望在其一个低维子空间中搜索近似解。</p><p>定义 <span class="math inline">\(m\)</span> 维 <strong>Krylov子空间</strong>为 <span class="math display">\[\mathcal{K}_{m}=\operatorname{span}\left(\boldsymbol{r}_{0}, A\boldsymbol{r}_{0}, A^{2} \boldsymbol{r}_{0}, \cdots, A^{m-1}\boldsymbol{r}_{0}\right)\]</span> 方程组求解问题转化为 <span class="math display">\[\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} - x\Vert.\]</span></p><h3 id="最佳逼近">1.2 最佳逼近</h3><p>现在的问题就是在何种范数意义下求解问题 <spanclass="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} -x\Vert\)</span>。假设 <span class="math inline">\({\mathcalK}_m\)</span> 的一组基作为列向量构成矩阵 <spanclass="math inline">\(V_m\)</span>，最优解为 <spanclass="math inline">\(x_m = x_0 + V_m y^{\ast} \in x_0 + {\mathcal K}_m,~ y^{\ast}\in{\mathbb R}^{m}\)</span>。</p><h4 id="方法一最佳平方逼近">1.2.1 方法一：最佳平方逼近</h4><p>取 <span class="math inline">\(2\)</span> 范数 <spanclass="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} -x\Vert_2\)</span>，那么根据最佳平方逼近条件（对<spanclass="math inline">\(x\)</span>求导，取零点），或者 <strong>Galerkin正交条件</strong>，可以推出<strong>法方程</strong>为 <spanclass="math display">\[\begin{align}&amp;\langle x^{\ast} - x_m, y \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; V_m^{\rm T}(x^{\ast}-x_m) = 0\end{align}\]</span> 但是这个方法<strong>不可行</strong>！因为要求 <spanclass="math inline">\(x_m\)</span> 就需要知道 <spanclass="math inline">\(x^{\ast}\)</span>。</p><h4 id="方法二假设-a-对称正定">1.2.2 方法二：假设 <spanclass="math inline">\(A\)</span> 对称正定</h4><p>若 <span class="math inline">\(A\)</span>对称正定，那么可以改求解问题 <span class="math inline">\(\min_{x\inx_0+{\mathcal K}_m} \langle A(x-x^{\ast}),x-x^{\ast}\rangle\)</span>，根据<strong>Galerkin正交条件</strong>有法方程 <span class="math display">\[\begin{align}&amp;\langle A(x^{\ast} - x_m), y \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; r_m = A(x^{\ast}-x_m) \perp {\mathcal K}_m \\\iff &amp; V_m^{\rm T}(r_0 - Ax_m) = 0\end{align}\]</span>这个方法<strong>可行</strong>！后面需要做两件事情：1）求出一组基 <spanclass="math inline">\(V_m\)</span>；2）解法方程。</p><blockquote><p><strong>Note</strong>：这里为了得到法方程，需要假设 <spanclass="math inline">\(A\)</span> 对称正定。但是在后面的 FOM 方法中，不论<span class="math inline">\(A\)</span> 是否正定，都基于 Galerkin条件直接采用了这一法方程来求解线性方程组。至于这么做是否有理论支持我也不太清楚，就姑且相信它是合理的。</p></blockquote><h4 id="方法三残差2范数">1.2.3 方法三：残差2范数</h4><p>当 <span class="math inline">\(A\)</span> 非奇异，不去求解 <spanclass="math inline">\(\min \Vert x^{\ast} - x\Vert\)</span>，而是求解<span class="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \VertA(x^{\ast} - x)\Vert_2\)</span>，那么再次根据 <strong>Galerkin条件</strong>，可以导出<strong>法方程</strong> <spanclass="math display">\[\begin{align}&amp;\langle A(x^{\ast} - x_m), Ay \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; r_m = A(x^{\ast}-x_m) \perp A{\mathcal K}_m \\\iff &amp; V_m^{\rm T}A^{\rm T}(r_0 - Ax_m) = 0\end{align}\]</span> 这个方法也是<strong>可行</strong>的。</p><p>不论如何，上面几种方法最后都归结为两个问题：</p><ol type="1"><li>获得 <span class="math inline">\({\mathcal K}_m\)</span> 的基底<span class="math inline">\(V_m\)</span>：Gram-Schmidt 正交化方法；</li><li>求解法方程，并且计算残差：低维线性方程组求解。</li></ol><h2 id="基底正交化">2. 基底正交化</h2><p>获得正交基底的方法主要有 Arnoldi 过程（CGS）、改进 Arnoldi过程（MGS）、以及 Lanczos 过程。名字起的很fancy，别被吓到，其实他们都只是 Gram-Schmidt 正交化方法。</p><h3 id="arnoldi-过程cgs">2.1 Arnoldi 过程（CGS）</h3><p>迭代过程可以归结为 <span class="math display">\[\begin{aligned}\boldsymbol{v}_{1} &amp;= \boldsymbol{r}_{0} / \Vert \boldsymbol{r}_{0}\Vert \\\boldsymbol{w}_{j} &amp;=A \boldsymbol{v}_{j}-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{1}\rangle \boldsymbol{v}_{1}-\langleA \boldsymbol{v}_{j},\boldsymbol{v}_{2}\rangle  \boldsymbol{v}_{2}-\cdots-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{j}\rangle \boldsymbol{v}_{j} \\\boldsymbol{v}_{j+1}&amp;=\frac{\boldsymbol{w}_{j}}{\left\|\boldsymbol{w}_{j}\right\|_{2}},j=1,2, \cdots \\h_{i,j} &amp;= \langle A \boldsymbol{v}_{j}, \boldsymbol{v}_{i}\rangle\end{aligned}\]</span> 得到的 <span class="math inline">\(\{ v_1, v_2, ..., v_m,...,v_n \}\)</span> 是单位正交基。由 <spanclass="math inline">\(h_{i,j}\)</span> 作为元素构成矩阵 <spanclass="math inline">\(H_m \in {\mathbb R}^{m\times m}\)</span>，可以验证<span class="math inline">\(H_m\)</span> 为 Hessenberg 阵，并且 <spanclass="math inline">\(h_{i+1,i}=\Vert \boldsymbol{w}_{i}\Vert_2\)</span>。在 <span class="math inline">\(H_m\)</span>的基础上可以定义 <span class="math inline">\(\bar{H}_m \in {\mathbbR}^{(m+1)\times m}\)</span>，也就是在最后一行下面再加一行 <spanclass="math inline">\([0,...,0,h_{m+1,m}]\)</span>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-cgs.png"alt="CGS-psudocode" /><figcaption aria-hidden="true">CGS-psudocode</figcaption></figure><p>可以验证他们满足如下等式，这三个式子在后面会频繁用到，极其重要！<span class="math display">\[\begin{align}AV_m &amp;= V_m H_m + \boldsymbol{w}_{m} \boldsymbol{e}_{m}^{\rm T} \\&amp;= V_{m+1} \bar{H}_m \\V_m^{\rm T} A V_m &amp;= H_m\end{align}\]</span> <imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-arnoldi.png"alt="Arnoldi" /></p><h3 id="改进-arnoldi-过程mgs">2.2 改进 Arnoldi 过程（MGS）</h3><p>前面的 Arnoldi 过程在计算 <spanclass="math inline">\(\boldsymbol{w}_{j}\)</span> 的时候，相当于把 <spanclass="math inline">\(A \boldsymbol{v}_{j}\)</span> 分别计算了 <spanclass="math inline">\(j\)</span> 次投影，每次都是向一个一维的子空间<span class="math inline">\(\operatorname{span}\{ \boldsymbol{v}_{i}\}\)</span>投影，可能会有计算不稳定的问题。对其进行改进的方法如下，交换顺序之后，每次都是向一个<span class="math inline">\(n-1\)</span> 维子空间投影。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-mgs.png"alt="MGS-psudocode" /><figcaption aria-hidden="true">MGS-psudocode</figcaption></figure><h3 id="lanczos过程">2.3 Lanczos过程</h3><p>是 Arnoldi 过程的特殊情况，当 <span class="math inline">\(A=A^{\rmT}\)</span>，那么 <span class="math inline">\(H_m\)</span>为三对角矩阵，那么 <spanclass="math inline">\(\boldsymbol{w}_{j}\)</span> 的计算简化为 <spanclass="math display">\[\boldsymbol{w}_{j} = A \boldsymbol{v}_{j}-\langle A \boldsymbol{v}_{j},\boldsymbol{v}_{j-1}\rangle \boldsymbol{v}_{j-1}-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{j}\rangle \boldsymbol{v}_{j}\]</span></p><h2 id="方程组求解">3. 方程组求解</h2><p>针对上面几种不同的迭代过程，可以有不同的求解方法。</p><h3 id="全正交方法-fom">3.1 全正交方法 (FOM)</h3><p>FOM (Full orthogonalization method) 根据 Galerkin 条件，<spanclass="math inline">\(r_m\perp {\mathcal K}_m\)</span>，根据法方程 <spanclass="math inline">\(V_m^{\rm T}(r_0 - AV_my)=0\)</span>，因此有 <spanclass="math display">\[\begin{align}&amp; r_m\perp {\mathcal K}_m \iff V_m^{\rm T}(r_0 - AV_my)=0\Longrightarrow H_m y = \Vert r_0\Vert \boldsymbol{e}_1\end{align}\]</span> 伪代码为</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-fom.png"alt="FOM" /><figcaption aria-hidden="true">FOM</figcaption></figure><p>根据 <span class="math inline">\(x_m = x_0 + V_m y\)</span>，残差有<span class="math inline">\(r_m = r_0-AV_my=r_0-(V_m H_m +\boldsymbol{w}_{m} \boldsymbol{e}_{m}^{\rm T})y = -\boldsymbol{w}_{m}\boldsymbol{e}_{m}^{\rm T} y\)</span>。</p><h3 id="d-lanczos方法">3.2 D-Lanczos方法</h3><p>若 <span class="math inline">\(A\)</span> 对称，那么 <spanclass="math inline">\(H_m\)</span> 为三对角阵，特别地记为 <spanclass="math inline">\(T_m\)</span> <span class="math display">\[T_{m}=\left(\begin{array}{ccccc}\alpha_{1} &amp; \beta_{2} &amp; &amp; &amp; \\\beta_{2} &amp; \alpha_{2} &amp; \beta_{3} &amp; &amp; \\&amp; \ddots &amp; \ddots &amp; \ddots &amp; \\&amp; &amp; \beta_{m-1} &amp; \alpha_{m-1} &amp; \beta_{m} \\&amp; &amp; &amp; \beta_{m} &amp; \alpha_{m}\end{array}\right) \in \mathbb{R}^{m \times m}\]</span> 记 <span class="math inline">\(T_m\)</span> 的 LU 分解为 <spanclass="math display">\[T_{m}=L_{m} U_{m}=\left(\begin{array}{ccccc}1 &amp; &amp; &amp; &amp; \\\lambda_{2} &amp; 1 &amp; &amp; &amp; \\&amp; \ddots &amp; \ddots &amp; &amp; \\&amp; &amp; \lambda_{m-1} &amp; 1 &amp; \\&amp; &amp; &amp; \lambda_{m} &amp; 1\end{array}\right)\left(\begin{array}{ccccc}\eta_{1} &amp; \omega_{2} &amp; &amp; &amp; \\&amp; \eta_{2} &amp; \omega_{3} &amp; &amp; \\&amp; &amp; \ddots &amp; \ddots &amp; \\&amp; &amp; &amp; \eta_{m-1} &amp; \omega_{m} \\&amp; &amp; &amp; &amp; \eta_{m}\end{array}\right)\]</span> 其中 <spanclass="math inline">\(\omega_{m}=\beta_{m}\)</span>, <spanclass="math inline">\(\quad\lambda_{m}=\frac{\beta_{m}}{\eta_{m-1}}\)</span>, <spanclass="math inline">\(\quad \eta_{m}=\alpha_{m}-\lambda_{m}\omega_{m}\)</span>。那么根据下面这一性质，Lanczos过程可以迭代进行 <spanclass="math display">\[\begin{align}L_{m}=\left(\begin{array}{c|c}L_{m-1} &amp; \mathbf{0} \\\hline \boldsymbol{l}_{m-1}^{T} &amp; 1\end{array}\right), \quad&amp;U_{m}=\left(\begin{array}{c|c}U_{m-1} &amp; \boldsymbol{y}_{m-1} \\\hline \mathbf{0}^{T} &amp; \eta_{m}\end{array}\right) \\L_{m}^{-1} = \left(\begin{array}{c|c}L_{m-1}^{-1} &amp; \mathbf{0} \\\hline -\boldsymbol{l}_{m-1}^{T}L_{m-1}^{-1} &amp; 1\end{array}\right), \quad&amp; U_{m}^{-1}=\left(\begin{array}{c|c}U_{m-1}^{-1} &amp; -\frac{1}{\eta_m} U_{m-1}^{-1} \boldsymbol{y}_{m-1}\\\hline \mathbf{0}^{T} &amp; 1/\eta_{m}\end{array}\right)\end{align}\]</span>根据这个方法，还可以到处<strong>CG（共轭梯度）法</strong>的形式。</p><h3 id="广义极小残量法gmres">3.3 广义极小残量法（GMRES）</h3><p>Generalized minimal residual method (GMRES)实际上就是最小化参量的二范数，即 <span class="math inline">\(\min \Vertr_m \Vert_2 = \min_{x\in x_0+{\mathcal K}_m} \Vert A(x^{\ast} -x)\Vert_2\)</span>，根据 Galerkin 条件，应有 <spanclass="math inline">\(r_m\perp A{\mathcal K}_m \iff V_m^{\rm T}A^{\rmT}AV_my = V_m^{\rm T}A^{\rm T}r_0, ~ y\in{\mathbb R}^m\)</span>。</p><p>另个一思路是 <span class="math inline">\(\min\Vert r_0-AV_my\Vert =\min \Vert V_{m+1} (\Vert r_0\Vert e_1 - \bar{H}_my)\Vert = \min \Vert\Vert r_0\Vert e_1 - \bar{H}_my\Vert\)</span>，最小二乘解 <spanclass="math inline">\(\bar{H}_m^{\rm T}(\bar{H}_my - \Vert r_0\Verte_1)=0\)</span>。</p><h3 id="minres-方法">3.4 MINRES 方法</h3><p>是 GMRES 的特殊情况，当 <span class="math inline">\(A=A^{\rmT}\)</span> 的时候，<span class="math inline">\(H_m\)</span> 为三对角阵<span class="math inline">\(T_m\)</span>，<spanclass="math inline">\(\min \Vert r_m\Vert_2 = \min \Vert \Vert r_0\Verte_1 - T_m y \Vert\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;现在需要求解一个大规模稀疏方程组 &lt;span
class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;，可以用迭代法比如 Jacobi
迭代法、Gauss-Seidel 迭代法等，不过这一节要讨论的是 Krylov
子空间方法，核心部分是 Arnoldi 迭代。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="线性方程组" scheme="https://glooow1024.github.io/tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    
    <category term="Arnoldi过程" scheme="https://glooow1024.github.io/tags/Arnoldi%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】连续参数马尔可夫链</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch7-s1-continuous-markov/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch7-s1-continuous-markov/</id>
    <published>2022-01-24T09:28:25.000Z</published>
    <updated>2022-01-24T09:37:07.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义与基本概念">7.1 定义与基本概念</h2><p><strong>定义</strong>：设随机过程 <spanclass="math inline">\(X=\{X(t),t\ge0\}\)</span>，状态空间 <spanclass="math inline">\(S\)</span>，对任意 <spanclass="math inline">\(0\le t_0 &lt; t_1 &lt; \cdots &lt; t_n &lt;t_{n+1}\)</span>，<span class="math inline">\(i_k\in S\)</span>，若<span class="math inline">\(P(X(T_k)=i_k,0\le k\le n) &gt; 0\)</span> 有<span class="math display">\[P(X(t_{n+1})=i_{n+1} | X(t_k)=i_k,0\le k\le n) = P(X(t_{n+1})=i_{n+1} |X(t_n)=i_n)\]</span> 则称 <span class="math inline">\(X\)</span>为<strong>连续参数的马氏链</strong>。若对任意的 <spanclass="math inline">\(s,t\ge0\)</span>，<spanclass="math inline">\(i,j\in S\)</span> 有 <span class="math display">\[P(X(s+t)=j | X(s)=i) = P(X(t)=j|X(0)=i) = P_{ij}(t)\]</span> 称 <span class="math inline">\(X\)</span>为<strong>齐次马氏链</strong>。</p><p>对于连续参数马氏链，在原点处有 <spanclass="math inline">\(P_{ij}(0)=\delta_{ij}\)</span>，因此 <spanclass="math inline">\(P(0)=I\)</span>。除此之外假设其在原点处连续，即<span class="math inline">\(\lim_{t\to 0}P_{ij}(t)=\delta_{ij},\lim_{t\to0}P(t)=I\)</span>。类比离散参数的马氏链，可以得到类似的C-K 方程 <span class="math inline">\(P(s+t)=P(s)P(t)\)</span>。</p><h2 id="转移概率矩阵">7.2 转移概率矩阵</h2><p>根据 C-K 方程可以猜测 <spanclass="math inline">\(P(t)=e^{tQ}\)</span>，泰勒展开表示为 <spanclass="math inline">\(P(t)=I + \sum_{n=1}^{\infty}\frac{t^n}{n!}Q^n\)</span>，<span class="math inline">\(P(t)\)</span>完全由 <span class="math inline">\(Q\)</span> 确定，并且有 <spanclass="math inline">\(P&#39;(0)=\lim_{t\to0}\frac{P(t)-I}{t}=Q\)</span>。</p><p>上面只是猜测，那么是否真的存在这样一个 <spanclass="math inline">\(Q\)</span> 呢？下面两个定理给出结论。</p><p><strong>定理 7.1</strong>：对 <span class="math inline">\(i\inS\)</span>，极限 <spanclass="math inline">\(-q_{ii}=\lim_{t\to0}\frac{1-P_{ii}(t)}{t}\)</span>存在，但可能是无穷。</p><p><strong>定理 7.2</strong>：对 <span class="math inline">\(i\inS\)</span>，极限 <spanclass="math inline">\(q_{ij}=\lim_{t\to0}\frac{P_{ij}(t)}{t}\)</span>存在且有限。</p><p>证明：略。</p><p><strong>Remark</strong>：实际应用中，<spanclass="math inline">\(P(t)\)</span> 很难获得，一般可以求得 <spanclass="math inline">\(Q\)</span>，此时 <spanclass="math inline">\(e^{tQ} = \lim_{n\to\infty}(I +Qt/n)^n\)</span>。如果取 <span class="math inline">\(n=2^k\)</span>的形式，只需要 <span class="math inline">\(k\)</span>次矩阵乘法即可。</p><p><strong>推论 7.1</strong>：对任意 <span class="math inline">\(i\inS\)</span>，<span class="math inline">\(0\le \sum_{i\ne j}q_{ij}\leq_{ii}\)</span>。</p><p>证明： <span class="math display">\[q_{ii}=\varliminf_{t\to0} \frac{1-P_{ii}(t)}{t} = \varliminf_{t\to0}\sum_{j\ne i}\frac{P_{ij}(t)}{t} \ge \sum_{j\nei}\varliminf_{t\to0}\frac{P_{ij}(t)}{t} = \sum_{j\ne i}q_{ij}\]</span> <strong>推论 7.2</strong>：当 <spanclass="math inline">\(S\)</span> 为有限状态空间时，<spanclass="math inline">\(\sum_{i\ne j}q_{ij}= q_{ii} &lt;\infty\)</span>。</p><h2 id="kolmogorov前向后向微分方程">7.3 Kolmogorov前向后向微分方程</h2><p><strong>定义</strong>：如果 <span class="math inline">\(Q\)</span>满足 <span class="math inline">\(\forall i\in S\)</span>，<spanclass="math inline">\(\sum_{j\ne i}q_{ij} = q_{ii} &lt;\infty\)</span>，则称 <span class="math inline">\(Q\)</span>为保守矩阵。</p><p><strong>定理 7.3</strong>：设马氏链 <spanclass="math inline">\(X=\{X(t),t\ge0\}\)</span>，<spanclass="math inline">\(Q=P&#39;(0)\)</span>，当 <spanclass="math inline">\(S\)</span> 为<strong>有限集</strong>时，<spanclass="math inline">\(P&#39;(t)=P(t)Q=QP(t)\)</span>。</p><p><strong>Remark</strong>：当 <span class="math inline">\(S\)</span>为可数状态时，前向方程与后向方程不一定成立，根据 Fatu 引理有 <spanclass="math inline">\(P&#39;(t)\ge P(t)Q,P&#39;(t)\ge QP(t)\)</span></p><p><strong>定理 7.4</strong>：当 <span class="math inline">\(S\)</span>为<strong>可列个状态</strong>，<span class="math inline">\(Q\)</span>为保守矩阵时，后向方程 <spanclass="math inline">\(P&#39;(t)=QP(t)\)</span> 成立。</p><h2 id="平稳分布与极限分布及其矩阵计算">7.4平稳分布与极限分布及其矩阵计算</h2><p>类似离散马氏链，可以定义状态的连通关系。</p><p><strong>定义</strong>：若 <span class="math inline">\(\int_0^\inftyP_{ii}(t)dt = +\infty\)</span>，则称状态 <spanclass="math inline">\(i\)</span>为<strong>常返态</strong>，否则称为非常返态。</p><p><strong>定义</strong>：设 <span class="math inline">\(i\)</span>为常返态，若 <span class="math inline">\(\lim_{t\to\infty}P_{ii}(t) &gt;0\)</span>，则称为正常返态，若 <spanclass="math inline">\(\lim_{t\to\infty}P_{ii}(t) =0\)</span>，称为零常返态。</p><p><strong>定义</strong>：若概率分布 <spanclass="math inline">\(\pi=\{\pi_i,i\in S\}\)</span> 满足 <spanclass="math inline">\(\pi=\pi P(t)\)</span>，称 <spanclass="math inline">\(\pi\)</span> 为 <spanclass="math inline">\(X\)</span> 的平稳分布。</p><p><strong>定理 7.5</strong>：设 <span class="math inline">\(X\)</span>是有限不可约连续马氏链，对任意 <span class="math inline">\(i,j\inS\)</span>，有 <spanclass="math inline">\(\lim_{t\to\infty}P_{ij}(t)=p_j\)</span>存在，且与状态 <span class="math inline">\(i\)</span> 无关。</p><p>证明：略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义与基本概念&quot;&gt;7.1 定义与基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：设随机过程 &lt;span
class=&quot;math inline&quot;&gt;\(X=\{X(t),t\ge0\}\)&lt;/span&gt;，状态空间 &lt;span
class=&quot;ma</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="平稳分布" scheme="https://glooow1024.github.io/tags/%E5%B9%B3%E7%A8%B3%E5%88%86%E5%B8%83/"/>
    
    <category term="极限分布" scheme="https://glooow1024.github.io/tags/%E6%9E%81%E9%99%90%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】马尔可夫过程2 | 状态空间</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s2-states/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s2-states/</id>
    <published>2022-01-24T09:28:24.000Z</published>
    <updated>2022-01-24T09:36:34.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态空间的分解">6.4 状态空间的分解</h2><p><strong>定义</strong>：设 <span class="math inline">\(A\subsetS\)</span>，若对任意 <span class="math inline">\(i\in A\)</span> 及<span class="math inline">\(j\notin A\)</span>，都有 <spanclass="math inline">\(p_{ij}=0\)</span>，称 <spanclass="math inline">\(A\)</span> 为<strong>闭集</strong>。若 <spanclass="math inline">\(A\)</span> 的状态是相通的，则 <spanclass="math inline">\(A\)</span> 为<strong>不可约</strong>的。</p><p><strong>引理 6.1</strong>：<span class="math inline">\(A\)</span>为闭集的充要条件为：任意 <span class="math inline">\(i\in A\)</span> 及<span class="math inline">\(j\notin A\)</span> 都有 <spanclass="math inline">\(p_{ij}^{(n)}=0,n\ge1\)</span>。</p><p><strong>推论</strong>：若 <span class="math inline">\(A\)</span>是闭集，对任意状态 <span class="math inline">\(i\in A\)</span> 恒有<span class="math inline">\(\sum_{j\in A}p_{ij}^{(n)}=1\)</span>。</p><blockquote><p><strong>定理 6.5</strong>：所有常返态构成一个闭集。</p><p><strong>推论</strong>：不可约马尔科夫链，所有状态都是常返的，或者所有状态都是非常返的。</p></blockquote><p><strong>定理 6.6</strong>：状态空间 <spanclass="math inline">\(S\)</span> 可以分解为 <spanclass="math inline">\(S = T\cup C = T\cup C_1 \cdots \cup C_h\cdots\)</span>，其中 <span class="math inline">\(T\)</span>表示非常返状态的集合，<span class="math inline">\(C_i\)</span>为基本的常返闭集，且有</p><ol type="1"><li>对任一确定的 <span class="math inline">\(k,C_k\)</span>中任意两个状态互通；</li><li><span class="math inline">\(C_k\cap C_l = \varnothing,\forall h\nel\)</span>。</li></ol><blockquote><p><strong>定理 6.7</strong>：有限状态马尔科夫链具有如下性质：</p><ol type="1"><li>状态空间 <span class="math inline">\(S\)</span> 可分解为 <spanclass="math inline">\(S = T\cup C = T\cup C_1 \cdots \cupC_h\)</span>，其中 <span class="math inline">\(T\)</span>表示非常返状态的集合，<span class="math inline">\(C_i\)</span>为基本的常返闭集；</li><li>非常返状态集合 <span class="math inline">\(T\)</span>一定不是闭集；</li><li>没有零常返状态；</li><li>必有正常返状态；</li><li>不可约马氏链的的状态都是正常返态；</li><li>任意闭集 <span class="math inline">\(C_i\)</span> 上的 <spanclass="math inline">\(n\)</span> 步转移矩阵为随机矩阵。</li></ol></blockquote><h2 id="极限特性与平稳分布">6.5 极限特性与平稳分布</h2><h3 id="极限特性">6.5.1 极限特性</h3><p><strong>定理 6.7</strong>：若状态 <spanclass="math inline">\(j\)</span> 为非常返态或零常返态，则对任意 <spanclass="math inline">\(i \in S\)</span>，有 <spanclass="math inline">\(\lim_{n\to\infty}p_{ij}^{(n)}=0\)</span>。</p><p><strong>推论6.7.1</strong>：若马尔科夫链有一个零常返态，则必有无穷多个零常返态。</p><h3 id="平稳分布">6.5.2 平稳分布</h3><p><strong>定义</strong>：一个定义在 <spanclass="math inline">\(S\)</span> 上的概率分布 <spanclass="math inline">\(\pi=(\pi_1,\pi_2,...,\pi_i,...)\)</span>称为马尔科夫链的平稳分布，如果有 <span class="math inline">\(\pi=\piP\)</span>。</p><p><strong>定理 6.9</strong>：若马尔科夫链是不可约的遍历链，则 <spanclass="math inline">\(\{\pi_i = 1 / \mu_i\}\)</span> 是 <spanclass="math inline">\(\pi=\pi P(\pi_i\ge0,\sum_{i\in S}\pi_i=1)\)</span>的<strong>唯一解</strong>。</p><p><strong>推论 6.9.1</strong>：不可约遍历链恒有唯一的平稳分布，且 <spanclass="math inline">\(\pi_j=\lim_{n\to\infty}p_{ij}^{(n)}\)</span>。</p><p><strong>定理 6.10</strong>：令 <spanclass="math inline">\(C_+\)</span>为马尔科夫链中全体正常返状态构成的集合，则有</p><ol type="1"><li>平稳分布不存在的充要条件为 <spanclass="math inline">\(C_+=\varnothing\)</span>；</li><li>平稳分布唯一存在的充要条件为只有一个基本正常返闭集；</li><li>若马尔科夫链有多于一个基本正常返闭集，则其平稳分布有无穷多个。</li></ol><p><strong>定理 6.11</strong>：关于有限状态的马尔科夫链</p><ol type="1"><li>有限状态马尔科夫链的平稳分布总存在；</li><li>有限不可约非周期的马尔科夫链存在唯一的平稳分布；</li><li>若有多于一个基本正常返闭集，则其平稳分布有无穷多个；</li></ol><p><em>栗子</em>（平衡方程及其应用）：对非周期正常返的离散马氏链，平稳分布存在且满足<span class="math inline">\(\pi P=\pi\)</span>，可以写成 <spanclass="math inline">\(\pi_j(1-P_{jj}) = \sum_{i\ne j,i\in S} \pi_iP_{ij}\)</span>，这被称为离散马氏链的平衡方程。左边表示从状态 <spanclass="math inline">\(j\)</span> 流出的量，右边表示从其他状态流入状态<span class="math inline">\(j\)</span>的量，在讨论一些实际工程问题时，可以借助平衡方程求解系统平稳分布。</p><h2 id="转移矩阵的平均极限">6.6 转移矩阵的平均极限</h2><p>一般情况下，<span class="math inline">\(n\to\infty\)</span> 时 <spanclass="math inline">\(P^n\)</span> 的极限未必存在，主要是因为 <spanclass="math inline">\(P^n\)</span>可能有周期性。为了消除周期性，最直接的方法就是取平均。</p><p><strong>定理 6.12</strong>：设 <span class="math inline">\(P\)</span>为有限马氏链的转移矩阵，则 <spanclass="math inline">\(L:=\lim_{n\to\infty}\frac{1}{n}(I+P+\cdots+P^{n-1})\)</span> 存在，且满足 <spanclass="math inline">\(LP = PL = L = L^2\)</span>。</p><p><strong>推论</strong>：设有限不可约马氏链的转移矩阵为 <spanclass="math inline">\(P\)</span>，平稳分布为 <spanclass="math inline">\(\pi\)</span>，<spanclass="math inline">\(L=(l_{ij})=\lim_{n\to\infty}\frac{1}{n}(I+P+\cdots+P^{n-1})\)</span>，则 <spanclass="math inline">\(\pi L=\pi\)</span>，且 <spanclass="math inline">\(\pi_j=l_{ij} / \sum_{k=1}^N l_{ik}\)</span>。</p><p><strong>定理 6.13</strong>：设 <span class="math inline">\(P\)</span>是有 <span class="math inline">\(m\)</span>个状态的不可约马氏链的转移矩阵，则平稳分布概率为</p><p><span class="math inline">\(\pi = (1,...,1)(I-P+{\mathbb1})^{-1}\)</span>，其中 <span class="math inline">\({\mathbb 1}\)</span>为全 1 的 <span class="math inline">\(m\times m\)</span> 矩阵。</p><p>证明：关键是要证明矩阵 <span class="math inline">\((I-P+{\mathbb1})\)</span> 可逆。</p><blockquote><p><strong>Note</strong>：马尔科夫链在随机过程里面是比较简单的部分，大部分结论都很直观，凭直观感觉就能得到。</p><p>实际上这章马尔科夫链的主要内容就是在讨论几种状态：非常返态、正常返态、零常返态。归结起来，现在想象一个马尔可夫链的状态转移图，有很多节点（状态）和有向边（转移概率）。</p><p>首先对于几种状态的区别：</p><ol type="1"><li>正常返态就是说从一个状态开始，经过有限步总能再次回到当前状态，并且这个平均回转时间是有限的（中华好男人，常回家看看）；</li><li>零常返态就是说从一个状态开始，经过有限步总能再次回到当前状态，但这个平均回转时间是无穷的（渣男海王，开空头支票）；</li><li>非常返态就是说从一个状态开始，经过有限步之后就再也不能返回当前状态了（恩断义绝）；</li></ol><p>如何判断每个节点的状态类型，基本只需要下面两条原则：</p><ol type="1"><li>如果两个状态相通，那么他们同为常返态或非常返态。<ol type="1"><li>那么如果两个节点之间有双向边，他们一定是同一类型态；要出现常返态和非常返态的区别一定是由于单向边的存在；</li><li>进一步的，一个连通子图里面的所有状态一定是同一类型；要出现常返态和非常返态的区别，一定是两个连通子图<span class="math inline">\(A,B\)</span> 之间只有单向边；</li><li>假如只有 <span class="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的单向边，那么连通子图 <spanclass="math inline">\(B\)</span> 中的节点一定都是非常返态。</li></ol></li><li>零常返态只可能出现在状态个数为无穷的时候。</li></ol><p>极限分布/平稳分布是怎样：</p><ol type="1"><li>极限分布与初始分布有关，平稳分布只与状态转移链本身的性质有关；</li><li>由于最终一定会收敛到常返态，平稳分布一定是只对常返态非零；</li><li>只考虑常返态的集合，平稳分布就是转移概率矩阵 <spanclass="math inline">\(P\)</span> 的左特征向量；</li></ol><p>下面讲个故事。</p><p>把概率想象成手里的money，初始分布概率就是每个节点手里的本钱；一个（不可约的）连通子图就是一个家族，家族里的每个人之间可以相互借钱来回周转；不同连通子图就是不同的家族。</p><p>（不可约的）连通子图内部，一个家族里面的钱再怎么周转也都是内部消化，每个人借出去的总能还回来，所以钱不会消失，总会有一个平衡。</p><p>如果有两个连通子图，并且它们之间只有单向边，相当于 <spanclass="math inline">\(A\)</span> 总是把一部分 money 白送给 <spanclass="math inline">\(B\)</span>，再厚的家底也得被掏空了。最后 <spanclass="math inline">\(A\)</span>家族就破产了（非常返态，不是闭集）。</p><p>如果 <span class="math inline">\(B\)</span>家族的钱只进不出，也就是没有向外的有向边（闭集），那么他们就会完成资本的积累，最终钱总会聚集到他们那里（常返态）。</p><p>如果有两个连通子图，他们相互之间没有任何边相联系，那就是他们互不打扰，两不相欠（各自有一个平稳分布）。100年之后各自有多少钱取决于现在各自有多少钱，不多不少（联合组成无穷个平稳分布，因为初始分布有无穷种情况）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;状态空间的分解&quot;&gt;6.4 状态空间的分解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：设 &lt;span class=&quot;math inline&quot;&gt;\(A\subset
S\)&lt;/span&gt;，若对任意 &lt;span class=&quot;math inline&quot;&gt;</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="平稳分布" scheme="https://glooow1024.github.io/tags/%E5%B9%B3%E7%A8%B3%E5%88%86%E5%B8%83/"/>
    
    <category term="极限分布" scheme="https://glooow1024.github.io/tags/%E6%9E%81%E9%99%90%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】马尔可夫过程1 | 基本概念</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s1-concepts/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s1-concepts/</id>
    <published>2022-01-24T09:28:23.000Z</published>
    <updated>2022-01-24T09:34:31.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">6.1 基本概念</h2><p>马尔科夫链的定义很常见了，在此不再赘述。简单而言就是 <spanclass="math display">\[P(X_{n+1}=s_{n+1}|X_0=s_0,...,X_{n}=s_n) = P(X_{n+1}=s_{n+1}|X_{n}=s_n)\]</span>还可以定义一步转移概率、转移概率矩。如果转移概率不随时间变化，就是时间齐次马尔科夫链。</p><p><strong>定理 6.1</strong>：设随机过程 <spanclass="math inline">\(\{X_n,n\ge0\}\)</span> 满足</p><ol type="1"><li><span class="math inline">\(X_n =f(X_{n-1},\xi_n)(n\ge1)\)</span>，其中 <spanclass="math inline">\(f:S\times S\to S\)</span>；</li><li><span class="math inline">\(\{\xi_n,n\ge1 \}\)</span>为独立同分布随机序列，且 <span class="math inline">\(X_0\)</span> 与<span class="math inline">\(\{\xi_n,n\ge1\}\)</span> 也相互独立；</li></ol><p>则 <span class="math inline">\(\{X_n,n\ge0\}\)</span>是马尔科夫链，并且一步转移概率为 <spanclass="math inline">\(p_{ij}=P(f(i,\xi_n)=j)\)</span>.</p><p>证明：根据条件 1 可知 <span class="math inline">\(\xi_{n+1}\)</span>与 <span class="math inline">\(X_0,...,X_n\)</span> 独立，从而有 <spanclass="math display">\[\begin{aligned}&amp;P(X_{n+1}=s_{n+1} | X_0=s_0,...,X_n=s_n) \\=&amp; P(f(X_n,\xi_{n+1})=s_{n+1} | X_0=s_0,...,X_n=s_n) \\=&amp; P(f(s_n,\xi_{n+1})=s_{n+1}) = P(X_{n+1}=s_{n+1} | X_n = s_n)\end{aligned}\]</span> 证毕。</p><blockquote><p><strong>Note</strong>：这个定理实际上是在说 <spanclass="math inline">\(X_n\)</span> 只由 <spanclass="math inline">\(X_{n-1}\)</span> 和一个与之完全独立的随机变量<span class="math inline">\(\xi_n\)</span>决定，这与马尔可夫性质异曲同工。并且如果 <spanclass="math inline">\(\xi_n,n\ge1\)</span>同分布，那么这个马尔可夫过程是时间齐次的，否则是非齐次的。</p><p>如果把随机变量看作是信息的话，<spanclass="math inline">\(\xi_n\)</span> 就可以看成是从 <spanclass="math inline">\(X_{n-1}\)</span> 到 <spanclass="math inline">\(X_n\)</span> 变化的信息量。</p></blockquote><p><em>栗子 1</em>：设 <spanclass="math inline">\(\{\xi_n,n\ge0\}\)</span>独立同分布，取值为非负整数，<spanclass="math inline">\(P(\xi_n=i)=a_i\)</span>。令 <spanclass="math inline">\(X_0=0,X_n=\sum_{k=1}^n \xi_k\)</span>，则易证<span class="math inline">\(\{X_n,n\ge0\}\)</span>是一个马尔科夫链，因为有 <span class="math inline">\(f(X_n,\xi_{n+1}) =X_n+\xi_{n+1}\)</span>。还可以得到转移概率为 <spanclass="math inline">\(p_{ij} = \begin{cases}a_{j-i}, &amp; i\ge i \\ 0,&amp; i &lt; i \end{cases}.\)</span></p><p><em>栗子2</em>（带吸收壁的随机游动）：对称随机游动，每次只能向左或向右移动一个单位，或者原地不动，随机移动限制在<span class="math inline">\(S=\{0,1,...,b\}\)</span> 内。用 <spanclass="math inline">\(\xi_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 次移动的距离，<spanclass="math inline">\(X_n\)</span> 为 <spanclass="math inline">\(n\)</span> 次移动后的位置，则 <spanclass="math inline">\(X_{n+1} = f(X_n,\xi_{n+1}) = X_n +(1-\delta(X_n-b)-\delta(X_n))\xi_{n+1}\)</span>。</p><p><em>栗子3</em>（G/M/1排队模型）：G表示顾客到达服务台的时间间隔，一般假设为独立同分布，分布函数为<spanclass="math inline">\(G(x)\)</span>；M表示服务时间，假设为独立同指数分布，且与顾客到达过程独立；1表示单个服务员。</p><p>记 <span class="math inline">\(X_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个顾客到达服务台时系统内的顾客数，<spanclass="math inline">\(T_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个顾客到达时刻。易证 <spanclass="math inline">\(X_n\)</span> 为一个马尔科夫链。</p><p>各顾客服务时间独立，且服从参数为 <spanclass="math inline">\(\mu\)</span> 的指数分布，<spanclass="math inline">\((0,t)\)</span> 时间内服务完的顾客服从参数为 <spanclass="math inline">\(\mu\)</span> 的泊松分布，因此 <spanclass="math display">\[P(X_{n+1}=i+1-j | X_n=i) = \int_0^\infty e^{-\mu t}\frac{(\mu t)^j}{j!}dG(t)\]</span></p><h2 id="转移概率矩阵">6.2 转移概率矩阵</h2><p><strong>定义</strong>：若 <span class="math inline">\(a_{ij}\ge0, ~i,j\in S\)</span> 且满足 <span class="math inline">\(\sum_{j\in S}a_{ij} = 1\)</span>，则称矩阵 <spanclass="math inline">\(A=(a_{ij})\)</span> 为随机矩阵。</p><p>记 <span class="math inline">\(\pi_i(n)=P(X_n=i)\)</span>，向量 <spanclass="math inline">\(\pi(n)=(\pi_1(n),\pi_2(n),...)\)</span> 表示 <spanclass="math inline">\(n\)</span>时刻的概率分布向量。一个马尔科夫链的性质完全由初始分布向量和一步转移概率矩阵决定。</p><p><strong>定理 6.2（C-K方程）</strong>：<spanclass="math inline">\(P^{(m+n)} = P^{(m)} P^{(n)}\)</span>.</p><p><strong>Remark</strong>：上面的C-K方程可以联想到卷积形式，即 <spanclass="math inline">\(P_{ij}^{(n)}=\sum_{k}P_{ik}^{(l)}P_{kj}^{(n-l)}\)</span>，于是又可以联想到用傅里叶变换/ z变换进行处理，以避免卷积。</p><h2 id="markov链状态的分类">6.3 Markov链状态的分类</h2><h3 id="状态分类">6.3.1 状态分类</h3><p><strong>定义</strong>：对于 <span class="math inline">\(i,j\inS\)</span>，若存在自然数 <span class="math inline">\(n\)</span> 使得<span class="math inline">\(p_{ij}^{(n)} &gt; 0\)</span>，则称自状态<span class="math inline">\(i\)</span> 出发可达状态 <spanclass="math inline">\(j\)</span>，记为 <span class="math inline">\(i\toj\)</span>。若 <span class="math inline">\(i\to j\)</span> 且 <spanclass="math inline">\(j\to i\)</span>，则称 <spanclass="math inline">\(i,j\)</span> <strong>相通</strong>，记为 <spanclass="math inline">\(i\leftrightarrow j\)</span>。如果 Markov链的任意两个状态都相通，则称为<strong>不可约链</strong>。</p><p><strong>定义</strong>：<strong>首达时间</strong> <spanclass="math display">\[\tau_{ij}=\min \{n:n\ge1,X_n=j,X_0=i \}\]</span> 若右边为空集，则令 <spanclass="math inline">\(\tau_{ij}=\infty\)</span>。</p><p><strong>定义</strong>：<strong>首达概率</strong> <spanclass="math display">\[f_{ij}^{(n)}=P(\tau_{ij}=n | X_0=i)=P(X_n=j,X_k\ne j,1\le k\le n-1 |X_0=i)\]</span> <span class="math inline">\(f_{ij}=\sum_{n=1}^\inftyf_{ij}^{(n)}\)</span> 表示从 <span class="math inline">\(i\)</span>出发，经有限步首次到达 <span class="math inline">\(j\)</span>的概率。</p><p><strong>定义</strong>：若 <spanclass="math inline">\(f_{ii}=1\)</span>，则称 <spanclass="math inline">\(i\)</span> 为<strong>常返态</strong>；若 <spanclass="math inline">\(f_{ii} &lt; 1\)</span>，称状态 <spanclass="math inline">\(i\)</span> 为非常返态。</p><p><strong>定义</strong>：若 <spanclass="math inline">\(f_{ii}=1\)</span>，此时定义 <spanclass="math inline">\(\mu_i=\sum_{n=1}^\infty nf_{ii}^{(n)}\)</span>，则<span class="math inline">\(\mu_i\)</span> 表示从状态 <spanclass="math inline">\(i\)</span> 出发再回到状态 <spanclass="math inline">\(i\)</span> 的<strong>平均回转时间</strong>。若<span class="math inline">\(\mu_i &lt; \infty\)</span> 称 <spanclass="math inline">\(i\)</span> 为<strong>正常返态</strong>；若 <spanclass="math inline">\(\mu_i=\infty\)</span>称为<strong>零常返态</strong>。</p><p><strong>定义</strong>：若集合 <spanclass="math inline">\(\{n:n\ge1,p_{ii}^{(n)} &gt;0\}\ne\varnothing\)</span>，称该数集的最大公约数 <spanclass="math inline">\(d(i)\)</span> 为状态 <spanclass="math inline">\(i\)</span> 的周期。若 <spanclass="math inline">\(d(i) &gt; 1\)</span> 称状态 <spanclass="math inline">\(i\)</span> 为<strong>周期</strong>的；若 <spanclass="math inline">\(d(i)=1\)</span>称为<strong>非周期</strong>的。</p><p><strong>定义</strong>：若状态 <span class="math inline">\(i\)</span>为正常返态且为非周期的，则称状态 <span class="math inline">\(i\)</span>为<strong>遍历状态</strong>（ergodic state）。</p><h3 id="一些基本关系式">6.3.2 一些基本关系式</h3><p><strong>定理 6.3</strong>：对 <span class="math inline">\(\foralli,j\in S,n\ge1\)</span> 有</p><ol type="1"><li><span class="math inline">\(p_{ij}^{(n)} = \sum_{l=1}^nf_{ij}^{(l)}p_{jj}^{(n-l)}\)</span></li><li><span class="math inline">\(f_{ij}^{(n)} = \sum_{k\nej}p_{ik}f_{kj}^{(n-1)}I_{\{n &gt; 1\}} + p_{ij}I_{\{n=1\}}\)</span>.</li></ol><p>下面给出一些关于该定理的讨论。</p><p><strong>Discussion（常返性判定准则）</strong>：对于特殊情况 <spanclass="math inline">\(i=j\)</span> 时，上面的第 1 条变成 <spanclass="math inline">\(p_{ii}^{(n)} = \sum_{l=1}^nf_{ii}^{(l)}p_{ii}^{(n-l)}\)</span>，这是卷积的形式，取 z 变换 <spanclass="math inline">\(P_i(z)=\sum_{n=1}^{\infty}p_{ii}^{(n)}z^{-n}\)</span>，<spanclass="math inline">\(F_i(z)=\sum_{n=1}^{\infty}f_{ii}^{(n)}z^{-n}\)</span>，那么根据上式有<span class="math inline">\(P_i(z)=1+F_i(z)P_i(z)\)</span>，从而 <spanclass="math inline">\(P_i(z)=\frac{1}{1-F_i(z)}\)</span>。当 <spanclass="math inline">\(z\to1\)</span>时，有 <spanclass="math inline">\(P_i(z)\to\sum_{n=1}^{\infty}p_{ii}^{(n)}\)</span>，<spanclass="math inline">\(F_i(z)\to \sum_{n=1}^{\infty}f_{ii}^{(n)} =f_{ii}\)</span>。</p><p><strong>推论 6.3.1</strong>：状态 <spanclass="math inline">\(i\)</span> 为常返的充要条件为 <spanclass="math inline">\(\sum_{n=1}^{\infty}p_{ii}^{(n)}=+\infty\)</span>；状态<span class="math inline">\(i\)</span> 非常返的充要条件为 <spanclass="math inline">\(\sum_{n=1}^{\infty}p_{ii}^{(n)} &lt;\infty\)</span>。</p><p>如果记 <span class="math inline">\(I_n(i)=\begin{cases}0,&amp;X_n\nei \\ 1,&amp; X_n=i \end{cases}\)</span>，<spanclass="math inline">\(S(i)=\sum_{n=1}^\infty I_n(i)\)</span> 为到达状态<span class="math inline">\(i\)</span> 的次数，那么 <spanclass="math inline">\({\mathbb E}[S(i) |X_0=i]=\sum_{n=1}^{\infty}p_{ii}^{(n)}\)</span> 即表示从状态 <spanclass="math inline">\(i\)</span> 出发返回 <spanclass="math inline">\(i\)</span> 的平均次数。当 <spanclass="math inline">\(i\)</span> 为常返态，直观上即平均返回 <spanclass="math inline">\(i\)</span>的次数为无穷，与上面的推论是一致的。对于非常返态，平均返回次数有限。</p><p><strong>Discussion（<spanclass="math inline">\(p_{ii}^{(n)}\)</span>与正常返、零常返的关系）</strong>：</p><p>（1）当状态是非周期的，定义 <spanclass="math inline">\(v_n=p_{ii}^{(n)} - p_{ii}^{(n-1)},n &gt;1\)</span>，<spanclass="math inline">\(v_0=p_{ii}^{(0)}\)</span>，于是有 <spanclass="math inline">\(V(z)=\sum_{n=0}^{\infty} v_nz^{-n} =\frac{1-z^{-1} }{1-F_i(z)}\)</span>，利用洛必达法则有 <spanclass="math inline">\(\lim_{z\to 1}V(z) = -1/F_i&#39;(1) =1/\mu_i\)</span>。另一方面 <spanclass="math inline">\(\lim_{z\to1}V(z)=\lim_{n\to\infty}\sum_{k=0}^\inftyv_k=\lim_{n\to\infty} p_{ii}^{(n)}\)</span>，因此有 <spanclass="math display">\[\lim_{n\to\infty} p_{ii}^{(n)}=1/\mu_i\]</span></p><blockquote><p>根据正常返和零常返的定义知道：</p><p>当 <span class="math inline">\(i\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i\ne0\)</span>；</p><p>当 <span class="math inline">\(i\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i=0\)</span>。</p></blockquote><p>（2）当状态是周期的，记状态 <span class="math inline">\(i\)</span>的周期为 <span class="math inline">\(T\)</span>，当 <spanclass="math inline">\(n\)</span> 不是 <spanclass="math inline">\(T\)</span> 的整数倍时有 <spanclass="math inline">\(f_{ii}^{(n)}=0\)</span>，<spanclass="math inline">\(F_i(z)=\sum_{k=0}^\inftyf_{ii}^{(kT)}z^{-kT}=\psi(z^T)\)</span>，相应的 <spanclass="math inline">\(P_i(z)=\frac{1}{1-\psi(z^T)}\)</span>。类似非周期情况的讨论可以得到<span class="math display">\[p_{ii}^{(nT)}\to T/\mu_i\]</span></p><blockquote><p>当 <span class="math inline">\(i\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(nT)}=T/\mu_i\ne0\)</span>，<spanclass="math inline">\(\lim_{n\to\infty} p_{ii}^{(nT+k)}=0,0 &lt; k &lt;T\)</span>；</p><p>当 <span class="math inline">\(i\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i=0\)</span>。</p></blockquote><p><strong>Discussion（<spanclass="math inline">\(p_{ij}^{(n)}\)</span>与正常返、零常返的关系）</strong>：由于<span class="math inline">\(p_{ij}^{(n)} = \sum_{l=1}^nf_{ij}^{(l)}p_{jj}^{(n-l)}\)</span>，定义相应的 z 变换可以得到 <spanclass="math inline">\(P_{ij}(z)=F_{ij}(z)P_j(z) =\frac{F_{ij}(z)}{1-F_j(z)}\)</span>。当 <spanclass="math inline">\(j\)</span> 为常返态时，利用洛必达法则有 <spanclass="math inline">\(\lim_{z\to1+}(1-z^{-1})P_{ij}(z) =\lim_{z\to1+}\frac{1}{F_j&#39;(z)}\lim_{z\to1+}F_{ij}(z) =f_{ij}/\mu_j\)</span>，而左端等于（利用Hardy-Littlewood引理） <spanclass="math inline">\(\lim_{z\to1+}(1-z^{-1})P_{ij}(z) =\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)}\)</span>，因此有 <span class="math display">\[\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\infty p_{ij}^{(k)} =\frac{f_{ij} }{\mu_j}\]</span></p><blockquote><p>当 <span class="math inline">\(j\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)} = {f_{ij} }/{\mu_j}\)</span> 为有限值；</p><p>当 <span class="math inline">\(j\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)}=0\)</span>。</p></blockquote><h3 id="状态间的等价关系">6.3.3 状态间的等价关系</h3><p>对马尔科夫链而言，状态互通是一种等价关系，对于状态进行归类有助于简化后续分析过程。</p><p><strong>定理 6.4</strong>：</p><ol type="1"><li>若状态 <span class="math inline">\(i\)</span> 常返，并且 <spanclass="math inline">\(i\to j\)</span>，则状态 <spanclass="math inline">\(j\)</span> 也是常返的，并且 <spanclass="math inline">\(f_{ji}=1\)</span>；</li><li>如果 <span class="math inline">\(i\leftrightarrow j\)</span>，则状态<span class="math inline">\(i,j\)</span>同为常返或非常返态；若为常返态，则他们同为正常返或零常返；</li><li>如果 <span class="math inline">\(i\leftrightarrow j\)</span>，则状态<span class="math inline">\(i,j\)</span> 有相同的周期。</li></ol><p>证明：（1）存在 <span class="math inline">\(N\)</span> 使得 <spanclass="math inline">\(p_{ij}^{(N)} &gt; 0\)</span>，从 <spanclass="math inline">\(i\)</span> 出发到 <spanclass="math inline">\(j\)</span> 不返回 <spanclass="math inline">\(i\)</span> 的概率为 <spanclass="math inline">\(p_{ij}^{(N)}(1-f_{ji})=0\)</span>，因此 <spanclass="math inline">\(f_{ji}=1\)</span>。由于 <spanclass="math inline">\(i\leftrightarrow j\)</span>，存在 <spanclass="math inline">\(N_1,N_2\)</span> 有 <spanclass="math inline">\(p_{ij}^{(N_1)} &gt; 0,p_{ji}^{(N_2)} &gt;0\)</span>，那么 <span class="math inline">\(p_{jj}^{(N_1+n+N_2)} \gep_{ij}^{(N_1)}p_{ii}^{(n)}p_{ji}^{(N_2)}=abp_{ii}^{(n)}\)</span>，因此有<span class="math inline">\(\sum_{n=0}^{\infty} p_{jj}^{(n)} =\infty\)</span>，因此状态 <span class="math inline">\(j\)</span>是常返的。</p><p>（2，3）略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;6.1 基本概念&lt;/h2&gt;
&lt;p&gt;马尔科夫链的定义很常见了，在此不再赘述。简单而言就是 &lt;span
class=&quot;math display&quot;&gt;\[
P(X_{n+1}=s_{n+1}|X_0=s_0,...,X_{n}=s_n) = P(X_{n</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="常返" scheme="https://glooow1024.github.io/tags/%E5%B8%B8%E8%BF%94/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】布朗运动2 | 推广</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch5-s2-brown-extension/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch5-s2-brown-extension/</id>
    <published>2022-01-24T09:28:21.000Z</published>
    <updated>2022-01-24T09:49:41.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大值与首中时的分布特性">5.4 最大值与首中时的分布特性</h2><p>设 <span class="math inline">\(\{B(t),t\ge0\}\)</span>是标准布朗运动，不妨设 <span class="math inline">\(B(0)=0\)</span>。</p><p><strong>定义</strong>：首次击中 <spanclass="math inline">\(a\)</span> 的时间 <spanclass="math inline">\(\tau_a=\inf\{t:t\ge0,B(t)=a\}\)</span></p><span id="more"></span><p><strong>定义</strong>：对 <span class="math inline">\(\forall t &gt;0, M(t)=\max_{0\le u\le t}B(u)\)</span> 表示 <spanclass="math inline">\([0,t]\)</span> 上的最大值。</p><p>当 <span class="math inline">\(a &gt; 0\)</span> 时，显然存在等价关系<span class="math inline">\(\{\tau_a \le t\} = \{M(t) \gea\}\)</span>，因此有 <span class="math inline">\(P(\tau_a \le t) =P(M(t) \ge a)\)</span>。</p><p><strong>Remark</strong>：事实上，这与泊松过程中定义的 <spanclass="math inline">\(\{S_n\le t\} = \{N(t)\ge n\}\)</span>类似。主要差别在于泊松过程中讨论离散点情况，这里讨论连续情况。</p><p><strong>定理 5.6</strong>：对任意 <spanclass="math inline">\(a&gt;0\)</span>，<spanclass="math inline">\(M(t)\)</span> 和 <spanclass="math inline">\(\tau_a\)</span> 的分布密度函数分别为 <spanclass="math display">\[\begin{aligned}f_{M(t)}(a) &amp;= \sqrt{\frac{2}{\pi t} } e^{-a^2/ 2t}I_{[0,\infty)}(a) \\f_{\tau_a}(t) &amp;= \frac{a}{\sqrt{2\pi} } e^{-a^2/2t} t^{-3/2}, \quadt &gt; 0\end{aligned}\]</span> <span class="math inline">\(\tau_a\)</span> 的 Laplace 变换为<span class="math inline">\({\mathbb E}[\exp(-s\tau_a)] =e^{-\sqrt{2s}a}, ~ s&gt;0\)</span>。</p><p>证明：<span class="math inline">\(P(B(t)\ge a) = P(B(t\ge a | \tau_a\le t))P(\tau_a \le t)\)</span>，由于 <spanclass="math inline">\(P(B(t)\ge a) | \tau_a\le t) = P(B(t)&lt; a) |\tau_a\le t)=1/2\)</span>，因此可以得到 <spanclass="math inline">\(P(M(t)\ge a) = P(\tau_a \le t) = 2P(B(t)\gea)=\frac{2}{\sqrt{2\pi t} }\int_a^{\infty} e^{-x^2 /2t}dx\)</span>。于是 <spanclass="math inline">\(f_{M(t)}(a)={d(1-P(M(t)\ge a))} /{da}\)</span>，<span class="math inline">\(f_{\tau_a}(t) = d(P(\tau_a\le t)) / da\)</span>，证毕。</p><p>利用上述定理可以到如下结果：</p><ol type="1"><li><span class="math inline">\(\tau_a\)</span> 几乎处处有限，即 <spanclass="math inline">\(P(\tau_a &lt; \infty)=1\)</span>；</li><li><span class="math inline">\({\mathbb E}\tau_a =\infty\)</span>。</li></ol><p>证明：1）<span class="math inline">\(P(\tau_a&lt;\infty) =\lim_{t\to\infty}=P(\tau_a \le t) = \lim_{t\to\infty}\frac{2}{\sqrt{2\pi} }\int_{a/\sqrt{t} }^{\infty} e^{-u^2/2}du =1\)</span>；2）<span class="math inline">\({\mathbbE}[\exp(-s\tau_a)]=e^{-\sqrt{2s}a}\)</span>，两边对 <spanclass="math inline">\(s\)</span> 求导得到 <spanclass="math inline">\({\mathbb E}[\tau_a \exp(-s\tau_a)] =\frac{\sqrt{2} }{2} a s^{-1/2} e^{-\sqrt{2s}a}\)</span>，令 <spanclass="math inline">\(s\to 0\)</span> 即可得到 <spanclass="math inline">\({\mathbb E}\tau_a = \infty\)</span>，证毕。</p><p><em>栗子 5.1</em>：</p><p><strong>定理 5.7</strong>：设 <spanclass="math inline">\(\{B(t)\}\)</span> 为标准布朗运动，<spanclass="math inline">\(\forall a &gt; 0, y\ge0\)</span> 有 <spanclass="math inline">\(P(B(t)\le a-y, M(t)\ge a) = P(B(t) \gea+y)\)</span></p><p>证明：根据反射性定义 <span class="math inline">\(B^{\ast}(t) =2a-B(t)\)</span>，则有 <span class="math inline">\(\tau_a =\tau^{\ast}_a = \inf\{B^{\ast}(t)=a\}\)</span>，又由于 <spanclass="math inline">\(\{M(t)\ge a\} = \{\tau_a \le t\}\)</span>，于是有<span class="math display">\[\begin{aligned}P(B(t)\le a-y, M(t)\ge a) &amp;= P(B(t)\le a-y, \tau_a\le t) \\&amp;= P(B^{\ast}(t) \le a-y, \tau_a \le t) \\&amp;= P(B(t) \ge a+y, \tau_a\le t) \\&amp;= P(B(t)\ge a+y)\end{aligned}\]</span> <strong>推论 5.7.1</strong>：设 <spanclass="math inline">\(\{B(t)\}\)</span> 为标准布朗运动，<spanclass="math inline">\(\forall a &gt; 0\)</span> 有 <spanclass="math inline">\(P(M(t)\ge a) = 2P(B(t)\ge a) = P(|B(t)|\gea)\)</span>.</p><p><strong>推论 5.7.2</strong>：<span class="math inline">\(\forall \xi&gt; 0, x\le\xi\)</span>，<span class="math inline">\(M(t)\)</span> 和<span class="math inline">\(B(t)\)</span> 的联合分布密度函数为 <spanclass="math inline">\(f_{M,B}(\xi,x) = \sqrt{\frac{2}{\pi}}(\frac{2\xi-x}{t^{3/2} }) \exp(-(2\xi-x)^2/2t)I_{[0,\infty)}(\xi)I_{(-\infty,\xi]}(x)\)</span>.</p><h2 id="过零点的反正弦定理">5.5 过零点的反正弦定理</h2><p><span class="math inline">\(\forall t_1 &lt; t_2\)</span>，记事件<span class="math inline">\(o(t_1,t_2)=\{\exists t\in(t_1,t_2),B(t)=0\}\)</span>，利用全概率公式有 <span class="math display">\[P(o(t_1,t_2)) = \int_{-\infty}^{\infty} P(o(t_1,t_2) | B(t_1)=x)\frac{1}{\sqrt{2\pi t_1} }e^{-x^2/2t_1} dx\]</span> 利用布朗运动的连续性和对称性有 <span class="math display">\[P(o(t_1,t_2)|B(t_1)=x) = P(\tau_x\le t_2-t_1) =\frac{2}{\sqrt{2\pi(t_2-t_1)} }\int_x^{\infty} e^{-u^2/2(t_2-t_1)} du\]</span> 于是有 <span class="math display">\[P(o(t_1,t_2)) = \frac{1}{\pi\sqrt{t_1(t_2-t_1)}}\int_0^{\infty}\int_x^{\infty} e^{-\frac{y^2}{2(t_2-t_1)} }dy \cdote^{-\frac{x^2}{2t_1} }dx\]</span>这个积分的直接求解非常困难，为求此积分，采用另外的方法，也即反正弦定理。</p><p><strong>定理 5.8（反正弦定理）</strong>：设 <spanclass="math inline">\(B(t)\)</span> 是标准布朗运动，记 <spanclass="math inline">\(\bar{o}(t_1,t_2)=\{B(t)\ne 0,\forallt\in(t_1,t_2)\}\)</span>，则 <spanclass="math inline">\(P(\bar{o}(t_1,t_2))=\frac{2}{\pi}\arcsin\sqrt{\frac{t_1}{t_2} }\)</span>，且当 <spanclass="math inline">\(t_1=xt, t_2=t, 0 &lt; x &lt; 1\)</span> 时，有<span class="math inline">\(P(\bar{o}(xt,t))=\frac{2}{\pi} \arcsin\sqrt{x}\)</span>.</p><p><strong>Remark</strong>：这说明布朗运动处处连续但处处不可导。</p><h2 id="布朗运动的推广">5.6 布朗运动的推广</h2><h3 id="带吸收点的布朗运动">5.6.1 带吸收点的布朗运动</h3><p>设 <span class="math inline">\(Z(t)=\begin{cases}B(t), &amp; t &lt;\tau_x \\ x, &amp; t\ge \tau_x \end{cases}\)</span>，为求 <spanclass="math inline">\(Z(t)\)</span> 的分布，不妨设 <spanclass="math inline">\(x &gt; 0\)</span></p><p>（1）当 <span class="math inline">\(y &gt; x\)</span> 时，<spanclass="math inline">\(P(Z(t) \le y)=1\)</span>；</p><p>（2）当 <span class="math inline">\(y=x\)</span> 时，<spanclass="math inline">\(P(Z(t)=x) = P(\tau_x\le t) = \frac{2}{\sqrt{2\pit} }\int_x^\infty e^{-u^2/2t} du\)</span>；</p><p>（3）当 <span class="math inline">\(y &lt; x\)</span> 时，</p><h3 id="原点反射的布朗运动">5.6.2 原点反射的布朗运动</h3><h3 id="几何布朗运动">5.6.3 几何布朗运动</h3><p>令 <spanclass="math inline">\(W(t)=e^{B(t)}\)</span>，称它为几何布朗运动，取<span class="math inline">\(B(t)\)</span> 的矩母函数 <spanclass="math inline">\(\phi(s)={\mathbb E}[e^{sB(t)}]\)</span>，则 <spanclass="math inline">\(\phi(s)=e^{ts^2/2}\)</span>，因此 <spanclass="math inline">\({\mathbb E}[W(t)]=\phi(1)=e^{t/2}\)</span>，<spanclass="math inline">\(D[W(t)] = {\mathbb E}[W^2(t)]-({\mathbbE}[W(t)])^2=\phi(2)-e^t = e^{2t}-e^t\)</span>.</p><p><em>栗子 5.2</em>：考虑股票市场收益率，<spanclass="math inline">\(S_0,S_n\)</span> 分别表示最初价位和最终价位，<spanclass="math inline">\(S_n=S_0 e^{B(t_1)-B(t_0)}\cdotse^{B(t_n)-B(t_{n-1})}\)</span>.</p><h3 id="布朗运动的积分">5.6.4 布朗运动的积分</h3><p>令 <span class="math inline">\(S(t)=\int_0^tB(u)du\)</span>，根据正态分布的性质知道他是正态过程，<spanclass="math inline">\({\mathbb E}S(t)=0\)</span>，<spanclass="math inline">\(\forall 0\le \delta \le t\)</span>，有 <spanclass="math display">\[\operatorname{cov}[S(\delta),S(t)] = {\mathbb E}[\int_0^\delta\int_0^tB(u)B(v)dudv] = \int_0^\delta\int_0^t(u\wedgev)dudv=\frac{\delta^2}{2}(t-\frac{\delta}{3})\]</span></p><h3 id="布朗运动的形式导数">5.6.5 布朗运动的形式导数</h3><p>考虑增量比，固定 <span class="math inline">\(\Delta t &gt;0\)</span>，令 <span class="math inline">\(\frac{B(t+\Deltat)-B(t)}{\Delta t} = \frac{\Delta B(t)}{\Delta t}\)</span>，</p><h2 id="布朗桥与经验分布">5.7 布朗桥与经验分布</h2><h3 id="布朗桥的基本概念与性质">5.7.1 布朗桥的基本概念与性质</h3><p><strong>定义</strong>：<spanclass="math inline">\(\{B(t),t\ge0\}\)</span> 为标准布朗运动，不妨设<span class="math inline">\(B(0)=0\)</span>，令 <spanclass="math inline">\(B_{00}(t)=B(t)-tB(1)\)</span>，则称 <spanclass="math inline">\(\{B_{00}(t), 0\le t\le 1\}\)</span>为<strong>布朗桥</strong>。</p><p>根据其定义，可以得到基本性质如下：</p><ol type="1"><li><spanclass="math inline">\(B_{00}(0)=B_{00}(1)=0\)</span>；（？？）</li><li><span class="math inline">\({\mathbb E}[B_{00}(t)]={\mathbbE}[B(t)-tB(1)]=0\)</span>；</li><li><span class="math inline">\(D[B_{00}(t)]={\mathbbE}[B_{00}^2(t)]=t(1-t)\)</span>；</li><li>设 <span class="math inline">\(s\le t\)</span>，<spanclass="math inline">\(\operatorname{cov}[B_{00}(s),B_{00}(t)]=s(1-t)\)</span>；</li><li><span class="math inline">\(\{B_{00}(t),0\le t\le1 \}\)</span>的分布与 <span class="math inline">\(\{B(t), t\ge0 \}\)</span> 在 <spanclass="math inline">\(B(1)=0\)</span> 下的条件分布相同。</li></ol><h3 id="经验分布与布朗桥的关系">5.7.2 经验分布与布朗桥的关系</h3><p>工程统计中，经常独立抽取多个样本 <spanclass="math inline">\(X_1,...,X_n\)</span>来统计某参量的统计特性，定义经验分布 <spanclass="math inline">\(\hat{F}_n(x) = \frac{1}{n}\sum_{i=1}^n I_{\{X_i\lex\} }\)</span>。假设 <span class="math inline">\(X_1,...,X_n\)</span>独立同分布，且 <span class="math inline">\(X_n\simF(x)\)</span>，则有：</p><ol type="1"><li><span class="math inline">\({\mathbb E}[\hat{F}_n(x)] =F(x)\)</span></li><li><spanclass="math inline">\(\operatorname{Var}[\hat{F}_n(x)]=\frac{1}{n}F(x)(1-F(x))\)</span></li><li>任意给定 <span class="math inline">\(x\)</span>，利用强大数定理得到任意给定 <span class="math inline">\(x\)</span>，利用强大数定理得到<spanclass="math inline">\(P(\lim_{n\to\infty}\hat{F}_n(x)=F(x))=1\)</span></li><li>任意给定 <spanclass="math inline">\(x\)</span>，利用中心极限定理得到 <spanclass="math inline">\(n\to\infty\)</span> 时有（依分布收敛）</li></ol><p><span class="math display">\[\frac{\sum_{i=1}^n (I_{\{X_i\le x\} }-F(x)) }{\sqrt{nF(x)(1-F(x))} }\overset{d}{=} {\mathcal N}(0,1)\]</span></p><p>证明：（2）<spanclass="math inline">\(\operatorname{Var}[\hat{F}_n(x)]={\mathbbE}[\hat{F}_n(x)^2] - F(x)^2 = \frac{1}{n^2}{\mathbb E}[\sum_{i=1}^nI_{\{X_i\le x\} } \sum_{j=1}^n I_{\{X_j\le x\} }]\)</span>，展开化简就可以得到性质 2.</p><p>（4）记 <spanclass="math inline">\(G_n(x)=\sqrt{n}(\hat{F}_n(x)-F(x))\)</span>，容易证明<span class="math inline">\({\mathbbE}G_n(x)=0,\operatorname{Var}G_n(x)=F(x)(1-F(x))\)</span>，特别的，根据中心极限定理，当<span class="math inline">\(n\to\infty\)</span> 时有 <spanclass="math inline">\(G_n(x)\overset{d}{=}G(x)\)</span>，其中 <spanclass="math inline">\(G(x)\sim {\mathcalN}(0,F(x)(1-F(x)))\)</span>。</p><p><strong>引理 5.1</strong>：如果 <span class="math inline">\(x_1 &lt;x_2\)</span>，则 <span class="math inline">\({\mathbbE}[G_n(x_1)G_n(x_2)] = F(x_1)(1-F(x_2))\)</span>。</p><p>证明：代入展开化简即可得到。</p><blockquote><p><strong>Remark</strong>：根据上述引理和 <spanclass="math inline">\(G_n(x)\)</span> 的性质可知，当 <spanclass="math inline">\(F_n(x)=x\)</span> 时，即 <spanclass="math inline">\(X_1,...,X_n\)</span> 服从 <spanclass="math inline">\([0,1]\)</span> 上的均匀分布时，<spanclass="math inline">\(G_n(x)\)</span> 的极限分别 <spanclass="math inline">\(G(x)\)</span> 是布朗桥。</p><p>事实上，对于一般的连续分布函数 <spanclass="math inline">\(F(x)\)</span>，<spanclass="math inline">\(G_n(x)\)</span> 的极限分布 <spanclass="math inline">\(G(x)\)</span>也可以用布朗桥表示。为此，首先给出如下引理。</p></blockquote><p><strong>引理 5.2</strong>：随机变量 <spanclass="math inline">\(X\)</span> 的分布函数 <spanclass="math inline">\(F(x)\)</span> 连续，则 <spanclass="math inline">\(Y=F(X)\)</span> 是一个 <spanclass="math inline">\([0,1]\)</span> 均匀分布的随机变量。</p><p>证明：<span class="math inline">\(\forall y\in[0,1]\)</span>，定义<span class="math inline">\(x=\inf\{u:F(u)\ge y\}\)</span>，因此有 <spanclass="math inline">\(P(F(X)\ge y)) = P(Y\gey)=1-F(x)=1-y\)</span>，从而有 <span class="math inline">\(P(Y &lt; y) =y\)</span>，证毕。</p><p>基于引理 5.2，可以定义 <span class="math inline">\(G^{ \#}(x)=B_{00}(F(x))\)</span>，利用布朗桥性质有 <spanclass="math inline">\(G^{ \# }(x)\)</span> 与 <spanclass="math inline">\(G(x)\)</span> 有相同的分布特性，从而可以推得 <spanclass="math inline">\(G_n(x)\)</span> 的极限分布为以 <spanclass="math inline">\(F(x)\)</span> 为参变量的布朗桥。</p><h3 id="经验分布的误差估计">5.7.3 经验分布的误差估计</h3><p>略。</p><h2 id="带漂移的布朗运动">5.8 带漂移的布朗运动</h2><p><strong>定义</strong>：设 <spanclass="math inline">\(\{B(t),t\ge0\}\)</span> 为标准布朗运动，记 <spanclass="math inline">\(X(t)=B(t)+\eta t\)</span>，其中 <spanclass="math inline">\(\eta\)</span> 为常数，称 <spanclass="math inline">\(\{X(t),t\ge0\}\)</span> 为带漂移的布朗运动。</p><h3 id="移出区间的概率计算">5.8.1 移出区间的概率计算</h3><p><strong>定理 5.9</strong>：对任意 <span class="math inline">\(A &gt;0, B &gt; 0\)</span>，定义停时 <spanclass="math inline">\(\tau=\inf\{t:X(t)=A ~ or ~ X(t)=-B \}\)</span>，则<span class="math inline">\(P_{A}=P(X(\tau)=A) = \frac{e^{2\etaB}-1}{e^{2\eta B}-e^{2\eta a} }\)</span>.</p><h3 id="首中时问题">5.8.2 首中时问题</h3><h2 id="布朗运动的轨道性质">5.9 布朗运动的轨道性质</h2><p><strong>轨道处处连续，几乎处处不可导</strong>。</p><p><strong>定理</strong>：标准布朗运动 <spanclass="math inline">\(B(t)\)</span>，对任意的 <spanclass="math inline">\(t\ge0\)</span>，有 <span class="math display">\[P(\lim_{h\to 0}\sup\left|\frac{B(t+h)-B(t)}{h}\right|=+\infty) = 1\]</span> 证明：略。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最大值与首中时的分布特性&quot;&gt;5.4 最大值与首中时的分布特性&lt;/h2&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(\{B(t),t\ge0\}\)&lt;/span&gt;
是标准布朗运动，不妨设 &lt;span class=&quot;math inline&quot;&gt;\(B(0)=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：首次击中 &lt;span
class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 的时间 &lt;span
class=&quot;math inline&quot;&gt;\(\tau_a=\inf\{t:t\ge0,B(t)=a\}\)&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="首中时" scheme="https://glooow1024.github.io/tags/%E9%A6%96%E4%B8%AD%E6%97%B6/"/>
    
    <category term="布朗运动" scheme="https://glooow1024.github.io/tags/%E5%B8%83%E6%9C%97%E8%BF%90%E5%8A%A8/"/>
    
    <category term="反正弦定理" scheme="https://glooow1024.github.io/tags/%E5%8F%8D%E6%AD%A3%E5%BC%A6%E5%AE%9A%E7%90%86/"/>
    
    <category term="布朗桥" scheme="https://glooow1024.github.io/tags/%E5%B8%83%E6%9C%97%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://glooow1024.github.io/2022/01/23/hello-world/"/>
    <id>https://glooow1024.github.io/2022/01/23/hello-world/</id>
    <published>2022-01-23T11:47:05.001Z</published>
    <updated>2019-12-10T11:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【高等数值分析】常微分方程数值解</title>
    <link href="https://glooow1024.github.io/2022/01/14/advanced-numerical-analysis/ada-nsode/"/>
    <id>https://glooow1024.github.io/2022/01/14/advanced-numerical-analysis/ada-nsode/</id>
    <published>2022-01-14T01:26:08.000Z</published>
    <updated>2022-01-14T01:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>求解常微分方程初值问题数值解 <span class="math display">\[\begin{align}&amp;\frac{dy}{dx} = f(x,y), \quad a &lt; x &lt; b, |y| &lt; \infty \\&amp;y(a) = y_0\end{align}\]</span> 存在唯一性定理：若 <span class="math inline">\(f(x,y)\)</span>连续，对 <span class="math inline">\(y\)</span> 满足 Lipschitz条件，那么初值问题有唯一解。</p><span id="more"></span><p>对上面的常微分方程积分就有 <span class="math inline">\(y(t_{n+k}) -y(t_{n-j}) = \int_{t_{n-j}}^{t_{n+k}} f(t,y(t))dt\)</span>，所以实际上可以转化为数值积分的问题，所以这一节的方法和数值积分很类似。但是这里的问题在于被积函数值是不知道的。</p><h2 id="线性多步法">2. 线性多步法</h2><p>在数值积分里面 <span class="math inline">\(f(t_k,y(t_k))\)</span>是已知的，主要是在设计求积节点对应的系数。在这里还需要首先估计每个节点的函数值。对前面的式子采样求积就得到<span class="math inline">\(y(t_{n+k}) - y(t_{n-j}) = h\sum_i \beta_if_{n-i}\)</span>，就引出了下面要介绍的线性多步法。</p><h3 id="线性多步法-1">2.1 线性多步法</h3><p>记 <span class="math inline">\(f_n=f(t_n,y_n),y_n=y(t_n)\)</span>，线性多步法（线性 <spanclass="math inline">\(k\)</span> 步法）的一般表达式为 <spanclass="math display">\[\sum_{i=0}^k \alpha_i y_{n+i} = h\sum_{i=0}^{k} \beta_i f_{n+i}\]</span> 其中 <span class="math inline">\(\alpha_k=1,\alpha_0^2+\beta_0^2\ne0\)</span>。给一些特例：</p><ul><li><span class="math inline">\(\alpha_0=-1,\beta_0=1,\beta_1=0\)</span>时为显式Euler法 <span class="math inline">\(y_{n+1}=y_n +hf_n\)</span>；</li><li><span class="math inline">\(\alpha_0=-1,\beta_0=0,\beta_1=1\)</span>时为隐式Euler法 <span class="math inline">\(y_{n+1}=y_n +hf_{n+1}\)</span>；</li><li><span class="math inline">\(\alpha_0=-1,\beta_0=\beta_1=1/2\)</span>时为梯形法 <span class="math inline">\(y_{n+1} = y_n +h/2(f_n+f_{n+1})\)</span>。</li></ul><p>可以定义<strong>“特征多项式”</strong>，在后面分析稳定性和收敛性的时候会很有用<span class="math display">\[\rho(\xi) = \sum_{i=0}^k \alpha_i \xi^i, \quad \sigma(\xi)=\sum_{i=0}^k\beta_i\xi^i\]</span>如何衡量数值求解方法的精度呢？定义<strong>局部截断误差</strong>为 <spanclass="math display">\[T_{n+k} = \sum_{i=0}^k [\alpha_i y(t_{n+i}) - h\beta_i y&#39;(t_{n+i})]\]</span> 对上面的式子做Taylor展开，可以得到形如 <spanclass="math inline">\(T_{n+1} = -1/90 h^5y^{(5)}(x_n)+O(h^6)\)</span>（这是Simpson公式的局部截断误差），这个式子表明Simpson公式是4阶的。</p><p>对于线性 <span class="math inline">\(k\)</span>步法，要想设计一种迭代方法使得数值精度是 <spanclass="math inline">\(p\)</span>阶的，可以采用待定系数法，保证局部截断误差中 <spanclass="math inline">\(y^{(1)}(x),...,y^{(q)}(x)\)</span>前面的系数都是0。</p><h3 id="稳定性与收敛性">2.2 稳定性与收敛性</h3><h4 id="相容性">2.2.1 相容性</h4><p>首先引入相容性的概念。若某个多步法的截断误差满足 <spanclass="math inline">\(T(t,y(t),h)=o(h)\)</span>那么称其为<strong>相容的</strong>。若 <spanclass="math inline">\(T(t,y(t),h)=O(h^{q+1})\)</span>，则称其为 <spanclass="math inline">\(q\)</span> 阶的。</p><p>实际上，相容性就是说该方法至少是1阶的，也就是当 <spanclass="math inline">\(y\)</span>为一次线性函数时，该方法要能够得到准确解。</p><p><strong>定理</strong>：相容的多步法充要条件是 <spanclass="math inline">\(\rho(1)=0,\rho&#39;(1)=\sigma(1)\)</span>。</p><h4 id="零稳定性">2.2.2 零稳定性</h4><p><strong>根条件</strong>：若多项式 <spanclass="math inline">\(\rho(\xi)\)</span> 的 <spanclass="math inline">\(k\)</span> 个根的模长都<strong>不大于1</strong>，并且模值等于 1 的根都是单根，则称其满足根条件。</p><p><strong>Note</strong>：根条件考虑的是齐次差分方程的解。当 <spanclass="math inline">\(f\equiv 0\)</span>的时候，齐次差分方程的解具有指数形式 <spanclass="math inline">\(y(n)=\sum_i P(n) \xi_i^n\)</span>，其中 <spanclass="math inline">\(P(n)\)</span> 是一个多项式， <spanclass="math inline">\(\xi_i\)</span> 就是 <spanclass="math inline">\(\rho(\xi)\)</span>的根（这里没考虑重根的情况，不过是类似的），如果 <spanclass="math inline">\(|\xi_i|&lt;1\)</span> 就意味着 <spanclass="math inline">\(\lim_{n\to\infty}y(n) =0\)</span>，那么这跟稳定性有什么关系呢？</p><p><strong>定理</strong>：线性多步法关于初值稳定的充要条件是 <spanclass="math inline">\(\rho(\xi)\)</span> 满足根条件。</p><p><strong>Note</strong>：这个定理说明了根条件和（零）稳定性二者的等价关系。为什么呢？假设真实的初值为<span class="math inline">\(y_0=y(t_0)\)</span>，真实的解为 <spanclass="math inline">\(y(n)=y_0\xi_0^{(n-t_0)}\)</span>。而我们计算的时候由于各种原因拿到的初值是有误差的，也就是<span class="math inline">\(\hat{y}_0\)</span>，那么最后求得的误差就是<spanclass="math inline">\(\hat{y}(n)-y(n)=(\hat{y}_0-y_0)\xi_0^{(n-t_0)}\)</span>，如果不满足根条件，当<span class="math inline">\(n\to\infty\)</span> 的时候，<spanclass="math inline">\(\hat{y}(n)-y(n) \to\infty\)</span>，解就是不稳定的。</p><h4 id="收敛性">2.2.3 收敛性</h4><p><strong>定义</strong>：假设在区间 <spanclass="math inline">\([a,b]\)</span> 上等距划分 <spanclass="math inline">\(N\)</span> 个区间，<span class="math inline">\(x_n= a+nh,n=0,1,...,N\)</span>，求解初值问题得到的解为 <spanclass="math inline">\(y_n,n=0,1,...,N\)</span>，最大整体误差为 <spanclass="math inline">\(E(h) = \max_{n} |y(x_n) - y_n|\)</span>，如果满足<span class="math inline">\(\lim_{h\to0}E(h)=0\)</span>，则称方法是<strong>收敛</strong>的。如果 <spanclass="math inline">\(E(h) \le Ch^p\)</span>，则称方法是 <spanclass="math inline">\(p\)</span> 阶收敛的。</p><p><strong>定理</strong>：相容性 + 零稳定性 <spanclass="math inline">\(\iff\)</span> 收敛性。</p><h4 id="绝对稳定性">2.2.4 绝对稳定性</h4><p>前面的零稳定性是跟所选择的方法有关的。而这里的绝对稳定性研究的是微分方程本身的属性。如果方程本身性质很不好，那么可能无论选择什么方法都是不稳定的。</p><p>取 <span class="math inline">\(f(x,y)=\lambday\)</span>，再研究方法的稳定性。以试验方程为例 <spanclass="math display">\[\begin{cases}y&#39; = \lambda y, t\in[a,b] \\y(a) = \tilde{y}_0\end{cases}\]</span> 用Euler法得到 <span class="math inline">\(y_n =(1+h\lambda)y_{n-1}\)</span>，于是两个解的误差满足 <spanclass="math inline">\(y_n-z_n = (1+h\lambda)^n (y_0-z_0)\)</span>，若<spanclass="math inline">\(|1+h\lambda|&gt;1\)</span>，则误差总会放大，这是我们不希望的。</p><p>要保证稳定性，既与方程本身的性质（也即 <spanclass="math inline">\(\lambda\)</span>） 有关，也与所选择的步长 <spanclass="math inline">\(h\)</span>有关。从另一个角度而言，方程本身的性质（<spanclass="math inline">\(\lambda\)</span>）会影响可选择的 <spanclass="math inline">\(h\)</span> 的范围。由此引出绝对稳定性的概念。</p><p>对前面提到的线性多步法，把 <span class="math inline">\(f(x,y)=\lambday\)</span> 代回去就有 <span class="math display">\[\sum_{i=0}^k (\alpha_i - h\lambda \beta_i) y_{n+i} = 0\]</span> 称 <span class="math inline">\(\Pi(\xi;z) = \rho(\xi) -z\sigma(\xi)\)</span> 为<strong>稳定多项式</strong>。</p><p><strong>定理</strong>：对给定的 <spanclass="math inline">\(z\)</span>，若 <spanclass="math inline">\(\Pi(\xi;z)\)</span> 的 <spanclass="math inline">\(k\)</span> 个根的模都<strong>小于1</strong>，则其是绝对稳定的。（满足这样条件的 <spanclass="math inline">\(z\)</span>的集合构成<strong>绝对稳定区域</strong>。）</p><h2 id="runge-kutta方法">3. Runge-Kutta方法</h2><p>Runge-Kutta方法和线性多步法的主要区别在于，其在 <spanclass="math inline">\(x_n,x_{n+1}\)</span>中间又进行了采样、插值。这种方法大概可以表示为 <spanclass="math display">\[\begin{align}&amp; y_{n+1} = y_n + h\sum_{i=1}^{s} b_i k_i \\&amp; k_i = y_n + f(t_n + c_i h, y_n + \sum_{i=1}^s a_{ij} k_j)\end{align}\]</span> 其中 <span class="math inline">\(0\le c_i\le1\)</span>。实际上<span class="math inline">\(k_i \approx y(t_n+c_i h)\)</span>，就是在<span class="math inline">\([y_n,y_{n+1}]\)</span>中间又进行了采样插值。</p><p>这样提高了精度，同时也会增加计算复杂度。</p><p>除此之外，提高精度的方法还有 Richardson 外推方法。</p><h2 id="刚性问题">4. 刚性问题</h2><p>刚性问题也是方程本身的属性，主要是指某些情况下两个特解的尺度相差很大，比如两个指数衰减的过程混合在一起，但是其中一个衰减特别快（<spanclass="math inline">\(\exp(-\lambda t)\)</span> 的 <spanclass="math inline">\(\lambda\)</span>特别大），另一个则衰减特别慢，那么数值求解的时候很可能只能看到衰减慢的那个过程，另一个则被忽略。这在化学反应中是经常遇到的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;求解常微分方程初值问题数值解 &lt;span class=&quot;math display&quot;&gt;\[
\begin{align}
&amp;amp;\frac{dy}{dx} = f(x,y), \quad a &amp;lt; x &amp;lt; b, |y| &amp;lt; \infty \\
&amp;amp;y(a) = y_0
\end{align}
\]&lt;/span&gt; 存在唯一性定理：若 &lt;span class=&quot;math inline&quot;&gt;\(f(x,y)\)&lt;/span&gt;
连续，对 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 满足 Lipschitz
条件，那么初值问题有唯一解。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="常微分方程" scheme="https://glooow1024.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
    <category term="刚性问题" scheme="https://glooow1024.github.io/tags/%E5%88%9A%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【高等数值分析】数值积分和数值微分</title>
    <link href="https://glooow1024.github.io/2022/01/09/advanced-numerical-analysis/ada-integration/"/>
    <id>https://glooow1024.github.io/2022/01/09/advanced-numerical-analysis/ada-integration/</id>
    <published>2022-01-09T13:55:54.000Z</published>
    <updated>2022-01-09T13:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>根据Newton-Leibniz公式有 <span class="math inline">\(\int_a^x f(t)dt=F(x)-F(a)\)</span>，但是绝大部分情况很难解析求解，需要数值积分。例如<strong>中点公式</strong><span class="math display">\[\int_a^b f(x)dx \approx f(\frac{a+b}{2})(b-a)\]</span> 若 <span class="math inline">\(f(x)\inC^2[a,b]\)</span>，则中点公式<strong>截断误差</strong>为 <spanclass="math display">\[\int_a^b f(x)dx - f(\frac{a+b}{2})(b-a) = \frac{(b-a)^2}{24}f&#39;&#39;(\xi), \quad \xi\in(a,b)\]</span> <span id="more"></span></p><h2 id="插值型求积公式">2. 插值型求积公式</h2><p>顾名思义，就是先插值再求积分。方法为给定求积节点 <spanclass="math inline">\(x_k,k=0,1,...,n\)</span> 和求积系数 <spanclass="math inline">\(A_k,k=0,1,...,n\)</span>，插值型求积公式表示为<span class="math display">\[\int_a^b f(x)dx \approx \sum_{k=0}^n A_k f(x_k)\]</span> 根据多项式插值中的理论，余项可表示为 <spanclass="math display">\[E_n(f) = \frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x)) w_{n+1}(x) dx\]</span> 当 <span class="math inline">\(f(x)\in{\mathcal P}_n\)</span>时都有 <spanclass="math inline">\(E_n(f)=0\)</span>。由此可以定义代数精度，如果对所有<span class="math inline">\(p\in{\mathcal P}_m\)</span> 有 <spanclass="math inline">\(E_n(p)=0\)</span>，而对某个 <spanclass="math inline">\(q\in{\mathcal P}_{m+1}\)</span> 有 <spanclass="math inline">\(E_n(q)\ne 0\)</span>，称求积公式具有 <spanclass="math inline">\(m\)</span> 次<strong>代数精度</strong>。</p><p>插值型求积公式主要分为两类：Newton-Cotes求积公式和Gauss型求积公式。前者等距选取插值节点，后者则未必。</p><h3 id="newton-cotes求积公式">2.1 Newton-Cotes求积公式</h3><p>方法是将区间 <span class="math inline">\([a,b]\)</span> <spanclass="math inline">\(n\)</span> 等分，得到 <spanclass="math inline">\(h =\frac{b-a}{n},x_k=a+kh,k=0,...,n\)</span>，再利用Lagrange插值公式 <spanclass="math inline">\(l_k(x)\)</span>，得到 <spanclass="math display">\[\int_a^b f(x)dx = (b-a)\sum_{k} \frac{f(x_k)}{b-a}\int_a^b l_k(x)dx =(b-a)\sum_k C_k^{(n)} f(x_k)\]</span> 其中 <spanclass="math inline">\(C_k^{(n)}=\frac{1}{b-a}\int_a^b \prod_{j\nek}\frac{x-x_j}{x_k-x_j}dx = \frac{1}{n}\int_a^b \prod_{j\nek}\frac{t-j}{k-j}dx\)</span> 称为 Cotes求积系数，不仅<strong>与被积函数无关</strong>，<strong>与求积区间也无关</strong>。</p><p>该方法有如下性质：</p><ul><li><span class="math inline">\(\sum_{k=0}^n C_k^{(n)} = 1\)</span>（取<span class="math inline">\(f\equiv1\)</span> 即可得证）；</li><li><span class="math inline">\(E_n(f) = \frac{1}{(n+1)!}\int_a^bf^{(n+1)}(\xi(x)) w_{n+1}(x) dx\)</span>；</li><li>当 <span class="math inline">\(n\)</span> 为偶数时，代数精度为 <spanclass="math inline">\(n+1\)</span>；当 <spanclass="math inline">\(n\)</span> 为奇数时，代数精度为 <spanclass="math inline">\(n\)</span>。（直观理解是因为奇次多项式的奇对称性积分后恰好为0）</li></ul><p>下面是 <span class="math inline">\(n\)</span> 取不同数值的特例。</p><p><span class="math inline">\(n=1\)</span> 时为梯形公式，代数精度为<span class="math inline">\(1\)</span>： <span class="math display">\[\begin{align}&amp;\int_a^b f(x)dx \approx \frac{b-a}{2}[f(a)+f(b)] \\&amp;E_1(f) = -\frac{(b-a)^3}{12} f&#39;&#39;(\xi), \xi\in[a,b]\end{align}\]</span> <span class="math inline">\(n = 2\)</span> 时为 Simpson公式，代数精度为 <span class="math inline">\(3\)</span>： <spanclass="math display">\[\begin{align}&amp;\int_a^b f(x)dx \approx \frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]\\&amp;E_1(f) = -\frac{(b-a)^5}{2880} f^{(4)}(\xi), \xi\in[a,b]\end{align}\]</span></p><h3 id="gauss型求积公式">2.2 Gauss型求积公式</h3><p>求积公式也表示为 <span class="math display">\[\int_a^b f(x)dx \approx \sum_{k=0}^n A_k f(x_k)\]</span>但与Newton-Cotes方法不同的是求积节点并非等距选取，而是将参数待定，解出使代数精度最高的参数<span class="math inline">\(A_k\)</span> 和 <spanclass="math inline">\(x_k\)</span>。共有 <spanclass="math inline">\(2n+2\)</span> 个参数待定，分别取 <spanclass="math inline">\(f(x)=1,x,x^2,...,x^{2n+1}\)</span>列方程组，因此代数精度最高可以达到 <spanclass="math inline">\(2n+1\)</span>。</p><p>从理论上也可以证明代数精度至多为 <spanclass="math inline">\(2n+1\)</span>。</p><p>证明：取 <spanclass="math inline">\(f(x)=\prod_{k=0}^n(x-x_k)^2\)</span>，那么上面等式左边一定有<span class="math inline">\(\int_a^b f(x)dx &gt;0\)</span>，但是等式右边有 <span class="math inline">\(\sum_{k} A_kf(x_k)=0\)</span>，显然不相等。证毕。</p><p>除此之外，Gauss型求积公式还可以拓展到带权积分的情况，也即 <spanclass="math display">\[\int_a^b \rho(x)f(x)dx = \sum_{k=0}^n A_k f(x_k) +\frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x)) w_{n+1}(x) dx\]</span> 关键问题是如何求解 <spanclass="math inline">\(A_k,x_k\)</span> 呢？</p><p>由于代数精度为 <span class="math inline">\(2n+1\)</span>，对 <spanclass="math inline">\(\forall f\in{\mathcalP}_{2n+1}\)</span>，截断误差应满足 <spanclass="math inline">\(\frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x))w_{n+1}(x) dx=0\)</span>。又由于 <spanclass="math inline">\(f^{(n+1)}\in{\mathcal P}_n\)</span>，那么只需要取<span class="math inline">\(w_{n+1}(x)\)</span> 为 <spanclass="math inline">\(n+1\)</span> 阶正交多项式（权函数为 <spanclass="math inline">\(\rho\)</span>）即可满足该条件。因此Gauss型求积公式的求解方法为：</p><ol type="1"><li>权函数为 <span class="math inline">\(\rho\)</span>，求 <spanclass="math inline">\(n+1\)</span> 阶正交多项式；</li><li>求 <span class="math inline">\(n+1\)</span> 个根 <spanclass="math inline">\(x_k\)</span>（在逼近一章中已经证明了一定存在 <spanclass="math inline">\(n+1\)</span> 个不同的根）；</li><li>取 <span class="math inline">\(f(x)=1,x,...,x^n\)</span>列线性方程组求 <span class="math inline">\(A_k\)</span>。</li></ol><p>Gauss型求积公式有如下性质：</p><ul><li><span class="math inline">\(A_k &gt; 0,k=0,1,...,n\)</span>（取<span class="math inline">\(f(x)=l_i(x)\)</span> 即可证明）；</li><li><span class="math inline">\(\sum_{k=0}^n A_k = \int_a^b\rho(x)dx\)</span>（取 <span class="math inline">\(f\equiv\)</span>即可证明）；</li><li>余项 <span class="math inline">\(E_n(f) =\frac{1}{(2n+2)!}f^{(2n+2)}(\eta)\int_a^b \rho(x) [w_{n+1}(x)]^2dx\)</span>。</li></ul><h2 id="数值微分">3. 数值微分</h2><p>数值微分和数值积分类似，也有插值型微分公式，即先进性多项式插值，再求导数值。</p><p>还可以利用Richardson外推公式提高精度。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;根据Newton-Leibniz公式有 &lt;span class=&quot;math inline&quot;&gt;\(\int_a^x f(t)dt
=
F(x)-F(a)\)&lt;/span&gt;，但是绝大部分情况很难解析求解，需要数值积分。例如&lt;strong&gt;中点公式&lt;/strong&gt;
&lt;span class=&quot;math display&quot;&gt;\[
\int_a^b f(x)dx \approx f(\frac{a+b}{2})(b-a)
\]&lt;/span&gt; 若 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\in
C^2[a,b]\)&lt;/span&gt;，则中点公式&lt;strong&gt;截断误差&lt;/strong&gt;为 &lt;span
class=&quot;math display&quot;&gt;\[
\int_a^b f(x)dx - f(\frac{a+b}{2})(b-a) = \frac{(b-a)^2}{24}
f&amp;#39;&amp;#39;(\xi), \quad \xi\in(a,b)
\]&lt;/span&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数值积分" scheme="https://glooow1024.github.io/tags/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【高等数值分析】函数逼近</title>
    <link href="https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-approximation/"/>
    <id>https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-approximation/</id>
    <published>2022-01-07T15:47:30.000Z</published>
    <updated>2022-01-07T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>函数插值当中我们只有几个离散的的插值节点及其函数值，在函数逼近里我们考虑的是有一个<span class="math inline">\(f(x),x\in[a,b]\)</span>已知，但是希望用一组简单的基函数 <spanclass="math inline">\(\{\phi_0,...,\phi_n\}\)</span> 逼近 <spanclass="math inline">\(f(x)\)</span>。</p><span id="more"></span><p>首先定义加权内积为 <span class="math inline">\(\langlef,g\rangle_\rho = \int_a^b \rho(x)f(x)g(x)dx\)</span>，其中 <spanclass="math inline">\(\rho(x)\ge0\)</span>为权函数。相应的可以导出范数定义为 <span class="math inline">\(\Vertf\Vert_\rho = \sqrt{\langlef,f\rangle_\rho}\)</span>。后面为了符号简洁都默认省略下标 <spanclass="math inline">\(\rho\)</span>。</p><p>一般考虑最佳平方逼近问题，即 <spanclass="math inline">\(\min_{s\in\Phi} \Vert f-s\Vert\)</span>，其中<span class="math inline">\(\Phi\)</span>为某个函数空间，一般为代数多项式、三角多项式或有理多项式组。</p><h2 id="多项式逼近">2. 多项式逼近</h2><h3 id="总体框架">2.1 总体框架</h3><p>若 <spanclass="math inline">\(\Phi=\operatorname{span}\{\phi_0,...,\phi_n\}\)</span>，<spanclass="math inline">\(\{\phi_j,j=0,...,n\}\)</span>为一组线性无关的的基函数，那么 <span class="math inline">\(\foralls\in\Phi\)</span> 可以表示为 <span class="math inline">\(s(x) =\sum_{j=0}^n a_j\phi_j(x)\)</span>，最佳平方逼近问题变为 <spanclass="math display">\[\min_{s\in\Phi} F(a_0,...,a_n) \triangleq \Vert f-\sum a_j\phi_j \Vert^2\]</span> 令 <span class="math inline">\(\partial F/\partiala_k=0\)</span> 即可得到下面的法方程，再求解线性方程组即可得到 <spanclass="math inline">\(a_k\)</span> <span class="math display">\[\sum_{i=0}^n \langle \phi_i, \phi_k\rangle a_i = \langlef,\phi_k\rangle, \quad k=0,1,...,n\]</span>除了前面的求导得到法方程，还可以利用<strong>Galerkin条件</strong>（实际上与法方程等价）<span class="math display">\[\langle f-s^{\ast}, s\rangle = 0, \quad s\in\Phi\]</span> 根据前面的结论，要想求得 <spanclass="math inline">\(a_k\)</span> 需要解法方程 <spanclass="math inline">\({\Psi}\boldsymbol{a}=\boldsymbol{b}\)</span>，为了进一步简化该问题，可以选择基函数<span class="math inline">\(\phi_j\)</span> 相互正交，那么 <spanclass="math inline">\(\Psi\)</span> 就会退化为对角阵，并且此时有 <spanclass="math display">\[s^{\ast} = \sum_{k=0}^n \frac{\langle f,\phi_k\rangle}{\Vert\phi_k\Vert^2} \phi_k\]</span> 后面的关键就是如何获得相互正交的一组基函数？</p><h3 id="正交多项式">2.2 正交多项式</h3><p>答案就是Gram-Schmidt正交化。对于多项式基函数 <spanclass="math inline">\(\phi_k\in{\mathcal P}_k\)</span>，只需要对 <spanclass="math inline">\(\{1,x,x^2,...\}\)</span>逐次进行Gram-Schmidt正交化即可。 <span class="math display">\[\phi_k = x^k - \sum_{j=0}^{k-1} \frac{\langle x^k,\phi_j\rangle}{\langle\phi_j,\phi_j\rangle} \phi_j\]</span> 后面将介绍几种不同的正交多项式，他们的区别就在于支撑区间 <spanclass="math inline">\([a,b]\)</span> 和权函数 <spanclass="math inline">\(\rho(x)\)</span> 的不同。</p><h4 id="lengdre多项式">2.2.1 Lengdre多项式</h4><p><spanclass="math inline">\(\rho(x)=1,x\in[-1,1],\phi_0(x)=1\)</span>，有如下性质：</p><ul><li>递推关系：<span class="math inline">\((n+1)P_{n+1}(x) =(2n+1)xP_n(x) - n P_{n-1}(x)\)</span></li><li>奇偶性：<span class="math inline">\(P_n(-x) = (-1)^nP_n(x)\)</span></li><li><span class="math inline">\([-1,1]\)</span> 上Lengdre多项式与 <spanclass="math inline">\(f\equiv0\)</span> 的平方误差最小</li></ul><h4 id="chebyshev多项式">2.2.2 Chebyshev多项式</h4><p><spanclass="math inline">\(\rho(x)=1/\sqrt{1-x^2},x\in[-1,1],\phi_0=1\)</span>，有如下性质：</p><ul><li>递推关系：<span class="math inline">\(T_{n+1}(x) =2xT_n(x)-T_{n-1}(x)\)</span></li><li>奇偶性：<span class="math inline">\(P_n(-x) = (-1)^nP_n(x)\)</span></li><li><span class="math inline">\(T_n(x)\)</span> 在 <spanclass="math inline">\((-1,1)\)</span> 上有 <spanclass="math inline">\(n\)</span> 个不同的零点 <spanclass="math inline">\(x_k=\cos\frac{(2k-1)\pi}{2n},k=1,2,..,n\)</span></li></ul><h4 id="lagurre多项式">2.2.3 Lagurre多项式</h4><p><spanclass="math inline">\(\rho(x)=e^{-x},x\in(0,+\infty),\phi_0=1\)</span></p><h4 id="hermite多项式">2.2.4 Hermite多项式</h4><p><spanclass="math inline">\(\rho(x)=\exp(-x^2),x\in(-\infty,\infty),\phi_0=1\)</span></p><h2 id="pade逼近">3. Pade逼近</h2><p>Pade逼近是用有理多项式 <span class="math inline">\(R_{n,m}(x) =\frac{R_n(x)}{Q_m(x)}\)</span> 逼近 <spanclass="math inline">\(f(x)\)</span>，其中 <spanclass="math inline">\(P_n\in{\mathcal P}_n,Q_m\in{\mathcalP}_m\)</span>。如果对 <span class="math inline">\(f(x)\)</span> 做Taylor 展开的话，能得到 <span class="math display">\[f(x)Q_m(x) - P_n(x) = \sum_{i=0}^\infty c_ix^i\]</span> 理论上有 <span class="math inline">\(n+m+1\)</span>个待定系数，因此可以列出方程 <spanclass="math inline">\(c_0=c_1=\cdots=c_{n+m}=0\)</span>，即可得到 <spanclass="math inline">\(R_{n,m}\)</span>。</p><h2 id="最小二乘">4. 最小二乘</h2><p>如果给定了很多个节点函数值 <spanclass="math inline">\(f(x_i)\)</span>，但是不要求满足插值条件 <spanclass="math inline">\(f(x_i)=\phi(x_i)\)</span>，而只要求最小化平方误差<span class="math inline">\(\sum_i(f(x_i)-\phi(x_i))^2\)</span>，那么就是最小二乘问题 <spanclass="math display">\[\min \Vert b-Ax\Vert \Rightarrow x^{\ast} = (A^TA)^{-1}A^Tb\]</span> 也可以对 <span class="math inline">\(A\)</span>做QR分解，那么就有 <spanclass="math inline">\(Rx^{\ast}=Q^Tb\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;函数插值当中我们只有几个离散的的插值节点及其函数值，在函数逼近里我们考虑的是有一个
&lt;span class=&quot;math inline&quot;&gt;\(f(x),x\in[a,b]\)&lt;/span&gt;
已知，但是希望用一组简单的基函数 &lt;span
class=&quot;math inline&quot;&gt;\(\{\phi_0,...,\phi_n\}\)&lt;/span&gt; 逼近 &lt;span
class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="多项式逼近" scheme="https://glooow1024.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%80%BC%E8%BF%91/"/>
    
    <category term="Pade逼近" scheme="https://glooow1024.github.io/tags/Pade%E9%80%BC%E8%BF%91/"/>
    
    <category term="Lengdre多项式" scheme="https://glooow1024.github.io/tags/Lengdre%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="Chebyshev多项式" scheme="https://glooow1024.github.io/tags/Chebyshev%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【高等数值分析】多项式插值</title>
    <link href="https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-interpolation/"/>
    <id>https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-interpolation/</id>
    <published>2022-01-07T15:46:20.000Z</published>
    <updated>2022-01-07T15:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>假设有离散的 <span class="math inline">\(\{x_0,x_1,...,x_n\}\)</span>插值节点，以及对应的函数值 <spanclass="math inline">\(\{f(x_0),....,f(x_n)\}\)</span>，希望用函数 <spanclass="math inline">\(\phi(x)\)</span> 来近似 <spanclass="math inline">\(f(x)\)</span>，使其满足插值条件 <spanclass="math inline">\(\phi(x_i)=f(x_i),i=0,...,n\)</span>。一般选择多项式插值函数<span class="math inline">\(p(x)=a_0+a_1x+\cdots+a_n x^n \in {\mathcalP}_n\)</span>。</p><span id="more"></span><p>根据插值条件 <span class="math inline">\(f(x_i)=\phi(x_i)\)</span>列出来 <span class="math inline">\(n+1\)</span> 个等式，再由 Hilbert阵的非奇异性质，可以证明插值函数 <spanclass="math inline">\(p(x)\)</span> 存在且唯一。但同时也由于 Hilbert的病态性，使得这种直接暴力求解的方式不好使。后面给出几种更好用的方法。</p><h2 id="lagrange插值">2. Lagrange插值</h2><p>采用了类似“正交基”的想法，如果有 <spanclass="math inline">\(n+1\)</span> 个插值节点，就先给出 <spanclass="math inline">\(n+1\)</span>个“正交基函数”，然后再用线性组合即可得到插值函数。</p><p>选择基底函数为 <span class="math display">\[l_i(x) = \prod_{k=0,k\ne i}^n \frac{x-x_k}{x_i-x_k}= \begin{cases}1, &amp; x=x_i \\0, &amp; x=x_k,k\ne i\end{cases}\]</span> 对应构造的插值函数为 <spanclass="math inline">\(L_n(x)=\sum_{i=0}^nf(x_i)l_i(x)\)</span>，插值余项 <span class="math display">\[R_n(x)\triangleq f(x)-L_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}w_{n+1}(x)\]</span> 其中 <spanclass="math inline">\(\xi(x)\in[a,b]\)</span>，<spanclass="math inline">\(w_{n+1}(x)=\prod_{k=0}^n(x-x_k)\)</span>。</p><p><strong>插值余项的证明</strong>：<span class="math inline">\(\forallx\in[a,b]\)</span>，将其看作新增插值节点，那么我们构造一个新的Lagrange插值函数<span class="math display">\[l_{n+1}(t) = R_n(x)\frac{w_{n+1}(t)}{w_{n+1}(x)}=\begin{cases}R_n(x), &amp; t=x \\0, &amp; t=x_0,...,x_n\end{cases}\]</span> 那么我们取 <span class="math inline">\(L_{n+1}(t) = L_n(t) +l_{n+1}(t)\)</span>，可以验证其满足 <spanclass="math inline">\(L_{n+1}(x_i)=f(x_i), t\in\{x,x_0,...,x_n\}\)</span>，也就是说他是新的插值函数，插值节点为 <spanclass="math inline">\(\{x,x_0,...,x_n\}\)</span>。此时插值余项为 <spanclass="math inline">\(R_{n+1}(t)=f(t)-L_{n+1}(t)=R_n(t)-l_{n+1}(t)\)</span>，其满足<span class="math inline">\(R_{n+1}(t)=0,t\in\{x,x_0,...,x_n\}\)</span>，反复应用 Rolle 定理，即可得到存在 <spanclass="math inline">\(\xi\in[a,b]\)</span> 使得 <spanclass="math inline">\(R_{n+1}^{(n+1)}(\xi)=f^{(n+1)}(\xi)-\frac{(n+1)!}{w_{n+1}(x)}R_n(x)\)</span>，证毕。</p><h2 id="newton插值">3. Newton插值</h2><h3 id="newton插值及其余项">3.1 Newton插值及其余项</h3><p>前面Lagrange插值方法存在的一个问题在于，如果新增一个插值节点，所有的基底函数<span class="math inline">\(l_i(x)\)</span>都要重新计算。Newton插值就是要克服这个问题，其思路在前面“插值余项的证明”过程中已经显现了，也就是每次新增一个插值节点，多项式的阶数会+1，那么我们就增加一个 <span class="math inline">\(n+1\)</span>次多项式来弥补。具体方法如下。 <span class="math display">\[N_n(x) = N_{n-1}(x) + a_n w_n(x)\]</span> 其中 <span class="math inline">\(N_{n-1}(x)\)</span> 为 <spanclass="math inline">\(\{x_0,...,x_{n-1}\}\)</span>的Newton插值函数，现在新增节点 <spanclass="math inline">\(x_n\)</span>，其插值函数 <spanclass="math inline">\(N_n(x)\)</span> 只需要添加一个 <spanclass="math inline">\(n\)</span> 阶多项式 <spanclass="math inline">\(a_n w_n(x)\)</span>，由 <spanclass="math inline">\(N_n(x_n)=f(x_n)\)</span> 可以推出 <spanclass="math inline">\(a_n =\frac{f(x_n)-N_{n-1}(x_n)}{w_n(x_n)}\)</span>，记为<strong>均差</strong><span class="math inline">\(a_n=f[x_0,...,x_n]\)</span>（实际上就是<span class="math inline">\(x^{n+1}\)</span>的系数，因此与节点的排列次序无关）。</p><p>由此得到Newton插值方法 <span class="math display">\[N_n(x) = \sum_{k=0}^n f[x_0,...,x_k] w_k(x)\]</span> 实际计算过程中均差可以递归计算 <span class="math display">\[f[x_0,...,x_n] = \frac{f[x_1,...,x_n] - f[x_0,...,x_{n-1}]}{x_n-x_0}\]</span> 证明：取 <span class="math inline">\(P_{n-1}(x)\in{\mathcalP}_{n-1}\)</span> 满足 <spanclass="math inline">\(P_{n-1}(x_i)=f(x_i),i=0,1,...,n-1\)</span>， <spanclass="math inline">\(Q_{n-1}(x)\in{\mathcal P}_{n-1}\)</span> 满足<spanclass="math inline">\(Q_{n-1}(x_i)=f(x_i),i=1,2,...,n\)</span>。构造<span class="math inline">\(P_n(x)=\frac{x-x_0}{x_n-x_0}Q_{n-1}(x) +\frac{x_n-x}{x_n-x_0}P_{n-1}(x) \quad(\bigstar)\)</span>，可以验证满足<span class="math inline">\(P_n(x_i)=f(x_i),i=0,...,n\)</span>。考虑<span class="math inline">\((\bigstar)\)</span> 式等号两侧 <spanclass="math inline">\(x^n\)</span> 的系数，即可得证。</p><p>插值余项为 <span class="math display">\[R_n(x) = f[x_0,...,x_n,x]\prod_{i=0}^n (x-x_i)\]</span> 证明：类似Lagrange中的方法，同样是将 <spanclass="math inline">\(x\)</span> 看作一个新的插值节点即可。证毕。</p><h3 id="高阶项">3.2 高阶项</h3><p>插值条件中除了直接给出函数值 <spanclass="math inline">\(f(x_i)\)</span>，有时候也会给出 <spanclass="math inline">\(f&#39;(x_i)\)</span>或者更高阶的导数值，那么此时的均差该如何计算呢？对于高阶项，如果有 <spanclass="math inline">\(x_0\le x_1\le \cdots \lex_n\)</span>，那么均差的计算方法为 <span class="math display">\[f[x_0,...,x_n] = \begin{cases}\frac{f[x_1,...,x_n] - f[x_0,...,x_{n-1}]}{x_n-x_0}, &amp; x_n\ne x_0 \\\frac{f^{(n)}(x_0)}{n!}, &amp; x_n=x_0\end{cases}\]</span>在解题过程中，主要还是用列表法，可以参考数值分析相关的教材。</p><h2 id="hermite插值">4. Hermite插值</h2><p>Hermite插值方法就是在Lagrange方法的基础上，再利用上插值节点的（高阶）导数值，用更少的插值节点获得更高阶的插值多项式。例如构造基函数<span class="math inline">\(\alpha_i,\beta_i\in {\mathcalP}_{2n+1},i=0,1,...,n\)</span> 满足 <span class="math display">\[\begin{cases}\alpha_i(x_j) = \delta_{ij}, &amp; \alpha&#39;_i(x_j)=0 \\\beta_i(x_j)=0, &amp; \beta&#39;_i(x_j) = \delta_{ij}\end{cases}\]</span> 构造的多项式即为 <span class="math display">\[H_{2n+1}(x) = \sum_{i=0}^n [f_i\alpha_i(x) + f&#39;(x_i)\beta_i(x)]\]</span> 具体细节略。</p><h2 id="样条插值">5. 样条插值</h2><p>前面的方法都会出现 Runge现象，也就是由于多项式本身的性质，插值函数阶数越高，边缘处振荡越严重，误差较大。样条插值的思路就是分段插值，并且只利用低阶多项式（如一阶、二阶、三阶）。其中一阶就是分段线性插值，用的比较多的还是三次样条插值。</p><p>三次样条插值的总体思路就是利用插值节点的函数值、一阶导、二阶导列出方程组来求解系数。不过为了使方程适定，需要再添加两个约束条件（增加两个方程），一般可选的有</p><ul><li>固支边界条件：<spanclass="math inline">\(S&#39;_3(x_0)=f&#39;(x_0),S&#39;_3(x_n)=f&#39;(x_n)\)</span>；</li><li>自然边界条件：<spanclass="math inline">\(S&#39;&#39;_3(x_0)=S&#39;&#39;_3(x_n)=0\)</span>；</li><li>周期边界条件：<span class="math inline">\(S_3(x_0)=S_3(x_n)=f_0,S&#39;_3(x_0)=S&#39;_3(x_n),S&#39;&#39;_3(x_0)=S&#39;&#39;_3(x_n)\)</span>。</li></ul><p>具体细节略。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;假设有离散的 &lt;span class=&quot;math inline&quot;&gt;\(\{x_0,x_1,...,x_n\}\)&lt;/span&gt;
插值节点，以及对应的函数值 &lt;span
class=&quot;math inline&quot;&gt;\(\{f(x_0),....,f(x_n)\}\)&lt;/span&gt;，希望用函数 &lt;span
class=&quot;math inline&quot;&gt;\(\phi(x)\)&lt;/span&gt; 来近似 &lt;span
class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;，使其满足插值条件 &lt;span
class=&quot;math inline&quot;&gt;\(\phi(x_i)=f(x_i),i=0,...,n\)&lt;/span&gt;。一般选择多项式插值函数
&lt;span class=&quot;math inline&quot;&gt;\(p(x)=a_0+a_1x+\cdots+a_n x^n \in {\mathcal
P}_n\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="插值" scheme="https://glooow1024.github.io/tags/%E6%8F%92%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】布朗运动1 | 定义与基本性质</title>
    <link href="https://glooow1024.github.io/2021/11/25/stochastic-process-2/ch5-s1-brown-concepts/"/>
    <id>https://glooow1024.github.io/2021/11/25/stochastic-process-2/ch5-s1-brown-concepts/</id>
    <published>2021-11-25T01:46:08.000Z</published>
    <updated>2021-11-25T01:55:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布朗运动概念">5.1 布朗运动概念</h2><p><strong>定义</strong>：若一个随机过程 <spanclass="math inline">\(\{X(t),t\ge0\}\)</span> 满足</p><ol type="1"><li><span class="math inline">\(X(t)\)</span> 是独立增量过程；</li><li><span class="math inline">\(\forall s,t\ge0, X(t+s)-X(s)\sim{\mathcal N}(0,c^2t)\)</span>；</li><li><span class="math inline">\(X(t)\)</span> 关于 <spanclass="math inline">\(t\)</span> 是连续函数；</li></ol><p>则称 <span class="math inline">\(X(t)\)</span>是布朗运动或维纳过程。</p><p>可以验证 <span class="math inline">\(R(t_1,t_2) = {\mathbbE}[X(t_1)X(t_2)]=c^2(t_1\wedget_2)\)</span>，所以布朗运动是<strong>非平稳过程</strong>。</p><span id="more"></span><h2 id="正态分布相关理论">5.2 正态分布相关理论</h2><h3 id="柯西分布与高斯随机变量">5.2.1 柯西分布与高斯随机变量</h3><p>问题 1：求 <span class="math inline">\(Z=X/Y\)</span>的概率分布与分布密度函数。</p><p><strong>定理 5.1</strong>：设 <spanclass="math inline">\(X_1,X_2\)</span> 是独立的均值为 <spanclass="math inline">\(0\)</span>，方差为 <spanclass="math inline">\(1\)</span> 的正态分布随机变量，则 <spanclass="math inline">\(X_1/|X_2|\)</span> 服从 Cauchy分布，分布密度函数为：<span class="math inline">\(f(x)=1/\pi(1+x^2),-\infty &lt; x &lt; \infty\)</span>，相应的概率分布函数为 <spanclass="math inline">\(F(x)=1/2 + \pi^{-1}\arctan x, -\infty &lt; x &lt;\infty\)</span>。</p><h3 id="区域分布与互相关系数的关系">5.2.2区域分布与互相关系数的关系</h3><p>定义 <span class="math inline">\(\sin \alpha = \frac{ {\mathbbE}[XY]}{\sqrt{ {\mathbb E}[X^2]{\mathbb E}[Y^2]} }=r\)</span>，那么<span class="math inline">\(P(X &gt; 0,Y &gt; 0) = P(X &lt; 0, Y &lt;0)=1/4 + \alpha / 2\pi\)</span>，<span class="math inline">\(P(X &lt;0,Y &gt; 0) = P(X &gt; 0, Y &lt; 0)=1/4 - \alpha / 2\pi\)</span>。</p><p>证明：略。</p><h3 id="贝叶斯定理与条件分布密度表示理论">5.2.3贝叶斯定理与条件分布密度表示理论</h3><p><strong>贝叶斯定理</strong>：<spanclass="math inline">\(f_Y(y|X=x)=\frac{f_X(x|Y=y)f_Y(y)}{f_X(x)}\)</span>。</p><p>该定理在讨论条件概率问题时，把需要利用分布函数讨论的问题转化为利用分布密度函数来讨论，简化了问题的讨论。</p><h3 id="联合正态分布的边缘分布密度与条件分布密度">5.2.4联合正态分布的边缘分布密度与条件分布密度</h3><p>略。</p><h3 id="几个基本关系式">5.2.5 几个基本关系式</h3><p>假设 <span class="math inline">\(X,Y\)</span> 服从均值为 0的联合正态分布，则 <span class="math inline">\({\mathbb E}[XY] =r\sigma_1\sigma_2\)</span>，<span class="math inline">\({\mathbbE}[X^2Y^2]={\mathbb E}[X^2]{\mathbb E}[Y^2] + 2{\mathbbE}^2[XY]\)</span>，<span class="math inline">\({\mathbb E}[|XY|] =\frac{2\sigma_1\sigma_2}{\pi}(\cos\alpha+\sin\alpha)\)</span>，其中<span class="math inline">\(r=\sin\alpha, -\pi/2 &lt; \alpha \le\pi/2\)</span>。</p><p>证明：略。</p><h3 id="反正弦率">5.2.6 反正弦率</h3><p>设 <span class="math inline">\(X(t)\)</span> 为平稳过程，且 <spanclass="math inline">\(X(t+\tau),X(t)\)</span> 的联合分布服从正态分布，对<span class="math inline">\(X(t)\)</span> 进行非线性运算 <spanclass="math display">\[Y(t) = \begin{cases} 1, &amp; X(t)\ge0 \\ -1, &amp; X(t) &lt; 0\end{cases}\]</span> 那么有 <span class="math inline">\({\mathbbE}[Y(t+\tau)Y(t)]=2\alpha / \pi\)</span>。随机变量 <spanclass="math inline">\(X(t+\tau),X(t)\)</span> 联合正态，那么 <spanclass="math inline">\(r=R(\tau)/R(0)=\sin\alpha\)</span>，于是有 <spanclass="math inline">\(R_Y(\tau)= \frac{2}{\pi}\arcsin{\frac{R(\tau)}{R(0)}}\)</span>。</p><h3 id="零交叉问题">5.2.7 零交叉问题</h3><p>略。</p><h3 id="正态分布拖尾概率估计">5.2.8 正态分布拖尾概率估计</h3><p><strong>定理 5.2（Mill比值）</strong>：对任意的 <spanclass="math inline">\(x &gt; 0\)</span> 有 <spanclass="math inline">\(\frac{x}{1+x^2} e^{-x^2/2} &lt; \int_x^\inftye^{-u^2/2}du &lt; \frac{1}{x} e^{-x^2/2}\)</span>。特别的，当 <spanclass="math inline">\(x\to\infty\)</span> 时有 <spanclass="math inline">\(\int_x^\infty e^{-u^2/2}du \approx \frac{1}{x}e^{-x^2/2}\)</span>。</p><h2 id="布朗运动">5.3 布朗运动</h2><h3 id="有限维联合概率密度">5.3.1 有限维联合概率密度</h3><p><strong>定理 5.3</strong>：设 <spanclass="math inline">\(\{B(t),t\ge0\}\)</span> 为标准的布朗运动，令 <spanclass="math inline">\(x_0=0,t_0=0\)</span>，则当 <spanclass="math inline">\(B(0)=0\)</span> 时，对 <spanclass="math inline">\(\forall 0 &lt; t_1 &lt; t_2 &lt; \cdots &lt;t_n\)</span>，<spanclass="math inline">\((B(t_1),B(t_2),...,B(t_n))\)</span>的联合概率密度函数为 <span class="math inline">\(g(x_1,x_2,...,x_n;t_1,t_2,...,t_n) = \Pi_{i=1}^n p(x_i-x_{i-1};t_i-t_{i-1})\)</span>，其中 <spanclass="math inline">\(p(x;t)=\frac{1}{\sqrt{2\pit}}\exp(-x^2/2t)\)</span>。</p><h3 id="布朗运动的性质">5.3.2 布朗运动的性质</h3><p>下面考虑标准布朗运动（即取 <spanclass="math inline">\(c=1\)</span>）的性质。</p><p><strong>平移特性</strong>：对任意的 <span class="math inline">\(s&gt; 0\)</span>，<spanclass="math inline">\(B_s(t)=B(t+s)-B(s),t\ge0\)</span>是标准布朗运动；</p><p><strong>伸缩性</strong>：对任意的 <span class="math inline">\(c &gt;0\)</span>，<span class="math inline">\(\{\sqrt{c} B(t/c),t\ge0\}\)</span> 是标准布朗运动；</p><p><strong>对称性</strong>：<spanclass="math inline">\(\{-B(t),t\ge0\}\)</span> 是标准布朗运动；</p><p><strong>鞅性</strong>：略。</p><p>其余还有正态过程性质、马尔可夫性质、反射性质、时间可逆性等在后面详细解释。</p><h3 id="正态过程">5.3.3 正态过程</h3><p><strong>定义</strong>：若随机过程 <spanclass="math inline">\(\{X(t),t\in T\}\)</span>，对任意 <spanclass="math inline">\(t_i\in T,i=1,2,...,n\)</span> 有 <spanclass="math inline">\(X(t_1),...,X(t_n)\)</span> 的联合分布为 <spanclass="math inline">\(n\)</span> 维正态分布，则称 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 为正态过程。</p><p><strong>定理 5.4</strong>：设 <span class="math inline">\(\{B(t),t\ge0\}\)</span> 是正态过程，轨道连续，<spanclass="math inline">\(B(0)=0,\forall s,t&gt;0\)</span>，有 <spanclass="math inline">\({\mathbb E}B(t)=0, {\mathbb E}[B(s)B(t)]=s\wedget\)</span>，则 <span class="math inline">\(\{B(t),t\ge0\}\)</span>是布朗运动，反之亦然。</p><p>证明：充分性易证。必要性证明，验证布朗运动有关条件：1）<spanclass="math inline">\(\forall t, s \ge0\)</span>，可以验证增量 <spanclass="math inline">\(B(t)-B(s) \sim {\mathcal N}(0,|t-s|)\)</span>是零均值正态随机变量；2）再验证独立增量过程，而验证两个高斯分布的独立性只需要证明他们的互相关为0，细节略。</p><h3 id="马尔可夫性">5.3.4 马尔可夫性</h3><p><strong>正向马尔可夫性</strong>：<span class="math inline">\(\forallt_1 &lt; t_2 &lt; \cdots &lt; t_n\)</span>，在给定 <spanclass="math inline">\(B(t_1),..,B(t_{n-1})\)</span> 下，<spanclass="math inline">\(B(t_n)\)</span> 的条件概率密度函数与只给定 <spanclass="math inline">\(B(t_{n-1})\)</span> 下 <spanclass="math inline">\(B(t_n)\)</span> 的条件概率密度相同。</p><p><strong>反向马尔可夫性</strong>：同理。</p><p><strong>中间关于两侧的马尔可夫性</strong>：<spanclass="math inline">\(\forall t_1 &lt; t_2 &lt; \cdots &lt;t_n\)</span>，在给定 <spanclass="math inline">\(...,B(t_{i-1}),B(t_{i+1}),...\)</span> 下，<spanclass="math inline">\(B(t_i)\)</span> 的条件概率密度函数与只给定 <spanclass="math inline">\(B(t_{i-1}), B(t_{i+1})\)</span> 下 <spanclass="math inline">\(B(t_i)\)</span> 的条件概率密度相同。</p><p>下面讨论 <span class="math inline">\(B(t_2)\)</span> 关于给定 <spanclass="math inline">\(B(t_1),B(t_3)\)</span> 的条件概率密度。</p><p><strong>定理5.5</strong>：对 <span class="math inline">\(0\le t_1&lt; t &lt;t_2\)</span>，给定 <span class="math inline">\(B(t_1)=a,B(t_2)=b, B(0)=0\)</span>，则 <span class="math inline">\(B(t)\)</span>的条件概率密度是一个正态密度，其均值为 <span class="math inline">\(a +(b-a)(t-t_1)/(t_2-t_1)\)</span>，方差为 <spanclass="math inline">\((t_2-t)(t-t_1) / (t_2-t_1)\)</span></p><p>证明：由于 <span class="math inline">\(B(t)\)</span>为正态过程，<spanclass="math inline">\(\boldsymbol{b}=B(t_1),B(t),B(t_2)\)</span>服从联合高斯分布，其均值为 <span class="math inline">\({\boldsymbol\mu}=[0,0,0]^{\mathrm T}\)</span>，协方差矩阵 <spanclass="math display">\[\Sigma = {\mathbb E}[{\boldsymbol b}{\boldsymbol b}^{\mathrm T}] =\begin{bmatrix} t_1 &amp; t_1 &amp; t_1 \\ t_1 &amp; t &amp; t \\ t_1&amp; t &amp; t_2 \end{bmatrix}\]</span> 直接根据高斯分布向量的条件分布即可得到。</p><p><strong>Remark</strong>：实际上 <span class="math inline">\({\mathbbE}[B(t) | B(t_1),B(t_2)]\)</span> 是关于 <spanclass="math inline">\(t\)</span> 的线性函数。</p><p><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/brown_conditional.png" /></p><h3 id="反射性">5.3.5 反射性</h3><p><strong>反射性</strong>：对 <span class="math inline">\(a &gt;0\)</span>，定义 <span class="math inline">\(\tau_a=\inf\{t:B(t)=a\}\)</span> 表示首次击中时间，定义 <spanclass="math inline">\(B^{\ast}(t)=\begin{cases} B(t), &amp; t \le \tau_a\\ 2a-B(t), &amp; t &gt; \tau_a \end{cases}\)</span>，则 <spanclass="math inline">\(\{B^\ast(t),t\ge0\}\)</span> 是标准布朗运动；</p><p>证明：略。</p><h3 id="时间可逆性">5.3.6 时间可逆性</h3><p><strong>时间可逆性</strong>：定义 <spanclass="math inline">\(B&#39;(t)=\begin{cases} tB(1/t), &amp; t &gt; 0 \\0, &amp; t=0 \end{cases}\)</span>，则 <spanclass="math inline">\(\{B&#39;(t),t\ge0\}\)</span> 是标准布朗运动；</p><p>证明：<span class="math inline">\(B(t)\)</span>是正态过程，根据前面正态过程的定义，可以得到 <spanclass="math inline">\(tB(1/t)\)</span> 也是正态过程。再根据定理 5.4可以验证条件 <span class="math inline">\({\mathbbE}[B&#39;(t)B&#39;(s)]=s\wedge t\)</span>，关于在 <spanclass="math inline">\(t=0\)</span> 点的连续性稍复杂，省略。由此可以证明<span class="math inline">\(B&#39;(t)\)</span> 是布朗运动。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;布朗运动概念&quot;&gt;5.1 布朗运动概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：若一个随机过程 &lt;span
class=&quot;math inline&quot;&gt;\(\{X(t),t\ge0\}\)&lt;/span&gt; 满足&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(X(t)\)&lt;/span&gt; 是独立增量过程；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\forall s,t\ge0, X(t+s)-X(s)\sim
{\mathcal N}(0,c^2t)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(X(t)\)&lt;/span&gt; 关于 &lt;span
class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 是连续函数；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;则称 &lt;span class=&quot;math inline&quot;&gt;\(X(t)\)&lt;/span&gt;
是布朗运动或维纳过程。&lt;/p&gt;
&lt;p&gt;可以验证 &lt;span class=&quot;math inline&quot;&gt;\(R(t_1,t_2) = {\mathbb
E}[X(t_1)X(t_2)]=c^2(t_1\wedge
t_2)\)&lt;/span&gt;，所以布朗运动是&lt;strong&gt;非平稳过程&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="布朗运动" scheme="https://glooow1024.github.io/tags/%E5%B8%83%E6%9C%97%E8%BF%90%E5%8A%A8/"/>
    
    <category term="高斯过程" scheme="https://glooow1024.github.io/tags/%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B/"/>
    
    <category term="维纳过程" scheme="https://glooow1024.github.io/tags/%E7%BB%B4%E7%BA%B3%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>洋葱</title>
    <link href="https://glooow1024.github.io/2021/11/17/music/Onion/"/>
    <id>https://glooow1024.github.io/2021/11/17/music/Onion/</id>
    <published>2021-11-17T07:04:17.000Z</published>
    <updated>2021-11-17T07:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<center><h2>洋葱🧅</h1></center><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=176053&amp;auto=1&amp;height=66"></iframe><blockquote><p>如果你眼神能够为我 片刻的降临 如果你能听到 心碎的声音 沉默的守护着你沉默的等奇迹 沉默的让自己 像是空气</p><p>大家都吃着聊着笑着 今晚多开心 最角落里的我 笑得多合群 盘底的洋葱像我永远是调味品 偷偷的看着你 偷偷的隐藏着自己</p><p>如果你愿意一层一层 一层地剥开我的心 你会发现 你会讶异 你是我 最压抑最深处的秘密 如果你愿意一层一层 一层地剥开我的心 你会鼻酸 你会流泪只要你能 听到我 看到我的全心全意</p><p>听你说你和你的他们 暧昧的空气 我和我的绝望 装得很风趣 我就像一颗洋葱永远是配角戏 多希望能与你 有一秒专属的剧情</p><p>如果你愿意一层一层 一层地剥开我的心 你会发现 你会讶异 你是我 最压抑最深处的秘密 如果你愿意一层一层 一层地剥开我的心 你会鼻酸 你会流泪只要你能 听到我 看到我的全心全意</p><p>如果你愿意一层一层 一层地剥开我的心 你会发现 你会讶异 你是我 最压抑最深处的秘密 如果你愿意一层一层 一层地剥开我的心 你会鼻酸 你会流泪只要你能 听到我 看到我的全心全意 你会鼻酸 你会流泪 只要你能 听到我看到我的全心全意</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h2&gt;
洋葱🧅
&lt;/h1&gt;
&lt;/center&gt;</summary>
    
    
    
    <category term="Music" scheme="https://glooow1024.github.io/categories/Music/"/>
    
    
  </entry>
  
  <entry>
    <title>【随机过程2】泊松过程2 | 泊松过程扩展</title>
    <link href="https://glooow1024.github.io/2021/11/09/stochastic-process-2/ch4-s2-possion-extend/"/>
    <id>https://glooow1024.github.io/2021/11/09/stochastic-process-2/ch4-s2-possion-extend/</id>
    <published>2021-11-09T02:03:08.000Z</published>
    <updated>2021-11-09T02:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非时齐次泊松过程">4.5 非时齐次泊松过程</h2><p><strong>定义</strong>：一个计数过程若满足：</p><ol type="1"><li><span class="math inline">\(N(0)=0\)</span>；</li><li>它是独立增量过程；</li><li>对充分小的 <span class="math inline">\(\Delta t&gt;0\)</span>，有<span class="math inline">\(P(N(t+\Delta t)-N(t)=1) = \lambda(t) \Deltat + o(\Delta t)\)</span>，<span class="math inline">\(P(N(t+\Deltat)-N(t)\ge 2)=o(\Delta t)\)</span>；</li></ol><p>则称它为具有强度函数 <spanclass="math inline">\(\{\lambda(t),t\ge0\}\)</span>的非时齐次泊松过程。</p><p><strong>定理 4.7</strong>：若 <spanclass="math inline">\(N(t),t\ge0\)</span> 是非时齐次泊松过程，令 <spanclass="math inline">\(m(t)=\int_0^t \lambda (s)ds\)</span>，则对 <spanclass="math inline">\(\forall s,t\ge0\)</span>，有 <spanclass="math display">\[P(N(t+s)-N(s)=n) = \frac{(m(s+t)-m(s))^n}{n!}\exp(-(m(s+t)-m(s))), ~n\ge0\]</span> 上述定理最主要特点在于 <span class="math inline">\({\mathbbE}[N(t+s)-N(s)] = m(s+t)-m(s) = \int_s^{s+t} \lambda(s)ds\)</span>，相应的方差为 <spanclass="math inline">\(D_{[N(s+t)-N(s)]}=m(s+t)-m(s)\)</span>。</p><h2 id="复合泊松过程">4.6 复合泊松过程</h2><h3 id="定义">4.6.1 定义</h3><p><strong>定义</strong>：设 <spanclass="math inline">\(\{Y_i,i\ge1\}\)</span>是独立同分布的随机变量序列，<spanclass="math inline">\(\{N(t),t\ge0\}\)</span> 为泊松过程，且与 <spanclass="math inline">\(\{Y_i,i\ge1\}\)</span> 独立，记 <spanclass="math inline">\(X(t)=\sum_{i=1}^{N(t)} Y_i\)</span>称为复合泊松过程。</p><p>为求 <span class="math inline">\(X(t)\)</span> 的矩，先求它的矩母函数<span class="math display">\[\begin{aligned}\phi_t(u) &amp;= {\mathbb E}[\exp(u X(t))] \\&amp;= \sum_{n=0}^\infty P(N(t)=n){\mathbb E}[\exp(uX(t)) | N(t)=n] \\&amp;= \exp(\lambda t(\phi_Y(u)-1))\end{aligned}\]</span> 其中 <span class="math inline">\(\phi_Y(u)={\mathbbE}[\exp(uY)]\)</span> 为 <span class="math inline">\(Y\)</span>的矩母函数。上式在 <span class="math inline">\(u=0\)</span> 处求导得到<span class="math inline">\({\mathbb E}[X(t)] = \phi_t&#39;(0) = \lambdat {\mathbb E}Y\)</span>，<span class="math inline">\({D}[X(t)] =\phi_t&#39;&#39;(0)-(\phi_t&#39;(0))^2 = \lambda t{\mathbbE}Y^2\)</span>。若 <span class="math inline">\(Y_i\)</span>取正整数的随机变量，则称 <spanclass="math inline">\(\{X(t),t\ge0\}\)</span> 为平稳无后效流。</p><h3 id="复合泊松恒等式">4.6.2 复合泊松恒等式</h3><p><strong>定理 4.8</strong>：设 <spanclass="math inline">\(Y=\sum_{i=1}^N X_i\)</span>是复合泊松随机变量，其中随机变量 <span class="math inline">\(N\)</span>服从均值为 <span class="math inline">\(\lambda\)</span>的泊松分布，随机变量序列 <spanclass="math inline">\(\{X_k,k=1,2,...\}\)</span> 是独立同分布的，且与<span class="math inline">\(N\)</span> 统计独立。设 <spanclass="math inline">\(X_k,(k=1,2,...)\)</span> 的分布函数为 <spanclass="math inline">\(F(x)\)</span>，则对任意的有界函数 <spanclass="math inline">\(h(x)\)</span> 有 <spanclass="math inline">\({\mathbb E}[Y h(Y)] = \lambda {\mathbb E}[Xh(Y+X)]\)</span>，其中随机变量 <span class="math inline">\(X\)</span> 与<span class="math inline">\(N\)</span> 统计独立，它的分布函数也为 <spanclass="math inline">\(F(x)\)</span>。</p><p>证明：略。</p><p><strong>推论 4.8.1</strong>：对任何正整数 <spanclass="math inline">\(n\)</span> 有 <span class="math inline">\({\mathbbE}[Y^n] = \lambda \sum_{k=0}^{n-1} \tbinom{n-1}{k} {\mathbbE}[Y^k]{\mathbb E}[X^{n-k}]\)</span>。</p><p>证明：令 <span class="math inline">\(h(x)=x^{n-1}\)</span>即可得证。</p><p>利用此推论可以得到： <span class="math display">\[\begin{aligned}{\mathbb E}Y &amp;= \lambda{\mathbb E}X \\{\mathbb E}Y^2 &amp;= \lambda{\mathbb E}X^2 + \lambda^2({\mathbb E}X)^2\\{\mathbb E}[Y-{\mathbb E}Y]^2 &amp;= \lambda{\mathbb E}X^2 \\{\mathbb E}[Y-{\mathbb E}Y]^3 &amp;= \lambda{\mathbb E}X^3\end{aligned}\]</span></p><h2 id="条件泊松过程">4.7 条件泊松过程</h2><p><strong>定义</strong>：设 <spanclass="math inline">\(\Lambda\)</span> 是一个正的随机变量，分布函数为<span class="math inline">\(G(x),x\ge0\)</span>，设 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span> 是一个计数过程，且给定<span class="math inline">\(\Lambda=\lambda\)</span> 的条件下，<spanclass="math inline">\(\{N(t),t\ge0\}\)</span> 是一个泊松过程，即 <spanclass="math inline">\(\forall s,t\ge0,n\in\mathbb{N},\lambda\ge0\)</span>，有 <span class="math display">\[P(N(s+t)-N(s)=n | \Lambda=\lambda) = \frac{(\lambda t)^n}{n!}e^{-\lambda t}\]</span> 则 <span class="math inline">\(\{N(t),t\ge0\}\)</span>是条件泊松过程。</p><p><strong>Remark</strong>：这里 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span>本身并不是独立增量过程，由全概率公式得到 <span class="math display">\[P(N(s+t)-N(s)=n) = \int_0^{\infty} \frac{(\lambda t)^n}{n!} e^{-\lambdat} dG(\lambda)\]</span> <strong>定理 4.9</strong>：设 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span> 是上述条件泊松过程，则</p><ol type="1"><li><span class="math inline">\({\mathbb E}[N(s+t)-N(t)] = s{\mathbbE}\Lambda\)</span></li><li><span class="math inline">\(D[N(s+t)-N(t)] = s{\mathbb E}\Lambda +s^2 D\Lambda\)</span></li></ol><p>证明：略。</p><h2 id="更新过程">4.8 更新过程</h2><h3 id="更新过程的定义">4.8.1 更新过程的定义</h3><p><strong>定义</strong>：设 <spanclass="math inline">\(\{X_k,k\ge1\}\)</span>独立同分布的非负随机变量，分布函数为 <spanclass="math inline">\(F(x)\)</span>，且 <spanclass="math inline">\(F(0)&lt;1\)</span>。令 <spanclass="math inline">\(S_0=0, S_n=\sum_{k=1}^n X_k\)</span>，对 <spanclass="math inline">\(\forall t\ge0\)</span>，记 <spanclass="math inline">\(N(t)=\sup\{n:S_n\le t\}\)</span> 或者 <spanclass="math inline">\(N(t)=\sum_{n=1}^\infty I_{\{S_n\let\}}\)</span>，称 <span class="math inline">\(\{N(t),t\ge0\}\)</span>为更新过程。</p><p>记 <span class="math inline">\(F_n(x)\)</span> 为 <spanclass="math inline">\(S_n\)</span> 的分布函数，易知 <spanclass="math inline">\(F_1(x)=F(x)\)</span>，<spanclass="math inline">\(F_n(x)=\int_0^xF_{n-1}(x-u)dF(u),(n\ge2)\)</span>，即 <spanclass="math inline">\(F_n(x)\)</span> 是 <spanclass="math inline">\(F(x)\)</span> 的 <spanclass="math inline">\(n\)</span> 重卷积。记 <spanclass="math inline">\(m(t)={\mathbb E}[N(t)]\)</span>，称 <spanclass="math inline">\(m(t)\)</span> 为更新函数。</p><p>类似的，分布密度函数同样是卷积的形式 <spanclass="math inline">\(f_n(x) = \int_0^xf_{n-1}(x-u)f(u)du\)</span>。</p><p><strong>定理 4.10</strong>：<span class="math inline">\(\forallt\ge0\)</span> 有 <span class="math inline">\(m(t)=\sum_{n=1}^\inftyF_n(t)\)</span>。</p><p>证明：<span class="math inline">\(m(t)=\sum_n nP(N(t)=n) = \sum_nP(N(t)\ge n) = \sum_n P(S_n\le t) = \sum_n F_n(t)\)</span>.</p><p><em>栗子 4.3</em>：<span class="math inline">\(F(x)\)</span>是指数分布函数，相应的概率密度函数为 <spanclass="math inline">\(f(x)=\lambda e^{-\lambda x},x\ge0,\lambda &gt;0\)</span>，那么由此可以计算 <spanclass="math inline">\(f_n(x)=\frac{\lambda (\lambda x)^{n-1}}{(n-1)!}e^{-\lambda x}\)</span>，然后计算得到 <span class="math inline">\(m(t) =\lambda t\)</span>，这与之前泊松过程的结论是一致的。</p><p><em>栗子 4.4</em>：设 <span class="math inline">\(F(x)\)</span> 是Gamma 分布函数，相应的额概率密度函数为 <spanclass="math inline">\(f(x)=xe^{-x}\)</span>，其 <strong>Laplace变换</strong>为 <span class="math inline">\(\hat{f}(s) =1/(1+s)^2\)</span>，利用 Laplace 变换的性质知道 <spanclass="math inline">\(\hat{f_n}(s)=1/(1+s)^{2n}\)</span>，反变换即可得到<span class="math inline">\(f_n(x)\)</span>，然后再根据定理 4.10计算得到<span class="math inline">\(m(t)=-\frac{1}{4} + \frac{t}{2} +\frac{e^{-2t}}{4}\)</span>。</p><h3 id="更新过程的剩余寿命与年龄">4.8.2 更新过程的剩余寿命与年龄</h3><p>设 <span class="math inline">\(N(t)\)</span> 表示 <spanclass="math inline">\([0,t]\)</span> 上事件发生的个数，<spanclass="math inline">\(S_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个事件发生的时刻，那么 <spanclass="math inline">\(S_{N(t)}\)</span> 表示在 <spanclass="math inline">\(t\)</span> 之前最后一个事件发生的时刻，<spanclass="math inline">\(S_{N(t)+1}\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻后首次事件发生的时刻。令 <spanclass="math inline">\(W(t)=S_{N(t)+1}-t, V(t)=t-S_{N(t)}\)</span>，则<span class="math inline">\(W(t)\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻后直到首次事件发生的剩余时间。</p><p><strong>定理 4.11</strong>：若非负随机变量 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span> 独立同分布，分布函数为<span class="math inline">\(F(x)\)</span>，则对 <spanclass="math inline">\(\forall x,t\ge0\)</span>，有</p><ol type="1"><li><span class="math inline">\(P(W(t) &gt; x)=1 - F(x+t) + \int_0^tP(W(t-u) &gt; x) dF(u)\)</span></li><li><span class="math inline">\(P(V(t) \le x) = (1-F(t)) I_{[0,x]}(t) +\int_0^t P(V(t-y) \le x) dF(y)\)</span></li></ol><p>证明：略。</p><p><strong>定理 4.12</strong>：设 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span> 是参数为 <spanclass="math inline">\(\lambda\)</span> 的泊松过程，则</p><ol type="1"><li><span class="math inline">\(W(t)\)</span> 与 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span> 同分布，即 <spanclass="math inline">\(P(W(t)\le x)=1-\exp(-\lambdax),x\ge0\)</span></li><li><span class="math inline">\(V(t)\)</span> 是截尾的指数分布，即 <spanclass="math inline">\(P(V(t)\le x)=\begin{cases} 1-\exp(-\lambda x)&amp; 0\le x &lt; t \\ 1 &amp; x\ge t \end{cases}\)</span></li></ol><p>证明：略。</p><h2 id="瓦尔德等式">4.10 瓦尔德等式</h2><p><strong>定义</strong>：设 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span> 为随机序列，<spanclass="math inline">\(T\)</span> 为非负整数随机变量，若对任一 <spanclass="math inline">\(n\in{\mathbb N}\)</span> 事件 <spanclass="math inline">\(\{T=n\}\)</span> 仅依赖于 <spanclass="math inline">\(\{X_1,...,X_n\}\)</span>，而与 <spanclass="math inline">\(X_{n+1},X_{n+2},...\)</span> 独立，则称 <spanclass="math inline">\(T\)</span> 关于 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span>是<strong>停时</strong>，或称马尔可夫时。</p><p><strong>定理 4.13（Wald）</strong>：设 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span> 独立同分布，<spanclass="math inline">\(\mu={\mathbb E}X_n &lt; \infty\)</span>，<spanclass="math inline">\(X_n\)</span> 与 <spanclass="math inline">\(X\)</span> 同分布，<spanclass="math inline">\(\tau\)</span> 关于 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span> 是停时，且 <spanclass="math inline">\({\mathbb E}\tau &lt; \infty\)</span>，则 <spanclass="math inline">\({\mathbb E}[\sum_{n=1}^\tau X_n] = {\mathbb E}X{\mathbb E}\tau\)</span></p><p>证明：略。</p><h2 id="泊松过程与鞅">4.11 泊松过程与鞅</h2><p>线性方法构造的鞅，<span class="math inline">\(Y(t)=N(t)-\lambda t,U(t)=Y^2(t)-\lambda t\)</span></p><p>基于特征函数构造的鞅 <span class="math inline">\(V(t)=\exp(-\thetaN(t) + \lambda t(1-e^{-\theta}))\)</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;非时齐次泊松过程&quot;&gt;4.5 非时齐次泊松过程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：一个计数过程若满足：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(N(0)=0\)&lt;/span&gt;；&lt;</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="泊松过程" scheme="https://glooow1024.github.io/tags/%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B/"/>
    
    <category term="更新过程" scheme="https://glooow1024.github.io/tags/%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/"/>
    
    <category term="Wald等式" scheme="https://glooow1024.github.io/tags/Wald%E7%AD%89%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】泊松过程1 | 定义与基本性质</title>
    <link href="https://glooow1024.github.io/2021/11/02/stochastic-process-2/ch4-s1-possion-concepts/"/>
    <id>https://glooow1024.github.io/2021/11/02/stochastic-process-2/ch4-s1-possion-concepts/</id>
    <published>2021-11-02T00:49:28.000Z</published>
    <updated>2021-11-02T00:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泊松过程的定义与基本性质">4.1 泊松过程的定义与基本性质</h2><p><strong>定义 4.1</strong>：随机过程 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span>称为时齐泊松过程，若满足下列条件：</p><ol type="1"><li>他是一个计数过程，且 <spanclass="math inline">\(N(0)=0\)</span>；</li><li>（独立增量）任取 <span class="math inline">\(0 &lt; t_1 &lt; t_2&lt; \cdots &lt; t_n\)</span>，<spanclass="math inline">\(N(t_1),N(t_2)-N(t_1),...,N(t_n)-N(t_{n-1})\)</span>相互独立；</li><li>（平稳增量）<span class="math inline">\(\foralls,t\ge0,n\ge0\)</span>，<span class="math inline">\(P(N(s+t)-N(s)=n) =P(N(t)=n)\)</span>；</li><li>对任意 <span class="math inline">\(t&gt;0\)</span> 和充分小的 <spanclass="math inline">\(\Delta t&gt;0\)</span>，有 <spanclass="math inline">\(P(N(t+\Delta t)-N(t)=1) = \lambda \Delta t +o(\Delta t)\)</span>，<span class="math inline">\(P(N(t+\Deltat)-N(t)\ge 2)=o(\Delta t)\)</span>；</li></ol><p>其中 <span class="math inline">\(\lambda&gt;0\)</span>称为强度常数，<span class="math inline">\(o(\Delta t)\)</span>为高阶无穷小。</p><span id="more"></span><p><strong>定义 4.2</strong>：计数过程 <spanclass="math inline">\(\{N(t),t\ge0\}\)</span>，被称为参数为 <spanclass="math inline">\(\lambda\)</span>的时齐泊松过程，若满足如下条件：</p><ol type="1"><li><span class="math inline">\(N(0)=0\)</span>；</li><li>它是独立增量过程；</li><li><span class="math inline">\(\forall s,t\ge0,N(s+t)-N(s)\)</span>是参数为 <span class="math inline">\(\lambda t\)</span> 的泊松分布，即<span class="math inline">\(P(N(t+s)-N(s)=k) = \frac{(\lambda t)^k}{k!}e^{-\lambda t}\)</span>。</li></ol><blockquote><p>两种定义是等价的。</p></blockquote><p>基本性质：</p><ol type="1"><li>均值 <span class="math inline">\({\mathbb E}[N(t)] = \lambdat\)</span>；</li><li>方差 <span class="math inline">\(\text{var}(N(t)) = {\mathbbE}[(N(t)-\lambda t)^2] = \lambda t\)</span>；</li><li>特征函数 <span class="math inline">\(\phi_{N(t)}(x) = {\mathbbE}[\exp(-j N(t)x)] = \exp(-\lambda t e^{jx})\)</span>；</li><li><span class="math inline">\({\mathbb E}[N(t)^2] = (\lambda t)^2 +\lambda t\)</span>；</li><li>自相关函数 <span class="math inline">\(R(t+\tau,t) = {\mathbbE}[N(t+\tau)N(t)] = (\lambda t)^2 + \lambda t + \lambda^2t\tau,(\tau&gt;0)\)</span>（非平稳过程）</li></ol><p><em>栗子 4.1</em>：<span class="math inline">\(\{N(t),t\ge0\}\)</span> 是参数为 <span class="math inline">\(\lambda\)</span>的时齐泊松过程，<span class="math inline">\(S_0=0,S_n\)</span> 为第<span class="math inline">\(n\)</span> 个事件发生的时刻，则 <spanclass="math inline">\(N(t)\)</span> 关于 <spanclass="math inline">\(\{S_n,n\ge0\}\)</span> 不是停时，但是 <spanclass="math inline">\(N(t)+1\)</span> 关于 <spanclass="math inline">\(\{S_n,n\ge0\}\)</span> 是停时。</p><p>证明：<span class="math inline">\(\{N(t)=n\} \iff \{S_n\le t &lt;S_{n+1} \}=\{S_n\le t \} - \{S_{n+1}\le t \}\)</span>，因此 <spanclass="math inline">\(\{N(t)=n\}\)</span> 可以由 <spanclass="math inline">\(\{S_0,...,S_{n+1} \}\)</span> 构成的事件表示，因此<span class="math inline">\(N(t)+1\)</span> 关于 <spanclass="math inline">\(\{S_n,n\ge0\}\)</span> 是停时。</p><h2 id="泊松过程与指数分布的关系">4.2 泊松过程与指数分布的关系</h2><p><span class="math inline">\(N(t),t\ge0\)</span> 是计数过程，令 <spanclass="math inline">\(S_0=0,S_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个事件发生的时刻，<spanclass="math inline">\(X_n=S_n-S_{n-1}\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个与第 <spanclass="math inline">\(n-1\)</span> 个事件之间的间隔，于是有 <spanclass="math inline">\(S_n=\inf\{t:N(t)=n \},n\ge1\)</span>。相应的 <spanclass="math inline">\(N(t)\)</span> 可以表示为 <spanclass="math inline">\(N(t)=\sum_{n=1}^{\infty}I_{[0,t]}(S_n)\)</span>。</p><p><span class="math inline">\(P(S_n \le t) = P(N(t)\ge n) =1-e^{-\lambda t} \sum_{k=0}^{n-1} \frac{(\lambdat)^k}{k!}\)</span>，特别当 <span class="math inline">\(n=1\)</span>时，有 <span class="math inline">\(P(S_1\le t) = P(X_1\le t) =1-e^{-\lambda t}\)</span>，即 <span class="math inline">\(X_1\simE(\lambda)\)</span> 是参数为 <spanclass="math inline">\(\lambda\)</span> 的指数分布。同样的可以得到 <spanclass="math inline">\(X_n(n\ge2)\)</span> 也服从指数分布，均值为 <spanclass="math inline">\(1/\lambda\)</span>，方差为 <spanclass="math inline">\(1/\lambda^2\)</span>。</p><p><strong>定理4.1</strong>：计数过程是泊松过程的<strong>充要条件</strong>是 <spanclass="math inline">\(\{X_n,n\ge1\}\)</span>是独立的同<strong>指数分布</strong>。</p><p>证明：略。</p><h2 id="到达时间的条件分布">4.3 到达时间的条件分布</h2><h3 id="到达时间的条件分布-1">4.3.1 到达时间的条件分布</h3><p><strong>定理 4.2</strong>：设 <spanclass="math inline">\(N(t),t\ge0\)</span> 是泊松过程，则对 <spanclass="math inline">\(\forall 0&lt; s &lt; t\)</span> 有 <spanclass="math inline">\(P(X_1\le s | N(t)=1) = s/t\)</span>。</p><p>证明：<span class="math inline">\(P(X_1\le s | N(t)=1) = P(X_1\le s,N(t)=1) / P(N(t)=1) = P(N(s)=1, N(t)-N(s)=0) / P(N(t)=1)\)</span>。</p><p><strong>定理 4.3</strong>：设 <spanclass="math inline">\(N(t),t\ge0\)</span> 是泊松过程，则对 <spanclass="math inline">\(\forall 0&lt; s &lt; t,k\le n\)</span> 有 <spanclass="math inline">\(P(S_k \le s | N(t)=n) = \sum_{l=k}^n\frac{n!}{l!(n-l)!}(\frac{s}{t})^l(1-\frac{s}{t})^{n-l}\)</span>。特别当 <spanclass="math inline">\(k=n\)</span> 时，有 <spanclass="math inline">\(P(S_n\le s | N(t)=n) =(\frac{s}{t})^n\)</span>。</p><p>证明：略。</p><h3 id="顺序统计量">4.3.2 顺序统计量</h3><p><span class="math inline">\(Y_1,...,Y_n\)</span> 是 <spanclass="math inline">\(n\)</span> 个随机变量，如果 <spanclass="math inline">\(Y_{(k)}\)</span> 是 <spanclass="math inline">\(Y_1,...,Y_n\)</span> 中第 <spanclass="math inline">\(k\)</span> 个最小的随机变量，我们称 <spanclass="math inline">\(Y_{(1)},...,Y_{(n)}\)</span> 是关于 <spanclass="math inline">\(Y_1,...,Y_n\)</span> 的顺序统计量。如果 <spanclass="math inline">\(Y_1,...,Y_n\)</span>是独立同分布的连续随机变量，其概率密度分布为 <spanclass="math inline">\(f(y)\)</span>，则 <spanclass="math inline">\(Y_{(1)},...,Y_{(n)}\)</span>的联合分布概率密度函数为 <span class="math display">\[f(y_1,...,y_n) = n! \Pi_{k=1}^n f(y_k), ~ y_1 &lt; y_2 &lt; \cdots &lt;y_n\]</span> 特别的，当 <span class="math inline">\(Y_1,...,Y_n\)</span> 为<span class="math inline">\((0,t)\)</span>上独立的均匀分布随机变量时，相应的顺序统计量 <spanclass="math inline">\(Y_{(1)},...,Y_{(n)}\)</span>的联合分布概率密度函数为 <span class="math display">\[f(y_1,...,y_n) = n! / t^n, ~ 0&lt; y_1 &lt; y_2 &lt; \cdots &lt; y_n&lt; t\]</span> <strong>定理 4.4</strong>：设 <spanclass="math inline">\(N(t),t\ge0\)</span> 为泊松过程，则在已给 <spanclass="math inline">\(N(t)=n\)</span> 时事件相继发生的时间 <spanclass="math inline">\(S_1,...,S_n\)</span> 的条件概率密度为 <spanclass="math display">\[f(t_1,t_2,...,t_n) = \begin{cases}n!/t^n, &amp; 0&lt; t_1 &lt; t_2 &lt;\cdots &lt; t_n \\ 0, &amp; others \end{cases}\]</span> 证明：对任取的 <span class="math inline">\(0=t_0 &lt; t_1 &lt;t_2 &lt; \cdots &lt; t_n &lt; t_{n+1}=t\)</span>，取 <spanclass="math inline">\(h_0=h_{n+1}=0\)</span> 及充分小的 <spanclass="math inline">\(h_i\)</span>，则 <span class="math display">\[\begin{aligned}&amp;P(t_i &lt; S_i \le t_i+h_i, 1\le i\le n | N(t)=n) \\=&amp; \frac{P(N(t_i+h_i)-N(t_i)=1,1\le i\le n, ~N(t_{j+1})-N(t_j+h_j)=0, 1\le j\le n)}{P(N(t)=n)} \\=&amp; \frac{n!}{t^n} h_1 h_2 \cdots h_n\end{aligned}\]</span> 取极限即可得证。</p><blockquote><p><strong>Remark</strong>：上述定理表明，若非负函数 <spanclass="math inline">\(g(x_1,...,x_n)\)</span> 是关于 <spanclass="math inline">\(x_i, i=1,...,n\)</span>的对称函数，即对任意一种排列模式 <spanclass="math inline">\(\phi\)</span>，有 <spanclass="math inline">\(g(x_1,...,x_n) = g(x_{\phi(1)}, x_{\phi(2)},...,x_{\phi(n)})\)</span>（也就是函数值与各分量的顺序无关），则在概率分布的意义上下列等式成立<span class="math display">\[g(S_1,...,S_n|N(t)=n) \overset{d}{=} g(Y_{(1)},...,Y_{(n)}) =g(Y_1,...,Y_n)\]</span> 其中 <span class="math inline">\(Y_1,...,Y_n\)</span> 为 <spanclass="math inline">\((0,t)\)</span> 上独立的均匀分布随机变量。</p></blockquote><p><em>栗子 4.2</em>：设某工地有一工程任务，工人到达工地遵照参数为 <spanclass="math inline">\(\lambda\)</span> 的泊松流，求在时刻 <spanclass="math inline">\(t\)</span> 工人完成的总的工程量的期望值。</p><p>解：设第 <span class="math inline">\(i\)</span>个工人到达工地的时刻为 <span class="math inline">\(S_i\)</span>，在<span class="math inline">\([0,t]\)</span> 内工人完成的总工程量为 <spanclass="math inline">\(S(t)=\sum_{i=1}^{N(t)}(t-S_i)\)</span>。有 <spanclass="math inline">\({\mathbb E}[S(t) | N(t)=n] = nt - {\mathbbE}[\sum_{i=1}^n S_i | N(t)=n]=nt - {\mathbb E}[\sum_{j=1}^n Y_j |N(t)=n]=nt/2\)</span>，于是 <span class="math inline">\({\mathbbE}[S(t)] = {\mathbb E}[{\mathbb E}[S(t) | N(t)=n]] = \lambdat^2/2\)</span>.</p><p><strong>定理 4.5</strong>：设 <spanclass="math inline">\(N(t),t\ge0\)</span> 是参数为 <spanclass="math inline">\(\lambda\)</span> 的泊松过程，<spanclass="math inline">\(S_k,k\ge1\)</span> 为到达时刻，则对任意的 <spanclass="math inline">\([0,+\infty)\)</span> 上可积函数 <spanclass="math inline">\(f\)</span> 有 <span class="math inline">\({\mathbbE}[\sum_{n=1}^{\infty} f(S_n)] = \lambda\int_0^\inftyf(s)ds\)</span>.</p><p>证明：当 <span class="math inline">\(t\ge0\)</span> 时，有 <spanclass="math inline">\(\{S_n\le t\}=\{N(t)\ge n\}\)</span>，因此有 <spanclass="math inline">\(P(S_n\le t)=P(N(t)\ge n) = \sum_{j=n}^\infty\frac{(\lambda t)^j}{j!} e^{-\lambda t}\)</span>，求导得到 <spanclass="math inline">\(S_n\)</span> 的概率密度为 <spanclass="math inline">\(f_{S_n}(t)=\lambda \frac{(\lambdat)^{n-1}}{(n-1)!} e^{-\lambda t}I_{\{t\ge0\}}\)</span>，因此 <spanclass="math inline">\({\mathbb E}[f(S_n)] = \lambda \int_0^\inftyf(s)\frac{(\lambda s)^{n-1}}{(n-1)!} e^{-\lambda s} ds\)</span>，再对<span class="math inline">\(n\)</span> 求和即可得证。</p><p><em>栗子 4.3</em>：题干同上面的栗子 4.2.</p><p>解：定义 <spanclass="math inline">\(f(s)=I_{[0,t]}(s)(t-s)\)</span>，则 <spanclass="math inline">\(S(t)=\sum_{i=1}^{\infty} f(s_i)\)</span>，利用定理4.5 结论即可得到 <span class="math inline">\({\mathbb E}[S(t)] = \lambdat^2 /2\)</span>。</p><h2 id="泊松过程的分流">4.4 泊松过程的分流</h2><p><strong>定理 4.6</strong>：设 <spanclass="math inline">\(N(t),t\ge0\)</span> 是参数为 <spanclass="math inline">\(\lambda\)</span>的泊松过程，到达事件的类型取决于它到达的时间。如果某到达时间是 <spanclass="math inline">\(s&gt;0\)</span>，则它属于类型 1 的概率为 <spanclass="math inline">\(P(s)\)</span>，输于类型 2 的概率为 <spanclass="math inline">\(1-P(s)\)</span>。假设 <spanclass="math inline">\(N_m(t),(m=1,2)\)</span> 表示 <spanclass="math inline">\((0,t]\)</span> 内到达的类型 <spanclass="math inline">\(m\)</span> 的事件数，则 <spanclass="math inline">\(N_1(t)\)</span> 和 <spanclass="math inline">\(N_2(t)\)</span>是两个独立的泊松变量，相应的均值分别为 <spanclass="math inline">\(\lambda pt\)</span> 和 <spanclass="math inline">\(\lambda(1-p)t\)</span>，其中 <spanclass="math inline">\(p=\frac{1}{t}\int_0^t P(s) ds\)</span>。</p><p>证明：<span class="math inline">\(P(N_1(t)=k, N_2(t)=l) = P(N_1(t)=k,N_2(t)=l | N(t)=k+l) P(N(t)=k+l)\)</span>，考虑发生在 <spanclass="math inline">\((0,t]\)</span> 的事件，如果事件在时刻 <spanclass="math inline">\(s\)</span> 发生，由于其在 <spanclass="math inline">\((0,t]\)</span> 服从均匀分布，那么该事件是类型 1的概率为 <span class="math inline">\(p=\frac{1}{t}\int_0^tP(s)ds\)</span>。</p><p>另外由于这些事件相互独立，因此 <spanclass="math inline">\(P(N_1(t)=k, N_2(t)=l |N(t)=k+l)=\tbinom{k+l}{k}p^k(1-p)^l\)</span>。证毕。</p><blockquote><p><strong>Remark</strong>：如果 <spanclass="math inline">\(P(s)\)</span> 与 <spanclass="math inline">\(s\)</span>无关，那么分流之后将得到两个新的泊松流，否则不是泊松流。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;泊松过程的定义与基本性质&quot;&gt;4.1 泊松过程的定义与基本性质&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义 4.1&lt;/strong&gt;：随机过程 &lt;span
class=&quot;math inline&quot;&gt;\(\{N(t),t\ge0\}\)&lt;/span&gt;
称为时齐泊松过程，若满足下列条件：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;他是一个计数过程，且 &lt;span
class=&quot;math inline&quot;&gt;\(N(0)=0\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;（独立增量）任取 &lt;span class=&quot;math inline&quot;&gt;\(0 &amp;lt; t_1 &amp;lt; t_2
&amp;lt; \cdots &amp;lt; t_n\)&lt;/span&gt;，&lt;span
class=&quot;math inline&quot;&gt;\(N(t_1),N(t_2)-N(t_1),...,N(t_n)-N(t_{n-1})\)&lt;/span&gt;
相互独立；&lt;/li&gt;
&lt;li&gt;（平稳增量）&lt;span class=&quot;math inline&quot;&gt;\(\forall
s,t\ge0,n\ge0\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(P(N(s+t)-N(s)=n) =
P(N(t)=n)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;对任意 &lt;span class=&quot;math inline&quot;&gt;\(t&amp;gt;0\)&lt;/span&gt; 和充分小的 &lt;span
class=&quot;math inline&quot;&gt;\(\Delta t&amp;gt;0\)&lt;/span&gt;，有 &lt;span
class=&quot;math inline&quot;&gt;\(P(N(t+\Delta t)-N(t)=1) = \lambda \Delta t +
o(\Delta t)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(P(N(t+\Delta
t)-N(t)\ge 2)=o(\Delta t)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\lambda&amp;gt;0\)&lt;/span&gt;
称为强度常数，&lt;span class=&quot;math inline&quot;&gt;\(o(\Delta t)\)&lt;/span&gt;
为高阶无穷小。&lt;/p&gt;</summary>
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="泊松过程" scheme="https://glooow1024.github.io/tags/%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B/"/>
    
    <category term="指数分布" scheme="https://glooow1024.github.io/tags/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83/"/>
    
    <category term="顺序统计量" scheme="https://glooow1024.github.io/tags/%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Happy 1024 day!</title>
    <link href="https://glooow1024.github.io/2021/10/24/essay/2021-1024/"/>
    <id>https://glooow1024.github.io/2021/10/24/essay/2021-1024/</id>
    <published>2021-10-24T11:34:36.000Z</published>
    <updated>2021-10-24T11:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>:fireworks:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;:fireworks:&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
