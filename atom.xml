<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你是下雨天</title>
  
  
  <link href="https://glooow1024.github.io/atom.xml" rel="self"/>
  
  <link href="https://glooow1024.github.io/"/>
  <updated>2024-04-16T17:59:29.848Z</updated>
  <id>https://glooow1024.github.io/</id>
  
  <author>
    <name>Glooow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三维旋转、欧拉角、四元数</title>
    <link href="https://glooow1024.github.io/2024/04/16/rotation/"/>
    <id>https://glooow1024.github.io/2024/04/16/rotation/</id>
    <published>2024-04-16T14:24:20.000Z</published>
    <updated>2024-04-16T17:59:29.848Z</updated>
    
    <content type="html"><![CDATA[<p>关于三维旋转、欧拉角和四元数，以前只是简单的调用库函数做转换，并没有深入理解，最近在网上找资料发现还是良莠不齐，很多文章写得比较杂乱，这里根据自己学习后的理解整理出一篇文章以供参考。</p><span id="more"></span><h2 id="欧拉角">1. 欧拉角</h2><p>欧拉角描述了三维空间中的旋转，想象有一架飞机悬在空中朝着正东方向水平静止，现在要将其姿态原地变换到任意一个其他方向，从最接近人的直观来看，在机头原始位置<spanclass="math inline">\(A\)</span>和旋转后位置<spanclass="math inline">\(A&#39;\)</span>连一条线即为最短路径，沿着该最短路径旋转飞机即可。如果用数学语言描述，那么就是假设飞机中心位置为<spanclass="math inline">\(O\)</span>，那么<spanclass="math inline">\(AOA&#39;\)</span>构成一个平面，以该平面法向量为轴旋转飞机，即可将飞机从原始姿态旋转到新的姿态。尽管这种方法很直观，但是一开始欧拉并没有采用这种表示方法，或许是觉得不够规整，旋转轴的确定和表示稍显麻烦。那么欧拉是如何做的呢？如下图所示<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Euler angles -Wikipedia">[1]</span></a></sup>，我们知道笛卡尔坐标系有<spanclass="math inline">\(xyz\)</span>三个轴，那么绕着这三个轴分别做旋转不就可以了吗？这时只需要给出每次旋转的角度即可。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/rotation.webp"alt="欧拉角旋转" /><figcaption aria-hidden="true">欧拉角旋转</figcaption></figure><p>更具体清晰的描述如下：首先假设<strong>世界坐标系</strong>为<spanclass="math inline">\(xyz\)</span>，飞机自身的局部坐标系为<spanclass="math inline">\(XYZ\)</span>（<strong>刚体坐标系</strong>），世界坐标系始终保持固定不变，而飞机局部坐标系在飞机旋转过程中会发生变化。假设飞机初始坐标系为<spanclass="math inline">\(X_1Y_1Z_1\)</span>，想要旋转到一个新的姿态<spanclass="math inline">\(X_2Y_2Z_2\)</span>，那么欧拉给出的一个结论是：任意两个姿态之间，只需要绕<span class="math inline">\(x,y,z(X,Y,Z)\)</span>轴做3次旋转即可完成。不过，具体到旋转过程中，绕哪几个轴旋转的先后顺序和角度都会对最终结果有影响<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://zhuanlan.zhihu.com/p/85108850">欧拉角细节/旋转顺序/内旋外旋- 知乎(zhihu.com) "&gt;[2]</span></a></sup>：</p><ol type="1"><li>内旋还是外旋：可以注意到上面动图中首先绕z轴旋转，第一次旋转之后局部坐标系的<spanclass="math inline">\(xy\)</span>轴与世界坐标系的<spanclass="math inline">\(XY\)</span>轴已经不对齐了，因此第二步是以局部坐标系的轴进行旋转还是以世界坐标系为轴进行旋转？前者被称为内旋，后者为外旋。显然其他参数相同的情况下，两种方式得到的结果不同。</li><li>旋转轴的顺序：欧拉角实际上有两大类，一类是Proper Eulerangles，其旋转顺序包括 (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x,y-x-y)，第二类是Tait–Bryan angles，包括 (x-y-z, y-z-x, z-x-y, x-z-y,z-y-x, y-x-z)。可以看到Proper Euler angles只涉及两个转轴.而Tait–Bryanangles涉及三个转轴。目前机器人以及SLAM领域中常用的是Tait–Bryanangles。后面的论述也都采用Tait–Bryan angles。</li><li>旋转的角度：指定绕 <span class="math inline">\(xyz(XYZ)\)</span>轴三个的旋转角度分别为 <spanclass="math inline">\((\alpha,\beta,\gamma)\)</span>，需要注意的是如果旋转轴的顺序不同，即使每个轴对应的旋转角度不变，最终的姿态角也可能不同。</li></ol><blockquote><p>最后给一个小的总结，也就是说要想用欧拉角的方式描述一个三维旋转，实际上需要5个参数，即：1）内旋or外旋；2）旋转顺序；3）每次旋转的角度。</p></blockquote><p>我们知道旋转可以用矩阵表示，如果考虑外旋的话，那么假设某个点在世界坐标系中的初始位置为<spanclass="math inline">\(\boldsymbol{p}_0\)</span>，如果跟随飞机坐标系按照某个Tait–Bryanangles做外旋，不妨设为 <span class="math inline">\(z(\gamma)\toy(\beta)\to x(\alpha)\)</span>，其旋转后的坐标是可以表示为 <spanclass="math inline">\(\boldsymbol{p}&#39;= \boldsymbol{R} *\boldsymbol{p}_0\)</span>，其中 <spanclass="math inline">\(\boldsymbol{R}\)</span>为旋转矩阵，那么这个旋转矩阵可以写为 <spanclass="math inline">\(\boldsymbol{R}=\boldsymbol{R}_x(\alpha)\boldsymbol{R}_y(\beta)\boldsymbol{R}_z(\gamma)\)</span>，其中<span class="math display">\[\boldsymbol{R}_x(\alpha) = \left[\begin{array}{ccc}1 &amp; 0 &amp; 0 \\0 &amp; \cos (\alpha) &amp; -\sin (\alpha) \\0 &amp; \sin (\alpha) &amp; \cos (\alpha)\end{array}\right] \\\boldsymbol{R}_y(\beta) = \left[\begin{array}{ccc}\cos (\beta) &amp; 0 &amp; \sin (\beta) \\0 &amp; 1 &amp; 0 \\-\sin (\beta) &amp; 0 &amp; \cos (\beta)\end{array}\right] \\\boldsymbol{R}_z(\gamma) = \left[\begin{array}{ccc}\cos (\gamma) &amp; -\sin (\gamma) &amp; 0 \\\sin (\gamma) &amp; \cos (\gamma) &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\]</span>外旋比较简单，但内旋的旋转矩阵就比较复杂，公式推导比较繁琐，这里给出一个简洁的结论：</p><blockquote><p>每种特定顺序的外旋等价于其相反顺序的内旋，例如 <spanclass="math inline">\(z(\gamma)\to y(\beta)\to x(\alpha)\)</span> 与<span class="math inline">\(X(\alpha)\to Y(\beta)\to Z(\gamma)\)</span>的旋转是等价的。</p></blockquote><h2 id="万向锁">2. 万向锁</h2><p>提到欧拉角旋转，很多文章会谈到万向锁问题，需要注意的是：欧拉角用来表示物体的旋转状态是没有问题的，万向锁是用欧拉角表示<strong>旋转过程</strong>中的一种状态，因此其影响到的是<strong>连续运动的问题</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/seraph0321/article/details/111773593">欧拉角表示旋转会出现的问题——万向锁(GimbalLock)-CSDN博客"&gt;[3]</span></a></sup>。另外，<strong>万向锁发生在内旋过程中</strong>，外旋过程是不会发生的。万向锁现象：假设内旋<span class="math inline">\(Z\to Y\to X\)</span>，初始刚体坐标系为 <spanclass="math inline">\(X_0Y_0Z_0\)</span>，其与世界坐标系重合，第1次旋转的时候绕着<span class="math inline">\(Z_0/z\)</span>轴旋转（任意角度）后得到新的刚体坐标系 <spanclass="math inline">\(X_1Y_1Z_1\)</span>，然后第2次旋转过程中绕 <spanclass="math inline">\(Y_1\)</span>轴旋转了90°/-90°，此时第2次旋转过后的刚体坐标系 <spanclass="math inline">\(X_2Y_2Z_2\)</span> 中的 <spanclass="math inline">\(X_2\)</span> 轴与世界坐标系中的 <spanclass="math inline">\(z\)</span>轴是同向/反向的，那么在做第3次旋转操作的时候，理应绕着此时的 <spanclass="math inline">\(X_2\)</span>轴做旋转，但从世界坐标系来看，也就等价于绕着 <spanclass="math inline">\(z\)</span>轴旋转，也就是说第1次和第3次旋转是完全可互相替代的，换言之失去了一个旋转的自由度。其他的内旋顺序也是类似的。简而言之，内旋过程中，当第二个旋转轴旋转90°/-90°时，第三个轴的转动效果可以被第一个旋转轴替代。</p><p>通常网上文章的另一种解释思路是用万向节，也就是陀螺仪的例子，个人认为这个例子不合适。首先陀螺仪中三轴万向锁中的三个轴并不总是保持互相垂直的，外圈的轴旋转并不会带动内圈轴旋转，因此它和我们直接理解刚体坐标系的旋转根本不是一回事。那么网上广为流传的那个粒子和万向锁有什么联系呢？还是结合刚才内旋<span class="math inline">\(Z\to Y\to X\)</span>的例子，以及网上流传的众多图片，下面将给出一个解释。</p><p>首先对于陀螺仪而言，可以看到其结构如下，中间是一根竖轴穿过一个盘子，而盘子处于高速旋转状态，是陀螺的转子，根据陀螺的定轴性，竖轴也就是陀螺的自转轴在惯性空间内的方向保持不变。<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="万向锁与欧拉角 -知乎(zhihu.com)">[4]</span></a></sup></p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/gyroscope.webp"alt="三轴陀螺仪" /><figcaption aria-hidden="true">三轴陀螺仪</figcaption></figure><p>初始时刻陀螺仪的三轴对应于世界坐标系的三轴，绿色可以绕x轴旋转，红色可以绕y轴旋转，蓝色可以绕z轴旋转。</p><table><thead><tr class="header"><th>绿色绕x轴旋转</th><th>红色绕y轴旋转</th><th>蓝色绕z轴旋转</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/gyroscope1.webp" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/gyroscope2.webp" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/gyroscope3.webp" /></td></tr></tbody></table><p>第一次旋转的时候，紫色绕 <span class="math inline">\(z/Z_0\)</span>轴旋转，此时内圈带动外圈一起旋转，还没出什么问题；第2次旋转的时候，红色绕<span class="math inline">\(Y_1\)</span> 旋转，带动外圈的 <spanclass="math inline">\(X_1\)</span>也旋转，需要注意的是，经过第一次旋转之后陀螺仪的坐标轴变成了 <spanclass="math inline">\(X_2Y_1Z_0(=X_2Y_1z)\)</span>，<spanclass="math inline">\(Z\)</span> 轴根本没动啊！还和世界坐标系中的 <spanclass="math inline">\(z\)</span>轴保持一致；然后再第3次旋转，就只有最外层的绕 <spanclass="math inline">\(X_2\)</span>轴旋转了。对于经典配图，也就是下面这张图当中的情况而言，要达到这种状况，就是在做第2次旋转的时候使得<span class="math inline">\(X_2\)</span> 和 <spanclass="math inline">\(z\)</span>轴同向了，这和我们前面解释死锁问题是一致的，这两个轴同向最终导致第3次旋转的时候实际上等价于在旋转<span class="math inline">\(z\)</span> 轴。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/gyroscope4.webp"alt="三轴陀螺仪的万向锁现象" /><figcaption aria-hidden="true">三轴陀螺仪的万向锁现象</figcaption></figure><p>再品一下上面陀螺仪的例子，会发现刚体坐标系和世界坐标系混在一起，而且几个坐标轴还不是同等关系，很容易就把人绕进去了！害人不浅啊！因此要想理解欧拉角万向锁还是去理解前面的内旋<span class="math inline">\(Z\to Y\to X\)</span> 例子吧。</p><p>另一种解释思路是从矩阵运算的角度<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://www.zhihu.com/question/433208062/answer/3008859970">关于欧拉角万向锁一直搞不明白万向锁为啥会形成？- 东方白的回答 - 知乎 "&gt;[5]</span></a></sup>，考虑前面提到的旋转矩阵<spanclass="math inline">\(\boldsymbol{R}=\boldsymbol{R}_x(\alpha)\boldsymbol{R}_y(\beta)\boldsymbol{R}_z(\gamma)\)</span>，当<span class="math inline">\(\beta=\pm\pi/2\)</span> 的时候，会推导出<span class="math display">\[\boldsymbol{R} = \left[\begin{array}{ccc}0 &amp; 0 &amp; 1 \\\sin (\alpha+\gamma) &amp; \cos (\alpha+\gamma) &amp; 0 \\-\cos (\alpha+\gamma) &amp; \sin (\alpha+\gamma) &amp; 0\end{array}\right]\]</span>这里有一点不太合适的，因为万向锁发生在内旋过程中，而这样左乘的矩阵实际上是对应的外旋操作，因此这个解释是有一点小问题的。但也说得通，因为前面提到过内旋和外旋有对应关系，所以可以认为是另一种内旋等价转换为外旋。这里可以看到复合的旋转矩阵<span class="math inline">\(\boldsymbol{R}\)</span>实际上只做了2个旋转操作，也就是所谓一个自由度被“锁”住了。</p><blockquote><p>前提到内旋和外旋操作是有等价关系的，又提到万向锁只发生在内旋过程中，这是否矛盾呢？我的理解是不矛盾，因为我们说内旋和外旋等价的时候，关注的是结果，也就是两种操作不管过程如何，最终旋转后的坐标系是相同的；而在考虑万向锁问题的时候，我们关注的是旋转的过程。</p></blockquote><p>关于万向锁带来的问题，例如3D动画中的插帧问题，以及云台追踪问题，可以参考博客<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/seraph0321/article/details/111773593">欧拉角表示旋转会出现的问题——万向锁(GimbalLock)-CSDN博客 "&gt;[3]</span></a></sup> <ahref="https://blog.csdn.net/seraph0321/article/details/111773593">欧拉角表示旋转会出现的问题——万向锁(GimbalLock)-CSDN博客</a></p><h2 id="四元数">3. 四元数</h2><p>其实大家可以发现，欧拉角方式描述三维旋转的一个关键问题是不唯一性，也就是多种不同的旋转操作可以得到相同的结果，被称为Ambiguity。</p><p>关于四元数的部分后面再写吧。。。</p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Euler_angles">Eulerangles - Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://zhuanlan.zhihu.com/p/85108850">欧拉角细节/旋转顺序/内旋外旋- 知乎(zhihu.com)</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://blog.csdn.net/seraph0321/article/details/111773593">欧拉角表示旋转会出现的问题——万向锁(GimbalLock)-CSDN博客</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/74040465">万向锁与欧拉角- 知乎(zhihu.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://www.zhihu.com/question/433208062/answer/3008859970">关于欧拉角万向锁一直搞不明白万向锁为啥会形成？- 东方白的回答 - 知乎</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><ahref="https://www.zhihu.com/question/47736315/answer/236808639">如何通俗地解释欧拉角？之后为何要引入四元数？- 大脸怪的回答 - 知乎</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于三维旋转、欧拉角和四元数，以前只是简单的调用库函数做转换，并没有深入理解，最近在网上找资料发现还是良莠不齐，很多文章写得比较杂乱，这里根据自己学习后的理解整理出一篇文章以供参考。&lt;/p&gt;</summary>
    
    
    
    
    <category term="旋转" scheme="https://glooow1024.github.io/tags/%E6%97%8B%E8%BD%AC/"/>
    
    <category term="欧拉角" scheme="https://glooow1024.github.io/tags/%E6%AC%A7%E6%8B%89%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>维生素每日摄入量</title>
    <link href="https://glooow1024.github.io/2024/04/13/vitamin/"/>
    <id>https://glooow1024.github.io/2024/04/13/vitamin/</id>
    <published>2024-04-13T15:38:39.000Z</published>
    <updated>2024-04-14T14:25:45.652Z</updated>
    
    <content type="html"><![CDATA[<p>人体所需营养素包括</p><p><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/nutrient2.png" /></p><p>其中，需要补充的维生素包括维生素A、B族、C、D、E，可以分为<strong>脂溶性</strong>和<strong>水溶性</strong>两类<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://askanydifference.com/zh-CN/difference-between-fat-soluble-vitamin-and-water-soluble-vitamin/">脂溶性维生素与水溶性维生素：区别与比较(askanydifference.com) "&gt;[1]</span></a></sup>：</p><table><thead><tr class="header"><th></th><th>脂溶性</th><th>水溶性</th></tr></thead><tbody><tr class="odd"><td>例子</td><td>维生素 A、D、E 和 K</td><td>B 族维生素和维生素 C</td></tr><tr class="even"><td>特点</td><td>储存在脂肪组织中，并且在膳食脂肪存在的情况下更容易被吸收</td><td>可溶于水，除维生素B12外，其他水溶性维生素几乎不会在体内贮存大多会随着尿液排出体外</td></tr><tr class="odd"><td>中毒</td><td>过量的脂溶性维生素会产生严重的中毒症状</td><td>过量基本不会中毒，会随尿液排出</td></tr><tr class="even"><td>食物</td><td>鱼、肉、蛋、奶等</td><td>全麦、坚果等</td></tr></tbody></table><p>根据《中国居民膳食营养素参考摄入量》，我们居民维生素膳食参考摄入量（RNI）为以下标准：</p><h3 id="维生素a">维生素A</h3><ul><li><strong>功效</strong>：维持视觉功能、保持皮肤黏膜完整性、促进免疫、维持生殖功能。</li><li><strong>缺乏</strong>：夜盲症、干眼症、失明、骨质疏松、皮肤粗糙鱼鳞片，影响生育。</li><li><strong>副作用</strong>：每天摄入3毫克维生素A，就有导致骨质疏松的危险。长期每天摄入33毫克以上的维生素A会使食欲不振、皮肤干燥、头发脱落、骨骼和关节疼痛，甚至引起流产。</li><li><strong>摄入量</strong>：成年人800微克/天（约2400单位），可耐受最高摄入量3000微克/天。</li><li><strong>食物</strong>：哈密瓜、杏子和芒果，胡萝卜（约300单位/100g）、南瓜、西兰花、红薯、菠菜，蛋黄、鸡肝、三文鱼等。</li></ul><h3 id="维生素c">维生素C</h3><ul><li><strong>功效</strong>：促进蛋白（尤其是胶原蛋白）生成，促进各种矿物质吸收，捕获自由基，因此能预防像癌症、动脉硬化、风湿病等疾病。此外，它还能增强免疫和，对皮肤、牙龈和神经也有好处。</li><li><strong>缺乏</strong>：坏血病。</li><li><strong>副作用</strong>：迄今，维生素C被认为没有害处，因为肾脏能够把多余的维生素C排泄掉。</li><li><strong>摄入量</strong>：100毫克/天。（丁勇老师推荐200毫克/天，甚至500毫克/天）</li><li><strong>食物</strong>：水果蔬菜。（做熟过程中会损失很多VC）</li></ul><blockquote><p>B族维生素主要是肉类中包含较多。</p><p>B族从来不是孤军奋战的，它们之间亲密合作，一种B族维生素的缺乏，往往是连带着其他多种B族的缺乏，<strong>B族维生素同时补充效果才更好</strong>。</p></blockquote><h3 id="维生素b1">维生素B1</h3><ul><li><strong>功效</strong>：被称为精神性的维生素，对神经组织和精神状态有良好调节作用。</li><li><strong>缺乏</strong>：缺乏易导致脚气病。食欲不振、疲劳乏力、消化不良、头发干枯、记忆力减退、抽筋（肌肉痉挛）。</li><li><strong>副作用</strong>：食用过多，可能会出现乏力、腹泻、食欲减退、头痛、精力下降等症状。</li><li><strong>摄入量</strong>：成年男子1.4毫克/天，成年女子1.3毫克/天。</li><li><strong>食物</strong>：全谷物（燕麦/小麦/小米）、豆类（黄豆/豌豆）、猪肉、动物内脏。</li></ul><h3 id="维生素b2核黄素">维生素B2（核黄素）</h3><ul><li><strong>功效</strong>：促进发育和细胞的再生；促进生长发育，维护皮肤和细胞膜的完整性；预防和消除口腔生殖综合；促使皮肤、指甲、毛发的正常生长；促进机体对铁的吸收，可防贫血等。</li><li><strong>缺乏</strong>：嘴唇干裂、易口腔溃疡、口角炎、皮炎、舌炎、结膜炎和角膜炎等。</li><li><strong>副作用</strong>：主要是皮肤会出现瘙痒，还有麻木、刺痛、灼热等等感觉异常的情况，以及排尿会非常黄，长期大量口服维生素B2会导致肾脏功能有所损害，表现为肌酐升高，尿素氮升高。</li><li><strong>摄入量</strong>：成年男子1.4毫克/天，成年女子1.2毫克/天。</li><li><strong>食物</strong>：动物肝脏、蛋类、全谷物（荞麦/绿豆）、乳制品、巴旦木。</li></ul><h3 id="维生素b3烟酰胺">维生素B3（烟酰胺）</h3><ul><li><strong>功效</strong>：合成性激素不可缺少的物质，促进血液循环，降低血压，降低胆固醇和甘油三酯。具有一定的美白作用。</li><li><strong>缺乏</strong>：手脚冰凉，嘴唇乌青。</li><li><strong>副作用</strong>：每天摄入量超过100毫克就会对身体造成危害。症状：发高热、头痛、恶心、肌肉痉挛。长期摄入超过100毫克的大剂量维生素B3会导致心律不齐，伤害肝脏。而且体内也能自动合成维生素B3。</li><li><strong>摄入量</strong>：男性15毫克，女性12毫克。上限35毫克。</li><li><strong>食物</strong>：坚果（花生/瓜子）、肉类（瘦肉/鱼肉）、豆类。</li></ul><h3 id="维生素b5泛酸">维生素B5（泛酸）</h3><ul><li><strong>功效</strong>：</li><li><strong>缺乏</strong>：</li><li><strong>副作用</strong>：</li><li><strong>摄入量</strong>：</li><li><strong>食物</strong>：</li></ul><h3 id="维生素b6">维生素B6</h3><ul><li><strong>功效</strong>：参与激素和红血球的合成，可以促进人体分泌胰岛素平衡，预防糖尿病。</li><li><strong>缺乏</strong>：烦躁易怒、情绪波动、失眠、睡眠质量差、嘴唇干裂、口角炎、皮炎等。</li><li><strong>副作用</strong>：日服100毫克左右就会对大脑和神经造成伤害。过量摄入还可能导致所谓的神经病，即一种感觉迟钝的神经性疾病。最坏的情况是导致皮肤失去知觉。</li><li><strong>摄入量</strong>：成年人需要1.2毫克/天。</li><li><strong>食物</strong>：坚果（花生/瓜子/芝麻）、鸡肉、牛肉、海鱼肉。</li></ul><h3 id="维生素b7">维生素B7</h3><ul><li><strong>功效</strong>：</li><li><strong>缺乏</strong>：皮炎、脱发、白发等。</li><li><strong>副作用</strong>：</li><li><strong>摄入量</strong>：</li><li><strong>食物</strong>：</li></ul><h3 id="维生素b9叶酸">维生素B9（叶酸）</h3><ul><li><strong>功效</strong>：被称为“造血维生素”，制造红血球和白血球，增强免疫能力。</li><li><strong>缺乏</strong>：贫血、舌头红肿疼痛、精神萎靡、容易疲劳、健忘、失眠、儿童生长发育不良等，孕妇可表现为畸胎、习惯性流产等。</li><li><strong>副作用</strong>：</li><li><strong>摄入量</strong>：</li><li><strong>食物</strong>：绿色蔬菜、新鲜水果（草莓）、肝脏、坚果豆类（瓜子/黄豆）。</li></ul><h3 id="维生素b12">维生素B12</h3><ul><li><strong>功效</strong>：是身体正常生长和红血球生长所不可或缺的，有助于维持神经系统的健康。</li><li><strong>缺乏</strong>：手脚容易麻木、记忆差、有胃病、</li><li><strong>副作用</strong>：</li><li><strong>摄入量</strong>：</li><li><strong>食物</strong>：蛋类、牛奶、肉类、虾。</li></ul><h3 id="维生素d">维生素D</h3><ul><li><strong>功效</strong>：维生素D是形成骨骼和软骨的发动机，能使牙齿坚硬。对神经也很重要，并对炎症的抑制作用。</li><li><strong>缺乏</strong>：骨质疏松。</li><li><strong>副作用</strong>：研究人员估计，长期每天摄入0.025克维生素D对人体有害。可能造成的后果是：恶心、头痛、肾结石、肌肉萎缩、关节炎、动脉硬化、高血压。</li><li><strong>摄入量</strong>：800单位。0.0005至0.01毫克。只有休息少的人，才需要额吃些含维生素D的食品或制剂。</li><li><strong>食物</strong>：</li></ul><h3 id="维生素e">维生素E</h3><ul><li><strong>功效</strong>：维生素E能抵抗自由基的侵害，预防癌症的心肌梗死。此外，它还参与抗体的形成，是真正的“后代支持者”。它促进男性产生有活力的精子。</li><li><strong>缺乏</strong>：黄褐斑、老年斑、不孕不育。</li><li><strong>副作用</strong>：每天摄入200毫克的维生素E就会出现恶心，肌肉萎缩，头痛和乏力等症状。每天摄入的维生素E超过300毫克会导致高血压，伤口愈合延缓，甲状腺功能受到限制。</li><li><strong>摄入量</strong>：成年人需要14毫克。</li><li><strong>食物</strong>：</li></ul><h2 id="总结">总结</h2><ul><li>维生素A：按照正常推荐剂量服用即可，即使略微过量也没关系，不会导致中毒。</li><li>维生素B：主要来自于肉类，由于是水溶性，因此不用太担心服用过量的问题。需要注意B族各类维生素要一起补充，相辅相成。因此可以服用复合维生素B片。</li><li>维生素C：主要来自蔬菜水果，尽可能多的多补充，同样是水溶性，不用担心过量的问题。</li><li>维生素D：</li><li>维生素E：</li><li>锌：不缺就不要补，会影响铁、铜的吸收。</li></ul><p>1IU=0.3<span class="math inline">\(\mu {\rm g}\)</span></p><table><thead><tr class="header"><th>维生素</th><th>摄入量</th><th>推荐</th></tr></thead><tbody><tr class="odd"><td>维生素A</td><td>800微克/天</td><td>维生素A软胶囊，每片含5000单位。<br>每天1次，每次1粒。</td></tr><tr class="even"><td>维生素C</td><td>200毫克/天</td><td>维生素C片，每片包含100mg。<br>每天3次，每次1片。</td></tr><tr class="odd"><td>维生素B1</td><td></td><td>恒健复合维生素片，每片包含<span class="math inline">\(B_1\)</span>3mg，<span class="math inline">\(B_2\)</span> 1.5mg，<spanclass="math inline">\(B_3\)</span> 10mg，<spanclass="math inline">\(B_5\)</span> 1mg，<spanclass="math inline">\(B_6\)</span> 0.2mg。<br>每天3次，每次1片。</td></tr><tr class="even"><td>维生素B2</td><td></td><td></td></tr><tr class="odd"><td>维生素B6</td><td></td><td></td></tr><tr class="even"><td>维生素B9（叶酸）</td><td></td><td>叶酸片，每片含<span class="math inline">\(B_9\)</span>0.4mg。<br>每天1次，每次1片。</td></tr><tr class="odd"><td>维生素B12</td><td></td><td></td></tr><tr class="even"><td>葡萄糖酸锌片</td><td></td><td>南岛葡萄糖酸锌片，每片包含Zn10mg。<br>每天3次，每次1片。（不缺就不要补）</td></tr></tbody></table><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://askanydifference.com/zh-CN/difference-between-fat-soluble-vitamin-and-water-soluble-vitamin/">脂溶性维生素与水溶性维生素：区别与比较(askanydifference.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人体所需营养素包括&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2024/nutrient2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，需要补充的维</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>高斯分布常用公式</title>
    <link href="https://glooow1024.github.io/2023/12/18/probability/gaussian/"/>
    <id>https://glooow1024.github.io/2023/12/18/probability/gaussian/</id>
    <published>2023-12-18T13:46:07.000Z</published>
    <updated>2023-12-18T13:48:28.398Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后面推导中反复用到Woodbury恒等式 <span class="math display">\[(A+UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}\]</span></p></blockquote><h3 id="边缘分布">1. 边缘分布</h3><p>假设 <span class="math inline">\(\boldsymbol{x}\sim {\mathcalN}(\boldsymbol{\mu}, \boldsymbol\Sigma_1),\boldsymbol{y}|\boldsymbol{x}\sim\mathcal{N}(\boldsymbol{A}\boldsymbol{x},\boldsymbol\Sigma_2)\)</span>，那么 <spanclass="math inline">\(\boldsymbol{y}\)</span> 的边缘分布也是高斯分布<span class="math display">\[\boldsymbol{y} \sim \mathcal{N}(\boldsymbol{\mu}_3, \boldsymbol\Sigma_3)\\\boldsymbol\Sigma_3 = (\boldsymbol\Sigma_2^{-1} -\boldsymbol\Sigma_2^{-1}\boldsymbol{A}(\boldsymbol\Sigma_1^{-1}+\boldsymbol{A}^{\rm T}\boldsymbol\Sigma_2^{-1} \boldsymbol{A})^{-1} \boldsymbol{A}^{\rm T}\boldsymbol\Sigma_2^{-1})^{-1} = \boldsymbol\Sigma_2 +\boldsymbol{A}\boldsymbol\Sigma_1 \boldsymbol{A}^{\rm T} \\\boldsymbol{\mu}_3 = \boldsymbol\Sigma_3 \boldsymbol\Sigma_2^{-\rm T}\boldsymbol{A} (\boldsymbol\Sigma_1^{-1}+\boldsymbol{A}^{\rm T}\boldsymbol\Sigma_2^{-1} \boldsymbol{A})^{-1} \boldsymbol\Sigma_1^{-1}\boldsymbol{\mu} = \boldsymbol{A\mu}\\\]</span></p><h3 id="后验分布">2. 后验分布</h3><p>假设有先验 <span class="math inline">\(\boldsymbol{x}\sim {\mathcalN}(\boldsymbol{\mu}, \boldsymbol\Sigma_1)\)</span>，似然 <spanclass="math inline">\(\boldsymbol{y}|\boldsymbol{x}\sim\mathcal{N}(\boldsymbol{A}\boldsymbol{x},\boldsymbol\Sigma_2)\)</span>，那么关于 <spanclass="math inline">\(\boldsymbol{x}\)</span> 的后验分布也是高斯分布<span class="math display">\[p(\boldsymbol{x}| \hat{\boldsymbol{y}}) \proptop(\boldsymbol{x},\hat{\boldsymbol{y}}) = p(\boldsymbol{x})p(\hat{\boldsymbol{y}} | \boldsymbol{x}) \sim {\mathcalN}(\boldsymbol{\mu}_4, \boldsymbol\Sigma_4) \\\boldsymbol{\Sigma}_4 = (\boldsymbol\Sigma_1^{-1} + \boldsymbol{A}^{\rmT}\boldsymbol{\Sigma}_2^{-1}\boldsymbol{A})^{-1} \\\boldsymbol{\mu}_4 = \boldsymbol{\Sigma}_4(\boldsymbol{\Sigma}_1^{-1}\boldsymbol{\mu} + \boldsymbol{A}^{\rmT}\boldsymbol{\Sigma}_2^{-1}\hat{\boldsymbol{y}})\]</span> 特殊情况下，假如 <spanclass="math inline">\(\boldsymbol{A}=\boldsymbol{I},\boldsymbol{\Sigma}_2=\sigma^2\boldsymbol{I},\boldsymbol{\mu}=\boldsymbol{0}\)</span>，此时将有<span class="math display">\[\boldsymbol{\Sigma}_4 = \sigma^2 \boldsymbol{\Sigma}_1(\boldsymbol{\Sigma}_1 + \sigma^2\boldsymbol{I})^{-1} \\\boldsymbol\mu_4 =\boldsymbol{\Sigma}_1(\boldsymbol{\Sigma}_1+\sigma^2\boldsymbol{I})^{-1}\hat{\boldsymbol{y}}\]</span></p><h3 id="条件分布">3. 条件分布</h3><p>假设 <spanclass="math inline">\(\boldsymbol{x}_1,\boldsymbol{x}_2\)</span>服从联合高斯分布 <span class="math display">\[\begin{bmatrix} \boldsymbol{x}_1 \\ \boldsymbol{x}_2 \end{bmatrix} \sim{\mathcal N} \left( \begin{bmatrix} \boldsymbol{\mu}_1 \\\boldsymbol{\mu}_2 \end{bmatrix},  \begin{bmatrix}\boldsymbol{\Sigma}_{11} &amp; \boldsymbol{\Sigma}_{12} \\\boldsymbol{\Sigma}_{21} &amp; \boldsymbol{\Sigma}_{22}\end{bmatrix}  \right)\]</span> 那么 <span class="math inline">\(\boldsymbol{x}_2 |\boldsymbol{x}_1\)</span> 也服从高斯分布 <span class="math display">\[\boldsymbol{x}_2 | \boldsymbol{x}_1 \sim {\mathcalN}(\boldsymbol{\mu}_5, \boldsymbol{\Sigma}_5) \\\boldsymbol{\Sigma}_5 = \boldsymbol{\Sigma}_{22}-  \boldsymbol{\Sigma}_{21} \boldsymbol{\Sigma}_{11}^{-1}\boldsymbol{\Sigma}_{12} \\\boldsymbol{\mu}_5 = \boldsymbol{\mu}_2 + \boldsymbol{\Sigma}_{21}\boldsymbol{\Sigma}_{11}^{-1} (\hat{\boldsymbol{x}}_1 -\boldsymbol{\mu}_1)\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后面推导中反复用到Woodbury恒等式 &lt;span class=&quot;math display&quot;&gt;\[
(A+UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}
\]&lt;/span&gt;</summary>
      
    
    
    
    <category term="Probability Theory" scheme="https://glooow1024.github.io/categories/Probability-Theory/"/>
    
    
    <category term="高斯分布" scheme="https://glooow1024.github.io/tags/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>爱得太迟</title>
    <link href="https://glooow1024.github.io/2023/02/10/music/ThePresentPerson/"/>
    <id>https://glooow1024.github.io/2023/02/10/music/ThePresentPerson/</id>
    <published>2023-02-10T15:15:01.000Z</published>
    <updated>2023-02-17T05:36:51.249Z</updated>
    
    <content type="html"><![CDATA[<center><h2>当时只道是寻常</h2></center><center>我们总是爱得太迟，等到那人真的失去，才追悔莫及。</center><center>最可怕是，爱得太迟，只差一秒，心声都已变历史。</center><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=5240533&amp;auto=1&amp;height=66"></iframe><blockquote><p>我过去 那死党 早晚共对</p><p>各也扎职以后 没法 畅聚</p><p>而终於 相约到 但无言共对 疏淡如水</p><p>日夜做 见爸爸 刚好想呻</p><p>却霎眼 看出他 多了皱纹</p><p>而他的苍老感 是从来未觉 太内疚担心</p><p>·</p><p>最心痛是 爱得太迟</p><p>有些心意 不可等某个日子</p><p>盲目地发奋 忙忙忙其实自私</p><p>梦中也习惯 有压力要我得志</p><p>最可怕是 爱需要及时</p><p>只差一秒 心声都已变历史</p><p>忙极亦放肆 见我爱见的相知</p><p>要抱要吻要怎么也好 偏要推说等下一次</p><p>·</p><p>我也觉 我体质 彷似下降</p><p>看了症得到是 别要太忙</p><p>而影碟 都扫光 但从来未看 因有事赶</p><p>日夜做 储的钱 都应该够</p><p>到圣诞 正好讲 跟我白头</p><p>谁知她开了口 未能挨下去 已恨我很久</p><p>·</p><p>错失太易 爱得太迟</p><p>我怎想到 她忍不到那日子</p><p>盲目地发奋 忙忙忙从来未知</p><p>幸福会掠过 再也没法说钟意</p><p>爱一个字 也需要及时</p><p>只差一秒 心声都已变历史</p><p>为何未放肆 见我爱见的相知</p><p>要抱要吻要怎么也好 不要相信一切有下次</p><p>·</p><p>相拥我所爱又花几多秒</p><p>这几秒 能够做到又有多少</p><p>未算少 足够遗憾忘掉</p><p>多少抱憾 多少过路人</p><p>太懂估计 却不懂爱惜自身</p><p>人人在发奋 想起他朝都兴奋</p><p>但今晚未过 你要过也很吸引</p><p>纵不信运 你不过是人</p><p>理想很远 爱於咫尺却在等</p><p>来日别操心 趁你有能力开心</p><p>世界有太多东西发生 不要等到天上俯瞰</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h2&gt;
当时只道是寻常
&lt;/h2&gt;
&lt;/center&gt;
&lt;center&gt;
我们总是爱得太迟，等到那人真的失去，才追悔莫及。
&lt;/center&gt;
&lt;center&gt;
最可怕是，爱得太迟，只差一秒，心声都已变历史。
&lt;/center&gt;</summary>
    
    
    
    <category term="Music" scheme="https://glooow1024.github.io/categories/Music/"/>
    
    
  </entry>
  
  <entry>
    <title>《娱乐至死》读后感</title>
    <link href="https://glooow1024.github.io/2022/09/03/essay/amusing_ourselves_to_death/"/>
    <id>https://glooow1024.github.io/2022/09/03/essay/amusing_ourselves_to_death/</id>
    <published>2022-09-03T14:05:17.000Z</published>
    <updated>2022-09-16T00:09:24.095Z</updated>
    
    <content type="html"><![CDATA[<p>人们表达、传递信息的工具/广义的语言包括：语言文字、图片/绘画、声音、视频，相应的信息传播的媒介包括：口口相传、印刷术、摄影技术、电视、互联网。</p><p>不同形式的语言的表达能力是不同的。例如语言文字可以表达更为抽象的概念，并且表意更为准确清晰；而图片则大多数时候只能表示具象的事物，有时候也可以表达抽象的想法，但通常是不清晰不明确的，是一种朦胧的感受，对读者来说会有“一千个哈姆雷特”；声音则更为朦胧一些，例如音乐带给我们的大体是某一种情绪，至于它如何引导我们产生怎样的反应与思考，更是因人而异；视频在将图像和声音结合在一起之后，除了拥有他们二者的特点，通过将多个画面、画面与声音的链接，能够产生相比之下更为准确同时也更具有冲击力的表达。</p><p>在前面提到的几种“语言”当中，文字与其他几种的区别格外的大。根本上来说，后面三种均来自于大自然，来自于外部世界，来自于人的直观感受；而语言文字是人类的独立创造，是人类建立的符号库，是对人类活动高度总结与概括，并进行一定程度的凝练与抽象，其具备的抽象表达能力正是人类思考后结出的精妙果实，并且在相互交流融合过程中，所有人达成高度共识，语言文字得以成为人类群体中极度凝练高效的信息表达与传递工具。再看音画视频这几种语言，他们也具备一定的情感信息表达功能，随着文明的进步，人类发掘了艺术创作能力，随着技术的进步，人类具备了记录、以及自己凭空创造图像、声音、视频的能力，我们总结出了一定的规律和原则，例如冷暖色调表达不同的感情，舒缓与快速的音乐节奏渲染不同的氛围，然而我们始终没有统一的生成与解读规则，我们没有规定红色一定代表热情，没有规定什么样的节奏一定代表着紧张，我们没有这么做，也没有必要，否则那就是另一种形式的“语言文字”，这几种语言生来自由，我们已经习惯了见仁见智，甚至正是因为这样的特点他们才不可或缺。在人与人的信息交流方面，可以说音画视频只是作为语言文字的补充手段，也可以说这都是注定的，或者本就如此，从诞生起就如此。</p><p>说完了几种语言，再来聊聊信息传播媒介。《娱乐至死》这本书主要是对比了印刷术时代走向娱乐时代，美国文化所发生的变化。作者指出媒介本身或许可以传播各种各样的语言，各种类型的信息，但是其认为技术绝对不是中立的，不可否认一种媒介技术本身对某一种形式的语言和信息具有偏好，这就导致了不同的媒介产生的是完全不同的文化特点。作者在上下两部分分别指出了两者的特点，对于印刷术：</p><p>印刷机统治下的人们更热衷于思辨，公众对话也像论文论述那样条分缕析、逻辑严密，严肃而理性，举的例子便是林肯与道格拉斯的辩论，他们一场辩论能够持续7个小时，每个人发言句法复杂，措辞精准，将辩词直接打印出来作为作为印刷本也丝毫不违和，而台下的观众也有足够的耐心和兴趣持续听完这样的辩论。</p><p>对于电视：</p><ol type="1"><li>电视上的一切都是为了娱乐，电视需要的是表演艺术，只有能够吸引观众的眼球内容才能在电视产业中存活下来；</li><li>电视使得一切变得琐碎，遥控器上的一个小小按钮，就能让我们瞬间从火灾新闻报道切换到脱口秀表演，一切变得支离破碎，包括人投入的情绪；同时语境消失了，我们的判断失去了上下文，逻辑不再那么重要，或者说难以根据逻辑判断；</li><li>同第一点相同，电视本身的特点，使得很多话语形式在电视传播过程中，其内涵被改变了，本书举了宗教、政治、教育的例子；这些领域原本都是非常严肃庄重的，在电视文化里，他们也都逐渐以娱乐性作为卖点，不再进行深度思考，宗教可以不再虔诚，政客的政治主张与执政能力不再成为是否获选的主要因素，教学从教室走向了电视。</li></ol><p>有意思的是，作者非常详细地反驳了“教学和娱乐不可分”的观点，首先学习需要兴趣，好的学习过程会让人感到快乐，这不可否认，但是当学习变成一种娱乐活动（而这正是电视所做的事情），其未必是有效、持久的。仔细想想，曾经有人告诉我们互联网是知识的海洋，如今我们浏览者网页，刷着短视频，看着各种各样图文并茂的科普，看似无时无刻不在快乐的学习，但是当按下电源键，刚刚看过的东西还记得多少？用娱乐的方式进行教学只能是一种美好的畅想，因为二者从本质上是完全相悖的，作者指出三条戒律：1）娱乐（电视）总是不假设你了解什么前提条件，即看即懂；2）不能令你困惑；3）避免枯燥无味的阐述，总是图文并茂，并配以优美的音乐。而教育，恰恰与这三点完全相违背，学习需要连续的长时间的深度思考，获得新知识与思辨能力是痛苦的过程。</p><p>实际上，说与写是完全不同的两件事情，相信每个人都有这种体会，书写过程中我们会反复斟酌行文逻辑、语言措辞，努力使读者清晰准确的理解这段文字所表述的内容，而说则不一样，我们通常没有足够时间梳理逻辑，话语往往跟随潜意识喷薄而出。表达的方式会影响表达的内容，从口语文化，印刷文化，到电视文化，再到互联网时代，每一次技术变革都会带来巨大的文化变革。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人们表达、传递信息的工具/广义的语言包括：语言文字、图片/绘画、声音、视频，相应的信息传播的媒介包括：口口相传、印刷术、摄影技术、电视、互联网。&lt;/p&gt;
&lt;p&gt;不同形式的语言的表达能力是不同的。例如语言文字可以表达更为抽象的概念，并且表意更为准确清晰；而图片则大多数时候只</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科目三</title>
    <link href="https://glooow1024.github.io/2022/08/04/essay/driving-subject-3/"/>
    <id>https://glooow1024.github.io/2022/08/04/essay/driving-subject-3/</id>
    <published>2022-08-04T02:48:11.000Z</published>
    <updated>2022-08-04T03:38:56.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下科目三的主要操作流程与关键点。</p></blockquote><h2 id="细节">0. 细节</h2><ol type="1"><li>从左至右，离合，刹车，油门；</li><li>前方右侧车道有停止车辆时，需要按两下喇叭，防止他突然开车门；</li><li>直行的时候，驾驶座正前方大约在车道1/3处；</li><li>停车时，离合和刹车要一起踩，若只踩刹车不踩离合容易发动机熄火；</li><li>1挡不能连续行驶超过50m，2挡不能连续行驶超过150m，两者加起来不能超过200m；</li><li>换挡不要求快，慢一点，不要换错；</li></ol><span id="more"></span><h2 id="考试流程">1. 考试流程</h2><ol type="1"><li>上车调整座椅，不系安全带，检查灯光回正，观察后视镜、雨刮器的点；</li><li>听到考试指令开始，下车逆时针绕车一周，点一下车身的黑色按钮；</li><li>上车坐好，系安全带；</li><li>灯光考试；</li><li>起步，道路考试；</li></ol><h2 id="灯光考试">2. 灯光考试</h2><h3 id="近光灯">近光灯:</h3><ol type="1"><li>夜间在照明良好的条件下行驶。</li><li>夜间在同方向近距离跟车行驶。</li><li>夜间直行通过路口。</li><li>夜间通过有交通信号灯控制的路口。</li><li>夜间与机动车、非机动车会车。</li></ol><h3 id="远近光灯交替使用两下">远近光灯交替使用两下:</h3><ol type="1"><li>夜间超越前方车辆</li><li>夜间通过急弯、坡路、拱桥，人行横道。</li><li>夜间通过没有交通信号灯控制的路口。</li></ol><h3 id="大灯关一半开双闪">大灯关一半开双闪:</h3><ol type="1"><li>夜间路边临时停车（大灯关一半 示廓灯）双闪 危险警报灯</li><li>夜间在道路上发生交通事故，妨碍交通又难以移动 。</li></ol><h3 id="远光灯">远光灯:</h3><p>❗夜间在没有路灯、照明不良条件下行驶。</p><h2 id="起步">3. 起步</h2><ol type="1"><li>打转向，按喇叭，挂1挡，松手刹；</li><li>松手刹后的10s内要完成起步；</li><li>观察左后视镜，看后方有没有来车，有的话先慢慢直行，没有的话左转向，慢松离合起步，不要闯动；</li><li>方向盘角度不要太大，到车道一半的时候就可以回正方向盘；</li><li>转向灯恢复正常；</li></ol><h2 id="换挡">4. 换挡</h2><ol type="1"><li>踩油门一口气加速到目标速度，然后快速松开；</li><li>离合踩到底；</li><li>换挡；</li><li>松离合，可以稍快一点，不用像科目二那么慢；1、2挡还是要稍微慢一些，3、4挡可以直接松开；</li></ol><h2 id="加减挡">5. 加减挡</h2><ol type="1"><li>需要逐级加挡到4挡，并保持大于40km/h的速度5s以上；</li><li>然后离合和刹车一起踩到底，当车速降到35时稍微松一点刹车，当车速降到28左右时松开刹车，仍然保持踩着离合，换到3挡；</li></ol><blockquote><p>考试路线上会出现斑马线，因此要在到达斑马线前将车速降到30km/h以下，整体时间还是很紧的，稍微慢一点很可能就不能及时完成。</p></blockquote><h2 id="变更车道">6. 变更车道</h2><ol type="1"><li>响起指令以后就打转向灯；</li><li>观察后方有没有车辆，扭头幅度大一些；</li><li>等待3秒，没有车辆就可以换车道；</li><li>结束后记得转向灯回正；</li></ol><blockquote><p>变更车道过程中注意扶好转向灯，不要让他中途掉了。</p></blockquote><h2 id="超车">7. 超车</h2><ol type="1"><li>先向左变更车道，再向右变更车道；</li></ol><blockquote><p>需要注意的是要在一定距离范围内完成超车，因此要卡好时间，不要拖延。如果后方有来车，可以挂2挡把速度降下来，防止不能在规定时间和距离内完成超车。</p></blockquote><h2 id="路口直行">8. 路口直行</h2><ol type="1"><li>距离路口30m内需要减速慢行，如果可以直接通过红绿灯，则距离斑马线20m左右轻踩一下刹车，如果需要等待红灯，则停车挂空挡，然后再起步；</li><li>起步先挂一档，然后踩一下油门提上速度，换二挡；</li></ol><blockquote><p>有时候红绿灯在坡道上，再次起步可能需要半坡起步。</p></blockquote><h2 id="路口转弯">9. 路口转弯</h2><ol type="1"><li>首先记得打转向灯；</li><li>距离路口30m左右减速到2挡；</li><li>距离路口20m左右踩一下刹车；</li><li>转弯前扭头看一下侧后方有没有车或者行人；</li><li>后面操作跟直行过马路基本相同，但是转弯时必须要在2挡；</li></ol><blockquote><p>考试路线中右转弯基本不需要等红路灯，可以直接转。但是如果刚好遇到左边道路车辆直行过路口，可以等他们过完再右转。</p></blockquote><h2 id="调头">10. 调头</h2><ol type="1"><li>首先记得打左转向灯；</li><li>首先换到2挡；</li><li>掉头前需要踩一下刹车；</li><li>观察对方有无来车，能调头就直接调，不能的话可以先停车等待，然后再1挡起步调头；</li><li>看到肩膀超过调头的牌子以后打死方向盘就能正常调过去；</li></ol><h2 id="会车">11. 会车</h2><ol type="1"><li>轻踩一下刹车；</li><li>向右打一下方向盘；</li><li>回正；</li></ol><blockquote><p>由于需要在道路中向右打一下方向盘，为防止压实线，可以提前靠左一点行驶。</p></blockquote><h2 id="直线行驶">12. 直线行驶</h2><ol type="1"><li>就是要保持100m直线行驶，横向偏离幅度不超过30cm，目视前方微调方向盘；</li></ol><h2 id="靠边停车">13. 靠边停车</h2><ol type="1"><li>先打右转向灯；</li><li>观察后方有没有来车，扭头幅度大一些；</li><li>调整到2挡，踩下离合和刹车慢慢走；</li><li>进入最右侧车道，先将车后回正，再慢慢调方向盘使车身不断靠近路边实线；切忌向右摆动幅度过大，一方面不容调整车身回正，另一方面容易压实线；</li><li>观察雨刮器，对齐路边沿白线右侧边缘，使车距离车道线控制在30cm以内；或者观察右侧后视镜，后边车门把手距离白线左侧边缘两指左右；</li><li>停车，挂空档，拉手刹，关闭发动机，松开安全带，观察后方有无来车，3s后打开车门，打开车门后10s内人下车并关闭车门；</li></ol><h2 id="整体理解">14. 整体理解</h2><p>科目三实际上就是要在实际道路上跑一圈，在路途中完成前面提到的各种操作，不同操作之间基本是相互独立，所以到每个地方只需要考虑对应的操作就可以了，不要觉得东西又多又杂，其实并不杂乱。</p><p>贯穿全程的一个关键是速度和挡位的选择，因为1挡和2挡连续行驶距离有最大限制，所以基本上都要保持3挡大约22km/h的速度行驶，采用其他挡位的地方只有：起步（包括中途停车后起步）、路口转弯、调头、靠边停车，以及加到4挡行驶。因此速度和挡位的选择也是很清晰的，主要是注意换挡的时候速度匹配、不要换错挡。</p><p>另外最容易错的地方还有：1）忘记打转向灯；2）斑马线/路口前忘记踩刹车；3）换到1、2挡松离合过快造成闯动。</p><p>靠边停车要找好点，速度要慢。</p><p>因为有的操作并不会有提示（例如转弯前要提前变更车道），因此提前熟悉考试路线很有必要。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录下科目三的主要操作流程与关键点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;细节&quot;&gt;0. 细节&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;从左至右，离合，刹车，油门；&lt;/li&gt;
&lt;li&gt;前方右侧车道有停止车辆时，需要按两下喇叭，防止他突然开车门；&lt;/li&gt;
&lt;li&gt;直行的时候，驾驶座正前方大约在车道1/3处；&lt;/li&gt;
&lt;li&gt;停车时，离合和刹车要一起踩，若只踩刹车不踩离合容易发动机熄火；&lt;/li&gt;
&lt;li&gt;1挡不能连续行驶超过50m，2挡不能连续行驶超过150m，两者加起来不能超过200m；&lt;/li&gt;
&lt;li&gt;换挡不要求快，慢一点，不要换错；&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>无线通信标准杂谈</title>
    <link href="https://glooow1024.github.io/2022/06/14/communication/communication-specification/"/>
    <id>https://glooow1024.github.io/2022/06/14/communication/communication-specification/</id>
    <published>2022-06-14T08:24:03.000Z</published>
    <updated>2022-06-14T08:35:31.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="g-lte">4G LTE</h2><p>采用OFDM调制，支持的带宽有（大带宽）10MHz、15MHz、20MHz，（窄带）1.4MHz、3MHz、5MHz。正常情况下子载波间隔15KHz，符号周期66.7us，加上循环前缀长度为71.35us。LTE在时域上的最小单位为时隙，以0.5ms为周期，在15KHz下，0.5ms*15KHz=7.5个正弦波，因此一个时隙内可以容纳7个symbol，多余出来的时间分配给各个符号的循环前缀<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/Angel_YJ/article/details/89001077">[3]</span></a></sup>。</p><p>各个子载波可以根据信道状况采用不同的调制方式，如BPSK，QPSK，8PSK，16QAM，64QAM等；当信道条件好时采用高阶调制方式，而当信道条件差时采用抗干扰能力强的低阶调制方式<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/jyqxerxes/article/details/78981109">[2]</span></a></sup>。</p><h2 id="g-nr">5G NR</h2><p>在5GNR中，定义了两种频段范围，FR1和FR2，FR1表示低频频段，FR2表示毫米波高频频段。具体FR1和FR2表示的频段范围如下表所示：</p><table><thead><tr class="header"><th>Frequency range</th><th>Frequency range</th></tr></thead><tbody><tr class="odd"><td>FR1 (Sub-6GHz)</td><td>410MHz - 7125MHz</td></tr><tr class="even"><td>FR2 (mmWave)</td><td>24250MHz - 52600MHz</td></tr></tbody></table><p>其中Sub6G频段以3.5GHz为主（3.2GHz-4.2GHz），最大带宽为100MHz。mmWave频段以28/39/60/73GHz为主，带宽50MHz-400MHz<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="5G - Wikipedia">[6]</span></a></sup>。</p><p>5G仍旧采用OFDM调制，但是不同于4GLTE在于设置了多个不同的子载波间隔，也即<spanclass="math inline">\(\Delta f=2^\mu \cdot 15\)</span>[kHz]，其中<spanclass="math inline">\(\mu=0,1,2,3,4\)</span>，也就是子载波间隔<spanclass="math inline">\(\Delta f\)</span>取值为15/30/60/120/240kHz。</p><p>在5G和4G中，帧的长度都是10ms，子帧长度都是1ms。在LTE中，一个子帧包含了14个符号。5G中，当调制符号时间变短时，一个子帧长度1ms内也就有了更多的符号<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/u010202588/article/details/94360185">[4]</span></a></sup>。与4G不同，5G中的时隙长度不是固定的，每个时隙内都有14个符号，但是随着子载波间隔的不同，对应的时隙不再是固定的0.5ms<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_39702335/article/details/110309294">[5]</span></a></sup>。</p><p>这些参数看起来很多很复杂，实际上只需要关注两件事。第一个是符号周期，这是由子载波间隔决定的；第二个是帧长度，这个是由5GNR标准规定的固定长度10ms。前者是最小单位，后者是最大单位。至于中间的时隙长度、符号个数等参数，就是在一个帧内对这么多个符号进行组合，至于怎么组合全看协议规定。</p><p>在OFDM接收端需要进行时域采样并FFT，这里涉及到两个参数：采样频率和FFT点数。采样频率<spanclass="math inline">\(f_s\)</span>由带宽<spanclass="math inline">\(B\)</span>决定，FFT点数<spanclass="math inline">\(N=2B\ast T_{\text{symbol}}=2B/\Deltaf\)</span>，因此FFT点数大约是子载波个数的2倍，和子载波间隔大小无直接关系。尽管如此，子载波间隔越大，符号周期越短，这就要求FFT在更短的时间内完成，并且同等子载波个数情况下信号带宽越大，采样频率越高，对处理器的速度要求越高。</p><p>4G以子帧为单位进行调度，而5G则以时隙为单位进行调度。</p><p>资源块（RB, Resource block）</p><p>还没太搞懂多用户的时频资源是怎么分配的，网上大多语焉不详。</p><h2 id="g-毫米波通信">5G 毫米波通信</h2><p>看到一篇博客（2019）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.edn.com/mmwave-and-ofdm-is-phy-research-dead/">[1]</span></a></sup>，讲的是5G mmWave的物理层信号PHYs（physicallayers）设计。主要观点是现有的物理层信号基本都是基于OFDM，但是当载频高于某个点之后，OFDM就不适合了，需要研究新的物理层信号。3GPP组织目前推出了Release15和16，频点都低于52.6GHz，在此频段下仍旧采用OFDM波形，但是超过某个频点（也许52.6GHz并不是确切的阈值点）之后，由于实际的物理器件难以实现OFDM信号所需的峰均比、增益平坦度和效率等，在更高频点上不得不设计新的物理信号波形。Nokia、NI等公司在73GHz频点上研究了2GHz带宽的单载波信号波形，在2信道MIMO系统中演示了14.6Gbps的吞吐量。另外802.11ad就是一个单载波调制的毫米波通信协议。</p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.edn.com/mmwave-and-ofdm-is-phy-research-dead/<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/jyqxerxes/article/details/78981109<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://blog.csdn.net/Angel_YJ/article/details/89001077<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/u010202588/article/details/94360185<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://blog.csdn.net/weixin_39702335/article/details/110309294<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/5G">5G- Wikipedia</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;g-lte&quot;&gt;4G LTE&lt;/h2&gt;
&lt;p&gt;采用OFDM调制，支持的带宽有（大带宽）10MHz、15MHz、20MHz，（窄带）1.4MHz、3MHz、5MHz。正常情况下子载波间隔15KHz，符号周期66.7us，加上循环前缀长度为71.35us。LTE在时域</summary>
      
    
    
    
    <category term="Communication and Networks" scheme="https://glooow1024.github.io/categories/Communication-and-Networks/"/>
    
    
    <category term="OFDM" scheme="https://glooow1024.github.io/tags/OFDM/"/>
    
    <category term="4G LTE" scheme="https://glooow1024.github.io/tags/4G-LTE/"/>
    
    <category term="5G NR" scheme="https://glooow1024.github.io/tags/5G-NR/"/>
    
    <category term="毫米波通信" scheme="https://glooow1024.github.io/tags/%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>信号调制与解调</title>
    <link href="https://glooow1024.github.io/2022/05/21/communication/modulation/"/>
    <id>https://glooow1024.github.io/2022/05/21/communication/modulation/</id>
    <published>2022-05-20T16:16:24.000Z</published>
    <updated>2022-06-23T03:14:12.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇文章的起因是我一直对数字调制和模拟调制这两个概念比较模糊，对于相应的通信系统结构也觉得比较混乱，所以在网上查了很多资料来理清楚这件事情。本文引用了诸多网络上的博客、文章中的文字和图片，引用之处都标注了参考出处，若有侵权请告知我，我会删除侵权部分。</p></blockquote><p>信号的调制简单来说，就是用基带信号去控制（调制）单频载波信号的某个或某几个参数，从而使得调制后的信号中嵌入了希望传递的信息<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html">[1]</span></a></sup>。这个载波往往是一个高频信号，便于传输。解调则是调制的逆过程。之所以要这么做是因为：1）高频信号更容易收发传输，天线尺寸需要是波长的1/4，使用高频信号可以减小天线尺寸；2）通过调制不同频率的载波信号，可以将基带信号搬移到不同频段的载波上，便于同时传输多路不同的基带信号<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/SilenceBurster/article/details/53126468">[2]</span></a></sup>。</p><h2 id="移动通信发展历史">1. 移动通信发展历史</h2><p>我们主要关注无线通信。移动通信最开始的目的是打电话，上世纪80年代出现了第一代（1G）移动通信网络，传输的是人的语音信号，1G使用模拟调制，多址技术为FDMA。当时使用的都是大哥大，采用模拟电路，因此手机都比较大，使用的频段在800MHz，所以天线长度大概要10cm，所以也能看到大哥大外面露出来的很长的天线，这个阶段摩托罗拉风光无限。传输速率只有2.4Kbps，要知道人的语音要想保证比较好的质量需要的速率是64Kbps，因此1G的语音通话质量也不太行<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/ziv669/article/details/122453973">[22]</span></a></sup>。</p><p>上世纪90年代，形成2G移动通信，大致可以分为两类，一类是基于TDMA的GSM标准，主要使用地区是我国和欧洲；另一类是基于CDMA的IS-95标准（也被称为cdmaOne），主要使用地区是美国。欧洲（芬兰）提出的通信标准GSM中采用了GMSK调制，而IS-95则采用QPSK和OQPSK调制，这三种都是数字调制，因此2G也将移动通信带入了数字时代。由于处理和传输的是数字信号，数字电路取代了模拟电路，能够集成在一个小小的芯片上，因此手机体积大大的减小了，诺基亚在这个阶段大杀四方。并且除了语音信号，其他的多媒体数据例如文字、图片也能传输了。GSM，工作在900MHz和1800MHz频点附近；CDMA工作在800MHz频点附近。2G移动通信，带宽有25MHz，峰值数据速率能达到14.4Kbps<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup><sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://baike.baidu.com/item/CDMAOne/7525860">[21]</span></a></sup>。</p><p>在2G和3G中间经过了2.5G，是二者的衔接，2.5G相比于2G提供了更高的速率和更多的功能。蓝牙等技术都是2.5G技术<sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="2.5G_百度百科(baidu.com)">[23]</span></a></sup>。</p><p>到3G时代，CDMA技术大行其道，作为CDMA技术的提出者，高通握着大量专利，简直是躺着赚钱。为了绕开高通的专利，欧洲日本联合起来成立了3GPP组织，提出了W-CDMA；中国搞了一个TD-SCDMA；高通与韩国组成3GPP2组织，推出了CDMA2000<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。前两个可以看作是从GSM演化而来；CDMA2000则是从IS-95继承而来。3G的工作频段在2100MHz附近，带宽有25MHz，上行链路采用BPSK调制，下行链路采用QPSK，数据速率能达到3.1Mbps<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Code-division_multiple_access">[19]</span></a></sup><sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup>。苹果2007年发布的iPhone也带动了3G的推广和发展。</p><p>在进入4G时代之前，插入一段关于WiFi和WiMax的历史。1999年，IEEE分别推出了802.11b与802.11a两种WiFi标准，分别使用2.4GHz和5GHz频段，彼此标准不相容。2003 年，IEEE引入正交频分复用技术(OFDM)，推出802.11b的改进版802.11g使传输速度从原先的11Mbps提升至54Mbps。现在我们使用的WiFi主要为802.11n，与802.11a、802.11b、802.11g皆兼容，并采用MIMO技术，使传输速度及距离都有所提升，速度甚至可达600Mbps<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>随着版图不断扩大，IT业巨头们开始觊觎起蜂窝移动通信市场大饼——4G。OFDM说起来也不是新技术，早在1960年代贝尔实验室发明OFDM后，技术框架约在1980年代便已建立完成。然而当时能支持OFDM的硬件不成熟，CDMA又由高通领军一时红火，便淘汰在3G标准之外。简单来说就是CDMA太红，如果Intel和IT大厂没有在WiFi上将OFDM技术发扬光大，电信业没有一家注意到早期不被重视的OFDM。由于WiMax的关系，OFDM才又重新进入电信业和学术界的视野中<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>2008年时，3GPP提出了长期演进技术 (Long Term Evolution, LTE)作为3.9G技术标准。又在2011年提出了长期演进技术升级版 (LTE-Advanced)作为4G技术标准，准备把W-CDMA汰换掉，转而采用OFDM。全球覆盖率最高的基站正是W-CDMA，因此，各大运营商无不纷纷决定采用LTE-Advanced当作第四代通信技术标准。如同高通败在W-CDMA基站的广覆盖上，LTE可兼容WCDMA，且利用现有基站配套设备，而WiMax基站却要从头建起，Intel也在2010年宣布放弃WiMax，加入LTE阵营<sup id="fnref:24" class="footnote-ref"><a href="#fn:24" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/zuochao_2013/article/details/78337600">[24]</span></a></sup>。</p><p>到4G时代，高通摆烂了，CDMA2000也没有后续向4G的演化，所以4G主要有两支，一个是从W-CDMA演化来的LTE-FDD/LTE-FDD-Advanced，另一个是从TD-SCDMA演化来的TD-LTE/TD-LTE-Advanced。4G采用的OFDM技术可以看成是多址技术，也可以看成是调制技术，实际上就是用多个相互正交的子载波同时传递多路数据，大大提高了频谱效率。FDD-LTE的工作频点在1800MHz附近，TD-LTE的工作频点在1890MHz、2350MHz、2600MHz附近，带宽有100MHz，数据速率可达100Mbps<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.zseries.in/telecom%20lab/telecom%20generations/">[20]</span></a></sup><sup id="fnref:26" class="footnote-ref"><a href="#fn:26" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://norstc.blog.csdn.net/article/details/80504263">[26]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/standard.jpg"alt="Mobile communication standards" /><figcaption aria-hidden="true">Mobile communicationstandards</figcaption></figure><h2 id="调制的分类">2. 调制的分类</h2><p>调制信号的大致分类如下图所示<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/Modulation_categorization.png"alt="Modulation_categorization" /><figcaption aria-hidden="true">Modulation_categorization</figcaption></figure><p>按照载波信号（也被称为被调信号）可以分为三类：正弦波调制、脉冲调制与强度调制。调制的载波分别是正弦波，脉冲和光波。</p><p>无线通信中一般使用的载波信号都是高频正弦波，而调制过程中改变的就是正弦波的3个参数：幅度、相位、频率<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html">[1]</span></a></sup>。也就是3种基本的调制方式：调幅（AM）、调相（PM）、调频（FM）。除此之外还有一些变异的调制方法，比如正交幅度调制（QAM），单边带调幅（SM）、残留边带调幅（SSB）等<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>。 <span class="math display">\[{\color{red}A_c} \cos(2\pi {\color{orange}f_c} t +{\color{blue}\varphi_c})\]</span>按照基带信号（也被称为调制信号）可以分为两类：模拟调制与数字调制。顾名思义，模拟调制中基带信号是模拟信号，数字调制中基带信号是数字信号。</p><p>模拟调制的中所控制的幅度、频率、相位参数是连续变化的，在解调的过程中也需要估计这个连续变化的波形；而数字调制中这些被改变的参数只是一些离散的值。模拟调制与数字调制各自的优缺点为<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/SilenceBurster/article/details/53126468">[2]</span></a></sup>：</p><table><thead><tr class="header"><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td><strong>数字调制</strong></td><td>抗干扰能力强；<br>易于加密，保密性强；<br>便于计算机对数字信息进行处理；<br>便于集成化。</td><td>需要较宽的频带；<br>进行数/摸转换时会带来量化误差；<br>要求的技术和设备复杂。</td></tr><tr class="even"><td><strong>模拟调制</strong></td><td>直观且容易实现；</td><td>保密性差，抗干扰能力差。</td></tr></tbody></table><p>调制的另一种分类方法是角度调制和幅度调制，其中角度调制包括调频和调相，幅度调制包括调幅AM、双边带调制DSB、单边带调制SSB、残留边带调制VSB和正交幅度调制QAM<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="Modulation -Wikipedia">[3]</span></a></sup>。</p><p>根据已调信号的频谱结构是否保留了原来消息信号的频谱模样，可以分为线性调制与非线性调制<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。幅度调制一般都是线性调制，角度调制都是非线性调制。</p><h2 id="解调的分类">3. 解调的分类</h2><p>相干解调与非相干解调。相干解调（也被称为同步检波）适用于所有线性调制信号的解调<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/m0_51288996/article/details/121340840">[4]</span></a></sup>。</p><h2 id="模拟调制与解调">4. 模拟调制与解调</h2><p>我们都假设基带信号是 <spanclass="math inline">\(m(t)\)</span>，载波频率是 <spanclass="math inline">\(f_c\)</span>，调制后的信号是 <spanclass="math inline">\(s(t)\)</span>。本部分主要参考了博客<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><h3 id="常规调幅am">4.1 常规调幅AM</h3><p>先将基带信号加上一个直流分量，然后乘以载波得到已调信号 <spanclass="math display">\[s(t) = (A_0 + m(t))\cos(2\pi f_c t)\]</span> 对应的波形和频谱如下图所示：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/AM.png"alt="AM" /><figcaption aria-hidden="true">AM</figcaption></figure><p>解调阶段只需要通过一个低通滤波器即可检出信号包络：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/AM-demodulation.png"alt="AM-demodulation" /><figcaption aria-hidden="true">AM-demodulation</figcaption></figure><h3 id="抑制载波的双边带调制dsb-sc">4.2 抑制载波的双边带调制DSB-SC</h3><p>上面的调幅方法由于直流的存在，会导致输出的已调信号中含有载波分量<spanclass="math inline">\(\cos(2\pi f_ct)\)</span>，抑制载波的双边带调制方法就是去除这个直流分量，也简称为双边带调制。<span class="math display">\[s(t) = m(t) \cos(2\pi f_c t)\]</span> <imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB.png"alt="DSB" /></p><p>由于DSB已调信号的包络不再与基带信号<spanclass="math inline">\(m(t)\)</span>成正比，因此不能使用包络检测器进行解调。通常采用的是相干解调。也就是在接收端生成一个与发送端同频同相的相关载波信号，与接收信号相乘，即可将接收信号频谱再搬到基带，通过低通滤波器后即可解调出基带信号。</p><table><thead><tr class="header"><th></th><th>调制</th><th>解调</th></tr></thead><tbody><tr class="odd"><td>系统框图</td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-modulation.png"alt="DSB-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-demodulation.png"alt="DSB-demodulation" /></td></tr><tr class="even"><td>频谱</td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-modulation-spectrum.png"alt="DSB-modulation-spectrum" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/DSB-demodulation-spectrum.png"alt="DSB-demodulation-spectrum" /></td></tr></tbody></table><h3 id="单边带调制ssb">4.3 单边带调制SSB</h3><p>前面的双边带调制基带信号是对称的，搬移到载波之后实际上有一半的频谱资源是浪费掉的，没有携带有效的信息，因此单边带调制就是在DSB的基础上，要去掉一半没用的频谱，节省频谱资源。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/SSB.png"alt="SSB" /><figcaption aria-hidden="true">SSB</figcaption></figure><p>上面通过低通滤波法获得单边带已调信号对滤波器有较高的要求，需要其在载频处具有陡峭的截止特性。这难以实现，因此实际中往往是通过项移法产生SSB信号，如下图所示，推导过程可以参考博客<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/SSB-modulation.png"alt="SSB-modulation" /><figcaption aria-hidden="true">SSB-modulation</figcaption></figure><h3 id="残留边带调制vsb">4.4 残留边带调制VSB</h3><p>单边带调制需要陡峭的低通滤波器，为了解决这个问题，残留边带调制的想法虽然理想的陡峭滤波器不可实现，但是圆滑滚降的滤波器还是可以的，那就用这样的滤波器。不过这样不能将其中一半的频谱去除干净，那么是否还能够解调出基带信号呢？也是可以的，不过这个滚降滤波器的频谱需要满足一定性质，也就是在载频处具有对称性<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114679288">[5]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB.png"alt="VSB" /><figcaption aria-hidden="true">VSB</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB-modulation-1.png"alt="VSB-modulation-1" /><figcaption aria-hidden="true">VSB-modulation-1</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/VSB-modulation-2.png"alt="VSB-modulation-2" /><figcaption aria-hidden="true">VSB-modulation-2</figcaption></figure><h3 id="调相pm与调频fm">4.5 调相PM与调频FM</h3><p>可以参考博客<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114694510">[6]</span></a></sup>。调频信号的包络恒定，而噪声往往是作用在信号幅度上，因此FM信号抗噪声能力强；但是FM信号需要占用较大的信号带宽，频谱利用率低。</p><h2 id="数字调制">5. 数字调制</h2><p>在开始本节之前，需要明晰的一点是，相比于模拟调制，数字调制当中“调制”的概念已经被扩展了。具体而言，在模拟调制当中，基带模拟信号与高频载波通过前面介绍的几种调制方式混合之后，得到的就直接是待发送的射频信号。而在数字调制中通常包含三个阶段：</p><ol type="1"><li>第一个阶段将二进制比特流映射为某种效率更高的数字信号（通常被称为码流），这个过程被称为基带调制；</li><li>第二个阶段将码流通过脉冲成型滤波器，将会突变的数字信号变成连续光滑的模拟信号，得到的就是基带信号；</li><li>第三个阶段将基带信号搬移到高频载波上，这个过程被称为载波调制/带通调制/射频调制。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/digital-communication-system-diagram.png"alt="digital-communication-system-diagram" /><figcaptionaria-hidden="true">digital-communication-system-diagram</figcaption></figure><p>在本节的几个子小节中，5.3IQ调制属于第三阶段载波调制，5.7脉冲成型滤波器属于第二阶段，其余的部分则属于第一阶段基带调制。为了讲述的方便以及前后逻辑的顺畅，这里将他们穿插起来，但是希望读者在脑海里能够明确他们在系统中的位置以及各自的作用。</p><blockquote><p>实际上，笔者在写本文之前对模拟和数字调制感到困惑、不理解也是源于此。</p></blockquote><h3 id="二进制数字调制">5.1 二进制数字调制</h3><p>最简单的数字调制系统中，基带信号是0-1二进制数字波形，通过控制开关实现对载波的调制，因此这里面的调幅AM、调相PM、调频FM也分别被称为幅度键控ASK/通-断键控OOK、相位键控PSK、频移键控FSK。他们各自图示如下<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.eecs.yorku.ca/course_archive/2010-11/F/3213/CSE3213_07_ShiftKeying_F2010.pdf">[8]</span></a></sup>：</p><table><thead><tr class="header"><th>2ASK</th><th>2PSK</th><th>2FSK</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2ASK.png"alt="2ASK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2PSK.png"alt="2PSK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/2FSK.png"alt="2FSK" /></td></tr></tbody></table><h3 id="多进制数字调制">5.2 多进制数字调制</h3><p>二进制数字调制中，每一个符号只能表示0-1两个数值，为了提高数据传输效率，可以在一个符号内传输更多的比特，从而提高频带利用率。简单来说就是把原来的0-1比特流进行分组，例如两个bit为一组映射到一个符号（symbol、码元）上，那么一个符号就有00,01, 11, 10这4种取值，再去调制：</p><ul><li>幅度：0，1，2，3这4个振幅；</li><li>相位：0，<span class="math inline">\(\pi/2\)</span>，<spanclass="math inline">\(\pi\)</span>，<spanclass="math inline">\(3\pi/2\)</span>这4个相位；</li><li>频率：4个不同的载波频率。</li></ul><p>想要传输的信号从bit流映射为了symbol流，symbol同样是只有有限个离散的取值，这个时候引入星座图会更直观更方便。什么是星座图呢？首先我们传输的正弦信号可以表示为一个复信号的实部，也就是<span class="math display">\[{A_c} \cos(2\pi {f_c} t + {\varphi_c}) = \operatorname{Re}\{{\color{blue}A_c \exp(\varphi_c)}\exp (2\pi {f_c} t)\}\]</span> 可以看到无论是调制信号幅度还是相位，都是在单频载波<spanclass="math inline">\(\exp(2\pi f_c t)\)</span>上乘以了一个复幅度<spanclass="math inline">\(A_c\exp(\varphi_c)\)</span>。因此如果是幅度或者相位调制，那么我们只需要看这个复幅度就得到了想要传输的信息（symbol流）。一个复数可以映射为一个x-y二维平面上的点，那么如果我们把所有的symbol取值画出来，那么就是多个离散的点，就像是星座一样，故名星座图。BPSK（也就是2PSK）、QPSK（也就是4PSK）和8PSK示意图如下<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.zhihu.com/p/58119209">[9]</span></a></sup><sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-MPSK.jpg"alt="constellation-MPSK" /><figcaption aria-hidden="true">constellation-MPSK</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/QPSK-BPSK.png"alt="QPSK-BPSK" /><figcaption aria-hidden="true">QPSK-BPSK</figcaption></figure><p>其实QPSK还有另外一种方式，就是星座图旋转45°<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114735043">[7]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-QPSK2.png"alt="constellation-QPSK2" /><figcaption aria-hidden="true">constellation-QPSK2</figcaption></figure><p>除了MPSK，幅度也是可以控制的，例如下面这个16APSK<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Amplitude_and_phase-shift_keying">[10]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/constellation-16APSK.png"alt="constellation-16APSK" /><figcaption aria-hidden="true">constellation-16APSK</figcaption></figure><p>不过这里有一个问题就是：我们实际系统中只能产生实信号，而这里转换到复数域虽然看起来很简洁，但是实际系统如何实现呢？答案就是用两路信号，分别表示复信号的实部和虚部，也就是I路（In-phase）和Q路（Quadrature）。这就引出了下面的正交幅度调制QAM。</p><h3 id="iq调制">5.3 IQ调制</h3><p>说白了IQ调制就是把复的基带信号搬移到高频载波上，仅此而已。前面我们已经提到了symbol可以用复数表示，那么我们要传输的码流就是一个复基带信号，记为<spanclass="math inline">\(s_0(t) = a(t) + j b(t)\)</span>，其中 <spanclass="math inline">\(a(t)\)</span> 和 <spanclass="math inline">\(b(t)\)</span>分别是实部和虚部，那么调制信号可以表示为 <span class="math display">\[s(t) = \operatorname{Re}\{s_0(t) \exp(2\pi f_c t)\} = a(t)\cos(2\pi f_ct) - b(t) \sin(2\pi f_c t)\]</span> 在信号发射阶段，I路的基带信号就是<spanclass="math inline">\(a(t)\)</span>，将其乘以<spanclass="math inline">\(\cos(2\pi f_ct)\)</span>，Q路的基带信号是<spanclass="math inline">\(b(t)\)</span>，将其乘以<spanclass="math inline">\(\sin(2\pi f_ct)\)</span>，再将二者求和即可得到要发送的已调信号。可以参考我之前的一篇博客<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/">[11]</span></a></sup>，系统框图如下<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-i-q-signals-and-quadrature-modulation/">[12]</span></a></sup><sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-quadrature-demodulation/">[13]</span></a></sup>：</p><table><thead><tr class="header"><th>IQ调制</th><th>IQ解调</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/diagram-IQ-modulation.jpg"alt="diagram-IQ-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/diagram-IQ-demodulation.jpg"alt="diagram-IQ-demodulation" /></td></tr></tbody></table><p>IQ调制在数学上是如此的漂亮，实际系统中又是如此的方便好用，因此在现代无线通信系统中几乎是必备的。后面介绍的各种基带调制方式也基本都会配合IQ调制来使用。</p><h3 id="正交幅度调制qam">5.4 正交幅度调制QAM</h3><p>有了IQ调制，我们只需要分别控制I、Q两路基带信号的幅度，就能得到星座图上任意一个点，所以各种MPSK、MASK以及MAPSK等都能通过这种方式获得，这种调制方式也被称为正交幅度调制QAM。</p><p>其实也不难发现QPSK实际上就是两路（载波）相互正交的BPSK，实际上也是4QAM。</p><h3 id="偏移四相位键控offset-qpsk">5.5 偏移四相位键控Offset-QPSK</h3><p>在一般的QPSK基础上有一些变种，比如OQPSK，与QPSK的区别就在于I、Q两路的码流在时间上错开了半个码元周期，这样可以避免出现两个支路同时出现极性翻转的情况，好处是：1）避免180°的相位跳变，这种情况下最多只有90°相位跳变；2）避免I、Q两路信号同时过零点，降低信号峰均比PAR<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/weixin_50912862/article/details/114735043">[7]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/QPSK-drawback.png"alt="QPSK-drawback" /><figcaption aria-hidden="true">QPSK-drawback</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OQPSK.png"alt="OQPSK" /><figcaption aria-hidden="true">OQPSK</figcaption></figure><p>除此之外，还有其他的变种，例如<spanclass="math inline">\(\pi/4\)</span>-QPSK等，不再赘述。</p><h3 id="最小频移键控msk">5.6 最小频移键控MSK</h3><p>前面介绍的不管是二进制还是多进制，码流信号都认为是矩形波，实际上这种矩形波性能并不好。因为矩形波从时域来看会导致相位跳变，波形不光滑、不连续，从频域来看就是矩形波旁瓣幅度较大，会出现频谱扩展，对相邻信道产生干扰。为了解决这个问题，那就把矩形波换掉！换成边缘光滑的波形！</p><p>最小频移键控MSK（Minimum-shiftkeying）可以看成是一种特殊的OQPSK，把原来的矩形方波换成半正弦波。如果从另一个角度来看，也可以认为是频率分离为比特率二分之一的连续相位频移键控CP-BFSK（一般通过开关实现的FSK信号在边沿处也会出现波形不连续，而MSK中波形/相位总是连续的）。如下图所示<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="MinimumShift Keying (MSK) - A Tutorial - Qasim Chaudhari">[15]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-class.png"alt="MSK-class" /><figcaption aria-hidden="true">MSK-class</figcaption></figure><p>那么他的数学原理是什么样的呢？首先从时域来看，实际上就是将OQPSK中的矩形方波换成半正弦波，这样相邻码元的相位变化就为0。如下图所示<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup><sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://ppt-online.org/1039280">[17]</span></a></sup>，一个脉冲的宽度为<spanclass="math inline">\(2T\)</span>，正弦波的周期为<spanclass="math inline">\(4T\)</span>。</p><table><thead><tr class="header"><th>MSK对比O-QPSK</th><th>MSK的波形是连续的</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-OQPSK.png"alt="MSK-OQPSK" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-half-sin.png"alt="MSK-half-sin" /></td></tr></tbody></table><p>用三角函数表示出来就是<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup> <span class="math display">\[s(t) = a_I(t)\cos(\frac{\pi t}{2T}) \cos(2\pi f_c t) -a_Q(t)\sin(\frac{\pi t}{2T})\sin(2\pi f_c t)\]</span> 其中<span class="math inline">\(a_I(t),a_Q(t)\)</span>还是矩形方波，<span class="math inline">\(\cos(\pi t/2T),\sin(\pi t/ 2T)\)</span>就是周期为<spanclass="math inline">\(4T\)</span>的正弦波，一个码元周期内半个正弦波。对这个式子应用三角恒等式，就能得到<span class="math display">\[\begin{aligned}s(t) &amp;= \cos\left( 2\pi f_c t + b_k(t)\frac{\pi t}{2T} + \phi_k\right) \\b_k(t) &amp;= \begin{cases} 1, &amp; a_I(t)=a_Q(t) \\ -1, &amp;\text{others} \end{cases} \\\phi_k &amp;= \begin{cases} 0, &amp; a_I(t)=1 \\ \pi, &amp;\text{others} \end{cases}\end{aligned}\]</span>从频域来看，MSK是频率分离为比特率二分之一的连续相位频移键控CPFSK，也就是在一般的BFSK基础上，MSK的两个载波频率间隔恰好是码元波特率的二分之一。假设FSK的两个载波频率为<spanclass="math inline">\(f_1,f_2\)</span>，码元周期为<spanclass="math inline">\(2T\)</span>，由于一个码元可以传输2个比特，因此波特率为<spanclass="math inline">\(1/T\)</span>，那么就有<spanclass="math inline">\(|f_1-f_2| = 1/2T\)</span>。</p><p>从频谱来看，MSK的旁瓣幅度相比于BPSK和QPSK也更低，因此， MSK情况下的信道间干扰较低<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-spectrum.png"alt="MSK-spectrum" /><figcaption aria-hidden="true">MSK-spectrum</figcaption></figure><p>发射接收机如下图所示<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/">[16]</span></a></sup>，解调也需要相干载波。</p><table><thead><tr class="header"><th>发射机</th><th>接收机</th></tr></thead><tbody><tr class="odd"><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-modulation.png"alt="MSK-modulation" /></td><td><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/MSK-demodulation.png"alt="MSK-demodulation" /></td></tr></tbody></table><h3 id="脉冲成型滤波器">5.7 脉冲成型滤波器</h3><p>MSK当中将矩形波换成了半正弦波，在实现的时候直接用一个正弦波发生器加上开关就可以了，但如果我们想换成其他形状的光滑波形呢？就没有这么简单了，这里就引出了数字传输中的脉冲成型滤波器。</p><p>数字调制之后得到的码流是矩形波，从时域来看存在跳变，从频域来看频谱宽度无穷大，这在实际系统当中是不可能实现的，原因是我们无法生成跳变的信号，并且信道和收发机的通带也不是无穷带宽的。因此我们需要将码流脉冲转化为模拟信号，这个模拟信号从时域来看是连续光滑的，从频域来看是带限的，如下图所示<sup id="fnref:29" class="footnote-ref"><a href="#fn:29" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://wirelesspi.com/pulse-shaping-filter/">[29]</span></a></sup>。思路很简单，将码流脉冲通过一个脉冲成型滤波器，输出信号就是滤波器冲激响应的叠加。不过关键的问题在于这个脉冲成型滤波器要怎么设计？</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/rectangular-sa.png"alt="rectangular-sa" /><figcaption aria-hidden="true">rectangular-sa</figcaption></figure><p>设计的关键在于不能有符号间串扰（Inter Symbol Interference,ISI）。什么意思呢？频域带限会导致时域扩展，要想当前码元对相邻的码元没有干扰，如下图所示<sup id="fnref:30" class="footnote-ref"><a href="#fn:30" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://dsp.stackexchange.com/questions/36340/nyquist-criterion-for-zero-isi">[30]</span></a></sup>，需要其时域波形在相邻码元的采样时刻幅值为0，这就是Nyquist准则。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/zero-ISI.png"alt="zero-ISI" /><figcaption aria-hidden="true">zero-ISI</figcaption></figure><p>记经过基带调制的复码流为 <span class="math inline">\(\{a_k\}\)</span>，码元间隔（采样周期）为 <spanclass="math inline">\(T_s\)</span>，脉冲成型滤波器的冲激响应为 <spanclass="math inline">\(g(t)\)</span>，那么脉冲成型之后的模拟基带信号为<span class="math display">\[s_0(t) = \sum_{k=-\infty}^{\infty} a_k g(t-kT_s)\]</span> 对应的Nyquist无码间串扰条件即为： <spanclass="math display">\[g(kT_s) = \begin{cases}1, &amp; k=0 \\ 0, &amp; k\ne 0 \end{cases}\]</span> 等价的频域条件为（<spanclass="math inline">\(G(f)\)</span>为<spanclass="math inline">\(g(t)\)</span>的傅里叶变换）<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Nyquist_ISI_criterion">[31]</span></a></sup>： <span class="math display">\[\frac{1}{T_s} \sum_{k=-\infty}^{\infty} G\left(f-\frac{k}{T_S}\right) =1, \forall f\]</span> 实际系统中常用的就是升余弦滤波器（Raised CosineFilter），不同滚降系数的RC滤波器频谱如下图所示<sup id="fnref:31" class="footnote-ref"><a href="#fn:31" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Nyquist_ISI_criterion">[31]</span></a></sup>，他两侧的边沿是余弦曲线。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/raised-cosine-filter.png"alt="raised-cosine-filter" /><figcaption aria-hidden="true">raised-cosine-filter</figcaption></figure><p>除此之外还有Sinc filter（频谱是理想矩形），Gaussianfilter（时域冲激响应是高斯的PDF）。第二代移动通信标准GSM中就采用高斯滤波器。</p><h3 id="高斯最小频移键控gmsk">5.8 高斯最小频移键控GMSK</h3><p>终于到了GMSK，其被应用于GSM通信标准、蓝牙、卫星通信当中。GMSK是在MSK的基础上，为了改善信号的旁瓣衰减性能，增加了一个高斯滤波器进行整形<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://en.wikipedia.org/wiki/Minimum-shift_keying">[14]</span></a></sup>。其实现方式可以是首先将基带码流通过高斯滤波器得到高斯脉冲，然后再通过MSK调制器。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-spectrum.png"alt="GMSK-spectrum" /><figcaption aria-hidden="true">GMSK-spectrum</figcaption></figure><p>系统框图如下所示<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996)."&gt;[18]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-diagram.png"alt="GMSK-diagram" /><figcaption aria-hidden="true">GMSK-diagram</figcaption></figure><p>下面的图片当中<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996)."&gt;[18]</span></a></sup>，第一行是已调信号相位轨迹随着非归零码序列（-1,-1,-1,+1,+1,-1,+1,+1,+1,+1,-1,+1,-1,+1,-1,-1）的变化，可以看到GMSK输出的信号相位变化更加平缓。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/GMSK-phase.png"alt="GMSK-phase" /><figcaption aria-hidden="true">GMSK-phase</figcaption></figure><h3 id="正交频分复用ofdm">5.9 正交频分复用OFDM</h3><p>OFDM本身又是一个非常精妙的调制技术。简单来理解，就是同时传输多路IQ调制的信号，不同路的载波频率不同，在一个符号周期内他们相互正交，互不干扰。</p><p>再详细一点的解释。首先对于IQ调制来说，I、Q两路本身是相互正交的，但是他们的载波还是位于同一个频点上，把两路放在一起看就是把基带信号的复频谱搬移到单一载波频点上<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/">[11]</span></a></sup>。而OFDM可以理解为在N个不同的载波频点上，并行传输了N个这样的IQ调制信号。需要注意这些子载波也不是随意选取的，需要满足在一个符号周期内的正交性，子载波之间不能有干扰。示意图如下<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/madongchunqiu/article/details/18614233">[27]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OFDM-parallel.png"alt="OFDM-parallel" /><figcaption aria-hidden="true">OFDM-parallel</figcaption></figure><p>但是实际系统中直接这样实现会有很多麻烦，所以人们想出了一种非常巧妙的办法。要传输的串行二进制比特流首先转化为N路并行的比特流，每一路比特流在经过QAM映射为码流，这些码流控制了不同频点载波的复幅度，所以同一时刻不同支路的码元，实际上就是要发送信号的频谱，那么对这些系数进行IFFT，我们就把他们从频域变换到了时域，N路并行的码元映射为了1路串行的N个时刻的（复）信号，然后再将得到时域波形实部和虚部送入一个IQ调制，即可得到要发送的射频信号。示意图如下<sup id="fnref:27" class="footnote-ref"><a href="#fn:27" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/madongchunqiu/article/details/18614233">[27]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/OFDM-FFT.png"alt="OFDM-FFT" /><figcaption aria-hidden="true">OFDM-FFT</figcaption></figure><p>OFDM的系统框图如下所示<sup id="fnref:28" class="footnote-ref"><a href="#fn:28" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://ecse.monash.edu/staff/eviterbo/OTFS-VTC18/Tutorial_ICC2019___OTFS_modulation.pdf">[28]</span></a></sup>：</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/OFDM.jpg"alt="OFDM" /><figcaption aria-hidden="true">OFDM</figcaption></figure><p>除此之外，OFDM中还包括了循环前缀以及其他细节的设计，在这里不再详细展开了，可以参考网上相关资料。LTE中OFDM采用的调制方式最高能达到256QAM，NR中能达到1024QAM<sup id="fnref:25" class="footnote-ref"><a href="#fn:25" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/m0_52840978/article/details/123674928">[25]</span></a></sup>。</p><h2 id="数字解调">6. 数字解调</h2><p>解调是调制的逆过程，所以数字解调也包括三个阶段：</p><ol type="1"><li>第一阶段将信号从载波频段搬回到基带，如果调制的时候采用的是IQ调制，那么解调就采用IQ解调就好了；</li><li>第二阶段从模拟的基带波形中恢复出数字信号，最佳接收方案为匹配滤波并以<spanclass="math inline">\(1/T_s\)</span>的频率进行采样；</li><li>第三阶段从数字信号中解调出原本想传输的比特流，需要根据星座图对得到的采样进行判决。</li></ol><h2 id="总结">7. 总结</h2><p>QAM和IQ调制yyds！OFDM yyds!</p><h2 id="reference">Reference</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://www.ni.com/zh-cn/innovations/white-papers/06/analog-and-digital-modulation.html<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>https://blog.csdn.net/SilenceBurster/article/details/53126468<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Modulation">Modulation- Wikipedia</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/m0_51288996/article/details/121340840<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114679288<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114694510<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7"class="footnote-text"><span>https://blog.csdn.net/weixin_50912862/article/details/114735043<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://www.eecs.yorku.ca/course_archive/2010-11/F/3213/CSE3213_07_ShiftKeying_F2010.pdf<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9"class="footnote-text"><span>https://zhuanlan.zhihu.com/p/58119209<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10"class="footnote-text"><span>https://en.wikipedia.org/wiki/Amplitude_and_phase-shift_keying<a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:11"class="footnote-text"><span>https://glooow1024.github.io/2021/08/29/communication/IQ-modulation/<a href="#fnref:11" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:12"class="footnote-text"><span>https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-i-q-signals-and-quadrature-modulation/<a href="#fnref:12" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:13"class="footnote-text"><span>https://www.allaboutcircuits.com/textbook/radio-frequency-analysis-design/radio-frequency-demodulation/understanding-quadrature-demodulation/<a href="#fnref:13" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:14"class="footnote-text"><span>https://en.wikipedia.org/wiki/Minimum-shift_keying<a href="#fnref:14" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:15"class="footnote-text"><span><a href="https://www.dsprelated.com/showarticle/1016.php">MinimumShift Keying (MSK) - A Tutorial - Qasim Chaudhari</a><a href="#fnref:15" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:16"class="footnote-text"><span>http://www.dsplog.com/2009/06/16/msk-transmitter-receiver/<a href="#fnref:16" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:17"class="footnote-text"><span>https://ppt-online.org/1039280<a href="#fnref:17" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:18" class="footnote-text"><span>Turletti, Thierry. "GMSK ina nutshell." Telemedia Networks and Systems Group LCS, MIT-TR(1996).<a href="#fnref:18" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:19"class="footnote-text"><span>https://en.wikipedia.org/wiki/Code-division_multiple_access<a href="#fnref:19" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:20"class="footnote-text"><span>https://www.zseries.in/telecom%20lab/telecom%20generations/<a href="#fnref:20" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:21"class="footnote-text"><span>https://baike.baidu.com/item/CDMAOne/7525860<a href="#fnref:21" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:22"class="footnote-text"><span>https://blog.csdn.net/ziv669/article/details/122453973<a href="#fnref:22" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:23"class="footnote-text"><span><a href="https://baike.baidu.com/item/2.5G/1192973">2.5G_百度百科(baidu.com)</a><a href="#fnref:23" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:24"class="footnote-text"><span>https://blog.csdn.net/zuochao_2013/article/details/78337600<a href="#fnref:24" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:25"class="footnote-text"><span>https://blog.csdn.net/m0_52840978/article/details/123674928<a href="#fnref:25" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:26"class="footnote-text"><span>https://norstc.blog.csdn.net/article/details/80504263<a href="#fnref:26" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:27"class="footnote-text"><span>https://blog.csdn.net/madongchunqiu/article/details/18614233<a href="#fnref:27" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:28" class="footnote-text"><span>https://ecse.monash.edu/staff/eviterbo/OTFS-VTC18/Tutorial_ICC2019___OTFS_modulation.pdf<a href="#fnref:28" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:29"class="footnote-text"><span>https://wirelesspi.com/pulse-shaping-filter/<a href="#fnref:29" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:30"class="footnote-text"><span>https://dsp.stackexchange.com/questions/36340/nyquist-criterion-for-zero-isi<a href="#fnref:30" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:31"class="footnote-text"><span>https://en.wikipedia.org/wiki/Nyquist_ISI_criterion<a href="#fnref:31" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写这篇文章的起因是我一直对数字调制和模拟调制这两个概念比较模糊，对于相应的通信系统结构也觉得比较混乱，所以在网上查了很多资料来理清楚这件事情。本文引用了诸多网络上的博客、文章中的文字和图片，引用之处都标注了参考出处，若有侵权请告知我，我会删除侵权</summary>
      
    
    
    
    <category term="Communication and Networks" scheme="https://glooow1024.github.io/categories/Communication-and-Networks/"/>
    
    
    <category term="IQ调制" scheme="https://glooow1024.github.io/tags/IQ%E8%B0%83%E5%88%B6/"/>
    
    <category term="调制与解调" scheme="https://glooow1024.github.io/tags/%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83/"/>
    
    <category term="移动通信" scheme="https://glooow1024.github.io/tags/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/"/>
    
    <category term="模拟调制" scheme="https://glooow1024.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/"/>
    
    <category term="数字调制" scheme="https://glooow1024.github.io/tags/%E6%95%B0%E5%AD%97%E8%B0%83%E5%88%B6/"/>
    
    <category term="QAM" scheme="https://glooow1024.github.io/tags/QAM/"/>
    
    <category term="OFDM" scheme="https://glooow1024.github.io/tags/OFDM/"/>
    
  </entry>
  
  <entry>
    <title>IEEE论文爬虫及数据统计</title>
    <link href="https://glooow1024.github.io/2022/03/19/diy/paper-collector/"/>
    <id>https://glooow1024.github.io/2022/03/19/diy/paper-collector/</id>
    <published>2022-03-19T05:51:48.000Z</published>
    <updated>2022-05-01T09:52:53.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ieee论文爬虫">1. IEEE论文爬虫</h2><p>爬虫代码网上有很多了，这部分是直接用的网上可以跑通的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/wp7xtj98/article/details/112711465">[1]</span></a></sup>。使用的时候直接调用<code>get_article_info()</code>，其中参数 <code>conferenceID</code>需要手动在 IEEE 上查询会议的 ID 号，参数 <code>saceFileName</code>为希望保存的 <code>csv</code> 文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取issueNumber</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_issueNumber</span>(<span class="hljs-params">conferenceID</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Get the issueNumber from the website.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    conferenceID = <span class="hljs-built_in">str</span>(conferenceID)<br>    gheaders = &#123;<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/xpl/conhome/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/proceeding&#x27;</span>,<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&#x27;</span><br>    &#125;<br>    md_url = <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/rest/publication/home/metadata?pubid=&#x27;</span>+conferenceID<br>    md_res = requests.get(md_url, headers = gheaders)<br>    md_dic = json.loads(md_res.text)<br>    issueNumber = <span class="hljs-built_in">str</span>(md_dic[<span class="hljs-string">&#x27;currentIssue&#x27;</span>][<span class="hljs-string">&#x27;issueNumber&#x27;</span>])<br>    <span class="hljs-keyword">return</span> issueNumber<br><br><span class="hljs-comment"># 爬取论文及其下载链接</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">conferenceID, saveFileName</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Collect the published paper data, and save into the csv file &quot;saveFileName&quot;.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获取issueNumber</span><br>    issueNumber = <span class="hljs-built_in">str</span>(get_issueNumber(conferenceID))<br>    conferenceID = <span class="hljs-built_in">str</span>(conferenceID)<br><br>    <span class="hljs-comment"># 记录论文数据</span><br>    dataframe = pd.DataFrame(&#123;&#125;)<br>    paper_title = []<br>    paper_author = []<br>    paper_year = []<br>    paper_citation = []<br>    paper_abstract = []<br>    paper_ieee_kwd = []<br><br>    <span class="hljs-comment"># 从第一页开始下载</span><br>    pageNumber = <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>        <span class="hljs-comment"># 获取会议文章目录</span><br>        toc_url = <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/rest/search/pub/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/issue/&#x27;</span>+issueNumber+<span class="hljs-string">&#x27;/toc&#x27;</span><br>        payload = <span class="hljs-string">&#x27;&#123;&quot;pageNumber&quot;:&#x27;</span>+<span class="hljs-built_in">str</span>(pageNumber)+<span class="hljs-string">&#x27;,&quot;punumber&quot;:&quot;&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;&quot;,&quot;isnumber&quot;:&#x27;</span>+issueNumber+<span class="hljs-string">&#x27;&#125;&#x27;</span><br>        headers = &#123;<br>            <span class="hljs-string">&#x27;Host&#x27;</span>: <span class="hljs-string">&#x27;ieeexplore.ieee.org&#x27;</span>,<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36&#x27;</span>,<br>            <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://ieeexplore.ieee.org/xpl/conhome/&#x27;</span>+conferenceID+<span class="hljs-string">&#x27;/proceeding?pageNumber=&#x27;</span>+<span class="hljs-built_in">str</span>(pageNumber),<br>        &#125;<br>        toc_res = requests.post(toc_url, headers = headers, data=payload)<br>        toc_dic = json.loads(toc_res.text)<br>        <span class="hljs-keyword">try</span>:<br>            articles = toc_dic[<span class="hljs-string">&#x27;records&#x27;</span>]<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> articles:<br>                title = article[<span class="hljs-string">&#x27;highlightedTitle&#x27;</span>]<br>                paper_link = IEEE_root_url + article[<span class="hljs-string">&#x27;htmlLink&#x27;</span>]<br>                paper_info = requests.get(url=paper_link, headers=headers, timeout=<span class="hljs-number">10</span>)<br>                soup = BeautifulSoup(paper_info.text, <span class="hljs-string">&#x27;lxml&#x27;</span>)                  <span class="hljs-comment"># 解析</span><br>                <span class="hljs-comment"># 正则表达式 创建模式对象</span><br>                pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;xplGlobal.document.metadata=(.*?)&quot;&#125;;&#x27;</span>, re.MULTILINE | re.DOTALL)<br>                script = soup.find(<span class="hljs-string">&quot;script&quot;</span>, text=pattern)                     <span class="hljs-comment"># 根据模式对象进行搜索</span><br>                <span class="hljs-keyword">try</span>:<br>                    res_dic = pattern.search(script.string).group(<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;&quot;&#125;&#x27;</span>      <span class="hljs-comment"># 配合search找到字典，匹配结尾字符串，降低文章摘要中也出现这种字符串的概率</span><br>                    <span class="hljs-comment"># 解析异常，一般是因为文章 abstract 中出现了字符串 &#x27;&quot;&#125;;&#x27;</span><br>                    json_data = json.loads(res_dic)                            <span class="hljs-comment"># 将json格式数据转换为字典</span><br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(pattern.search(script.string).group(<span class="hljs-number">0</span>))<br>                    <span class="hljs-built_in">print</span>(res_dic)<br>                <span class="hljs-comment"># 保存文章信息</span><br>                paper_title.append(title)<br>                paper_year.append(json_data[<span class="hljs-string">&#x27;publicationYear&#x27;</span>])<br>                <span class="hljs-built_in">print</span>(json_data.keys())<br>                <span class="hljs-comment">#a = input(&#x27;input anything...&#x27;)</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;author&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_author.append(json_data[<span class="hljs-string">&#x27;author&#x27;</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    paper_author.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;abstract&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_abstract.append(json_data[<span class="hljs-string">&#x27;abstract&#x27;</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    paper_abstract.append(<span class="hljs-literal">None</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;keywords&#x27;</span> <span class="hljs-keyword">in</span> json_data.keys():<br>                    paper_ieee_kwd.append(json_data[<span class="hljs-string">&#x27;keywords&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;kwd&#x27;</span>])       <span class="hljs-comment"># ieee有三种 key words</span><br>                <span class="hljs-keyword">else</span>:<br>                    paper_ieee_kwd.append(<span class="hljs-literal">None</span>)<br>                count=count+<span class="hljs-number">1</span><br>                <span class="hljs-comment">#link = &#x27;https://ieeexplore.ieee.org/stampPDF/getPDF.jsp?tp=&amp;arnumber=&#x27;+article[&#x27;articleNumber&#x27;]+&#x27;&amp;ref=&#x27;</span><br>                <span class="hljs-comment">#alf.write(title.replace(&#x27;\n&#x27;,&#x27;&#x27;)+&#x27;&gt;_&lt;&#x27;+link+&#x27;\n&#x27;)</span><br>            <br>            <span class="hljs-comment"># 写入csv文件</span><br>            dataframe = pd.DataFrame(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:paper_title, <span class="hljs-string">&#x27;year&#x27;</span>:paper_year, <span class="hljs-string">&#x27;abstract&#x27;</span>:paper_abstract, <span class="hljs-string">&#x27;key words&#x27;</span>:paper_ieee_kwd&#125;)<br>            dataframe.to_csv(saveFileName, index=<span class="hljs-literal">True</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Page &#x27;</span>, pageNumber, <span class="hljs-string">&#x27;, total &#x27;</span>, count, <span class="hljs-string">&#x27;papers.&#x27;</span>)<br>            pageNumber = pageNumber+<span class="hljs-number">1</span><br>            <span class="hljs-comment"># 停一下防禁ip</span><br>            <span class="hljs-keyword">import</span> time<br>            time.sleep(<span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment"># 写入csv文件</span><br>    dataframe = pd.DataFrame(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:paper_title, <span class="hljs-string">&#x27;year&#x27;</span>:paper_year, <span class="hljs-string">&#x27;abstract&#x27;</span>:paper_abstract, <span class="hljs-string">&#x27;key words&#x27;</span>:paper_ieee_kwd&#125;)<br>    dataframe.to_csv(saveFileName, index=<span class="hljs-literal">True</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="ieee论文数据统计">2. IEEE论文数据统计</h2><h2 id="写一个图形界面">3. 写一个图形界面</h2><h3 id="弹出提示窗口">3.1 弹出提示窗口</h3><p>在写代码过程中有时候需要测试功能是否成功实现，于是想要加一个弹出窗口的函数可以显示调试信息，用以验证想要的功能是否正常实现。主要难点在于根据内容自动调整窗口大小，以获得较好的显示效果。</p><p>采用的方法是利用 <code>QLabel.adjust()</code>函数获取文本显示的宽度，并据此调整窗口的大小<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> (QWidget, QDialog, QLabel, QPushButton)<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> (QSize, QRect)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.dialog_btn = QPushButton(<span class="hljs-string">&#x27;Click&#x27;</span>)<br>        self.dialog_btn.clicked.connect(self.click_callback)<br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">click_callback</span>(<span class="hljs-params">self</span>):</span><br>        self.show_dialog(<span class="hljs-string">&#x27;You clicked me!&#x27;</span>)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_dialog</span>(<span class="hljs-params">self, info</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Pop up dialogs for debug.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        hint_dialog = QDialog()<br>        hint_dialog.setWindowTitle(<span class="hljs-string">&#x27;Hint info&#x27;</span>)<br>        <span class="hljs-comment">#hint_dialog.setWindowModality(PyQt6.QtCore.Qt.NonModal)</span><br><br>        hint_info = QLabel(info, hint_dialog)<br>        hint_info.adjustSize()<br>        padding = <span class="hljs-number">20</span><br>        max_width = <span class="hljs-number">360</span><br>        <span class="hljs-comment"># set the maximum width</span><br>        <span class="hljs-keyword">if</span> hint_info.size().width() &gt; max_width:<br>            hint_info.setGeometry(QRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, max_width, <span class="hljs-number">80</span>))<br>            hint_info.setWordWrap(<span class="hljs-literal">True</span>)<br>        hint_info.move(padding, padding)<br><br>        hint_dialog.resize(hint_info.size() + QSize(padding*<span class="hljs-number">2</span>, padding*<span class="hljs-number">2</span>))<br>        hint_dialog.<span class="hljs-built_in">exec</span>()<br></code></pre></td></tr></table></figure><h3 id="文本框显示爬取日志">3.2 文本框显示爬取日志</h3><p>我希望在窗口中增加一个文本框，将爬取过程中的日志信息打印出来，便于用户实时监测。</p><p>采用的思路是定义一个<code>logging.Logger</code>，将其日志信息同时输出到窗口的文本框和控制台中打印，通过自定义<code>logging.Handler</code>可以实现这一功能<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://zhuanlan.gitbook.io/p/360306588">[3]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://stackoverflow.com/questions/41176319/python-logging-output-on-both-gui-and-console">[5]</span></a></sup><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://stackoverflow.com/questions/24371274/how-to-dynamically-update-qtextedit">[6]</span></a></sup>。实现方式为：</p><ol type="1"><li><p>继承 <code>logging.Handler</code>类，并初始化阶段将整个窗口(<code>QWidget</code>类)作为参数传入，便于后续修改窗口的信息；</p></li><li><p>自定义实现 <code>emit</code> 函数，在 <code>emit</code> 函数中将log 信息同时输出到窗口文本框、打印到控制台；</p></li><li><p>创建 <code>logger</code> 的时候设置Handler<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/qq_37541097/article/details/108317762">[4]</span></a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ex = PaperCollector()<br>logger = logging.getLogger(<span class="hljs-string">&quot;logger&quot;</span>)<br>handler = LogHandler(ex)<br>logger.addHandler(handler)<br></code></pre></td></tr></table></figure></li></ol><p>下面是这部分功能相关的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogHandler</span>(<span class="hljs-params">logging.Handler</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.parent = parent<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">emit</span>(<span class="hljs-params">self, record</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">print</span>(self.<span class="hljs-built_in">format</span>(record))<br>            self.parent.print_log(self.<span class="hljs-built_in">format</span>(record))<br>            QApplication.processEvents()<br>        <span class="hljs-keyword">except</span> Exception:<br>            self.handleError(record)<br>            <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the UI playout.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># button to start crawing</span><br>        self.startCrawling_button = QPushButton(<span class="hljs-string">&#x27;Start&#x27;</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;Click and wait for collecting published paper data.&#x27;</span>)<br>        self.startCrawling_button.clicked.connect(self.start_collect_paper)<br>        <span class="hljs-comment"># print log</span><br>        self.process = QTextEdit(readOnly=<span class="hljs-literal">True</span>)<br>        self.process.setFont(QFont(<span class="hljs-string">&quot;Source Code Pro&quot;</span>,<span class="hljs-number">9</span>))<br>        <br>        grid = QGridLayout()<br>        grid.setSpacing(<span class="hljs-number">10</span>)<br>        grid.addWidget(self.startCrawling_button, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>        grid.addWidget(self.process, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>        self.setLayout(grid)<br>        <br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">700</span>, <span class="hljs-number">300</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">global</span> logger<br>        <span class="hljs-comment">#self.show_dialog(&#x27;start!&#x27;)</span><br>        get_article_info(self.conferenceID_edit.text(), self.saveFile_edit.text(), logger)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_log</span>(<span class="hljs-params">self, s</span>):</span><br>        self.process.append(s)<br>        <br>logger = <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    app = QApplication(sys.argv)<br>    ex = PaperCollector()<br><br>    <span class="hljs-keyword">global</span> logger<br>    logger = logging.getLogger(<span class="hljs-string">&quot;logger&quot;</span>)<br>    logger.setLevel(logging.INFO)<br>    formater = logging.Formatter(fmt=<span class="hljs-string">&quot;%(asctime)s [%(levelname)s] : %(message)s&quot;</span><br>                ,datefmt=<span class="hljs-string">&quot;%Y/%m/%d %H:%M:%S&quot;</span>)<br>    handler = LogHandler(ex)<br>    handler.setFormatter(formater)<br>    logger.addHandler(handler)<br><br>    sys.exit(app.<span class="hljs-built_in">exec</span>())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>爬取论文的主函数如下，其中一个参数为<code>logger</code>，在函数内部需要打印日志信息的地方添加<code>logger.info(...)</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">conferenceID, saveFileName, logger</span>):</span><br>    logger.info(<span class="hljs-string">&#x27;collecting paper......&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="多线程避免卡顿">3.3 多线程避免卡顿</h3><p>上述打印日志的方法不能做到实时输出信息到窗口文本框，而是会等到所有论文爬取完毕之后再一股脑的更新，这是因为PyQt的界面线程是主线程，当爬虫开始工作时，也是运行在主线程中，这时主界面就无法更新，看起来就像是卡死了。解决方法就是开一个子线程运行爬虫工作<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客"&gt;[7]</span></a></sup>。</p><p>具体实现细节为：</p><ol type="1"><li>新建类 <code>SpiderThread</code> 继承 <code>QObject</code>，自定义<code>run</code> 函数，在其中运行爬虫程序；</li><li>在 <code>SpiderThread</code> 类中定义一个<code>_spider_finish = pyqtSignal()</code>，该信号用于告知主线程爬虫子线程已完成工作</li><li>在 <code>PaperCollector</code> 类中定义一个<code>_start_spider = pyqtSignal(str, str, logging.Logger)</code>，该信号用于启动爬虫子线程<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/gong_xufei/article/details/89786272">[8]</span></a></sup><sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="https://blog.csdn.net/qq_39560620/article/details/105711799">[9]</span></a></sup>；</li><li>通过 <code>pyqtSignal.connect</code>分别将各个信号连接到对应的槽（处理函数）上；</li></ol><p>下面是这部分功能相关的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> (QObject, pyqtSignal, QThread)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderThread</span>(<span class="hljs-params">QObject</span>):</span><br>    _spider_finish = pyqtSignal()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.flag_running = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt; __del__&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, conference_ID, save_filename, logger</span>):</span><br>        get_article_info(conference_ID, save_filename, logger)<br>        self._spider_finish.emit()<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    _start_spider = pyqtSignal(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, logging.Logger)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.initUI()<br>        <span class="hljs-comment">#sys.stdout = LogStream(newText=self.onUpdateText)</span><br><br>        self.spiderT = SpiderThread()<br>        self.thread = QThread(self)<br>        self.spiderT.moveToThread(self.thread)<br>        self._start_spider.connect(self.spiderT.run)        <span class="hljs-comment"># 只能通过信号槽启动线程处理函数</span><br>        self.spiderT._spider_finish.connect(self.finish_collect_paper)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        <br>        self.startCrawling_button.setEnabled(<span class="hljs-literal">False</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;I\&#x27;m trying very hard to collect papers &gt;_&lt;&#x27;</span>)<br>        <span class="hljs-comment"># 先启动QThread子线程</span><br>        self.thread.start()<br>        <span class="hljs-comment"># 发送信号，启动线程处理函数</span><br>        <span class="hljs-comment"># 不能直接调用，否则会导致线程处理函数和主线程是在同一个线程，同样操作不了主界面</span><br>        <span class="hljs-keyword">global</span> logger<br>        self._start_spider.emit(self.conferenceID_edit.text(), self.saveFile_edit.text(), logger)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        self.startCrawling_button.setEnabled(<span class="hljs-literal">True</span>)<br>        self.startCrawling_button.setToolTip(<span class="hljs-string">&#x27;Click and wait for collecting published paper data ^o^&#x27;</span>)<br>        self.thread.quit()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        self.thread.quit()      <span class="hljs-comment"># 退出</span><br>        self.thread.wait()      <span class="hljs-comment"># 回收资源</span><br>        self.show_dialog(<span class="hljs-string">&#x27;stop!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="流畅中止子线程">3.4 流畅中止子线程</h3><p>有时候我们需要中途停止爬虫工作，比如发现会议ID设置错误、希望先对已经爬取的部分数据进行统计分析等。在上面的实现中，尽管线程正常运行很流畅，但是如果在爬虫运行中途点击停止按钮，程序就会卡死。</p><p>在原本的爬虫脚本中，<code>get_article_info()</code>函数内部的爬虫采用了 <code>while(True)</code> 死循环，主线程中直接用<code>self.thread.quit()</code>强制退出，从控制台来看这样确实可以停掉，但是Qt窗口却总是会卡死。原因我也不太清楚，采用的解决方法是：</p><ol type="1"><li>定义一个爬虫类 <code>IEEESpider</code>，设置成员变量<code>flag_running</code>，将函数 <code>get_article_info</code>也设置为类成员函数；</li><li>将 <code>get_article_info</code> 中的循环改为<code>while(self.flag_running)</code>；</li><li>在主线程中想要停止爬虫子线程的时候，只需要首先设置<code>flag_running=False</code>，那么爬虫子线程在当前一次循环结束后就自动结束，这个时候主线程调用<code>self.thread.quit()</code> 就不会导致界面卡死。需要注意的是设置<code>flag_running=False</code> 一定要 <code>sleep</code>一段时间，以保证爬虫子线程能够结束当前循环，否则还是容易卡死。</li></ol><p>下面是这部分功能的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IEEESpider</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.flag_running = <span class="hljs-literal">False</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_article_info</span>(<span class="hljs-params">self, conferenceID, saveFileName, logger</span>):</span><br>        <span class="hljs-keyword">while</span>(self.flag_running):<br>            <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpiderThread</span>(<span class="hljs-params">QObject</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment">#self.flag_running = False</span><br>        self.ieee_spider = IEEESpider()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, conference_ID, save_filename, logger</span>):</span><br>        self.ieee_spider.flag_running = <span class="hljs-literal">True</span><br>        self.ieee_spider.get_article_info(conference_ID, save_filename, logger)<br>        self._spider_finish.emit()<br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop_collect_paper</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.thread.isRunning():<br>            <span class="hljs-keyword">return</span><br>        self.spiderT.ieee_spider.flag_running = <span class="hljs-literal">False</span><br>        time.sleep(<span class="hljs-number">15</span>)<br>        self.thread.quit()      <span class="hljs-comment"># 退出</span><br>        <span class="hljs-comment">#self.thread.wait()      # 回收资源</span><br>        self.show_dialog(<span class="hljs-string">&#x27;stop!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="增加侧边导航栏">3.5 增加侧边导航栏</h3><p>前面只有爬取论文的页面，现在我想加上数据分析的页面，那么就需要设置一个侧边导航栏，以切换两种不同的任务。</p><p>实现方式为左侧设置多个按钮，右侧添加一个<code>QTabWidget()</code>，将不同的页面设置为子标签页，通过按钮的点击回调函数切换不同的标签页<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperCollector</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebarUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the UI playout of sidebar.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.sidebar_btn_1 = QPushButton(<span class="hljs-string">&#x27;Collector&#x27;</span>, self)<br>        self.sidebar_btn_1.clicked.connect(self.sidebar_button_1)<br>        self.sidebar_btn_2 = QPushButton(<span class="hljs-string">&#x27;Analyzer&#x27;</span>, self)<br>        self.sidebar_btn_2.clicked.connect(self.sidebar_button_2)<br>        self.sidebar_btn_3 = QPushButton(<span class="hljs-string">&#x27;Reserved&#x27;</span>, self)<br>        self.sidebar_btn_3.clicked.connect(self.sidebar_button_3)<br><br>        sidebar_layout = QVBoxLayout()<br>        sidebar_layout.addWidget(self.sidebar_btn_1)<br>        sidebar_layout.addWidget(self.sidebar_btn_2)<br>        sidebar_layout.addWidget(self.sidebar_btn_3)<br>        sidebar_layout.addStretch(<span class="hljs-number">5</span>)<br>        sidebar_layout.setSpacing(<span class="hljs-number">20</span>)<br><br>        self.sidebar_widget = QWidget()<br>        self.sidebar_widget.setLayout(sidebar_layout)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_1</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_2</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sidebar_button_3</span>(<span class="hljs-params">self</span>):</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">2</span>)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Define the overall UI playout.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.sidebarUI()<br>        self.spiderUI()<br>        self.analyzerUI()<br>        self.reservedUI()<br>        <br>        <span class="hljs-comment"># 多个标签页</span><br>        self.right_widget = QTabWidget()<br>        self.right_widget.tabBar().setObjectName(<span class="hljs-string">&quot;mainTab&quot;</span>)<br><br>        self.right_widget.addTab(self.spider_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br>        self.right_widget.addTab(self.analyzer_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br>        self.right_widget.addTab(self.reserved_widget, <span class="hljs-string">&#x27;&#x27;</span>)<br><br>        <span class="hljs-comment"># 隐藏标签部件的标签并初始化显示页面</span><br>        self.right_widget.setCurrentIndex(<span class="hljs-number">0</span>)<br>        self.right_widget.setStyleSheet(<span class="hljs-string">&#x27;&#x27;&#x27;QTabBar::tab&#123;width: 0; height: 0; margin: 0; padding: 0; border: none;&#125;&#x27;&#x27;&#x27;</span>)<br><br>        <span class="hljs-comment"># overall layout</span><br>        main_layout = QHBoxLayout()<br>        main_layout.addWidget(self.sidebar_widget)<br>        main_layout.addWidget(self.right_widget)<br>        main_layout.setStretch(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)<br>        main_layout.setStretch(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>)<br>        self.setLayout(main_layout)<br><br>        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">850</span>, <span class="hljs-number">300</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;IEEE paper collector (by Glooow)&#x27;</span>)<br>        self.show()<br></code></pre></td></tr></table></figure><h3 id="next-...">3.6 next ...</h3><p>接下来考虑：写数据分析页面 ......</p><h1 id="referencce">Referencce</h1><p>这里关于参考文献的部分，本来我想按照下面格式来写，希望实现的效果是都像<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>一样，每一条引用列出来的是超链接，而不是直接写出来链接地址，但是我发现除了第<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt中文教程 (gitbook.io)">[2]</span></a></sup><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded" aria-label="PyQt5侧边栏布局 • Chang Luo (luochang.ink)">[10]</span></a></sup>条，其他条这么写话都会像现在的第<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="<ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客"&gt;[7]</span></a></sup>条一样，格式会乱，也不知道为什么。有人知道的话可以告诉我嘛&gt;_&lt;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">[^<span class="hljs-number">1</span>]:[Python爬虫——爬取IEEE论文 - 乐 ShareLe的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/wp7xtj98/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">112711465</span>)<br>[^<span class="hljs-number">2</span>]:[PyQt 中文教程 (gitbook.io)](https:<span class="hljs-regexp">//m</span>aicss.gitbook.io<span class="hljs-regexp">/pyqt-chinese-tutoral/</span>)<br>[^<span class="hljs-number">3</span>]:[python日志：logging模块使用 - 知乎](https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">360306588</span>)<br>[^<span class="hljs-number">4</span>]:[python3 自定义logging.Handler, Formatter, Filter模块 - 太阳花的小绿豆的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_37541097/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">108317762</span>)<br>[^<span class="hljs-number">5</span>]:[python logging output on both GUI and console - stackoverflow](https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">41176319</span>/python-logging-output-on-both-gui-and-console)<br>[^<span class="hljs-number">6</span>]:[How to dynamically update QTextEdit - stackoverflow](https:<span class="hljs-regexp">//</span>stackoverflow.com<span class="hljs-regexp">/questions/</span><span class="hljs-number">24371274</span>/how-to-dynamically-update-qtextedit)<br>[^<span class="hljs-number">7</span>]:[PyQt - 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/bailang_zhizun/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">109240670</span>)<br>[^<span class="hljs-number">8</span>]:[pyqt 带单个参数<span class="hljs-regexp">/多个参数信号&amp;槽总结 - gong xufei的博客 - CSDN博客](https:/</span><span class="hljs-regexp">/blog.csdn.net/g</span>ong_xufei<span class="hljs-regexp">/article/</span>details/<span class="hljs-number">89786272</span>)<br>[^<span class="hljs-number">9</span>]:[PyQt5 pyqtSignal: 自定义信号传入的参数方法 - Mic28的博客 - CSDN博客](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_39560620/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">105711799</span>)<br>[^<span class="hljs-number">10</span>]:[PyQt5 侧边栏布局 • Chang Luo (luochang.ink)](https:<span class="hljs-regexp">//</span>www.luochang.ink<span class="hljs-regexp">/posts/</span>pyqt5_layout_sidebar/)<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>https://blog.csdn.net/wp7xtj98/article/details/112711465<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://maicss.gitbook.io/pyqt-chinese-tutoral/">PyQt中文教程 (gitbook.io)</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>https://zhuanlan.gitbook.io/p/360306588<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span>https://blog.csdn.net/qq_37541097/article/details/108317762<a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5"class="footnote-text"><span>https://stackoverflow.com/questions/41176319/python-logging-output-on-both-gui-and-console<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6"class="footnote-text"><span>https://stackoverflow.com/questions/24371274/how-to-dynamically-update-qtextedit<a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><ahref="https://blog.csdn.net/bailang_zhizun/article/details/109240670">PyQt- 使用多线程避免界面卡顿 - bailang zhizun的博客 - CSDN博客</a><a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8"class="footnote-text"><span>https://blog.csdn.net/gong_xufei/article/details/89786272<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9"class="footnote-text"><span>https://blog.csdn.net/qq_39560620/article/details/105711799<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10"class="footnote-text"><span><a href="https://www.luochang.ink/posts/pyqt5_layout_sidebar/">PyQt5侧边栏布局 • Chang Luo (luochang.ink)</a><a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ieee论文爬虫&quot;&gt;1. IEEE论文爬虫&lt;/h2&gt;
&lt;p&gt;爬虫代码网上有很多了，这部分是直接用的网上可以跑通的&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span</summary>
      
    
    
    
    <category term="DIY" scheme="https://glooow1024.github.io/categories/DIY/"/>
    
    
    <category term="spider" scheme="https://glooow1024.github.io/tags/spider/"/>
    
    <category term="PyQt" scheme="https://glooow1024.github.io/tags/PyQt/"/>
    
    <category term="多线程" scheme="https://glooow1024.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SLAM综述</title>
    <link href="https://glooow1024.github.io/2022/03/02/research/SLAM-survey/"/>
    <id>https://glooow1024.github.io/2022/03/02/research/SLAM-survey/</id>
    <published>2022-03-02T03:14:56.000Z</published>
    <updated>2022-03-03T10:57:13.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于SLAM（simultaneous localization andmapping）问题一个很粗糙的总结。</p></blockquote><p>对于SLAM的发展历程，Leonard和Reid大佬将SLAM到目前为止的发展过程总结为三个阶段：</p><ol type="1"><li>classicalage（1986-2004）：早期阶段，SLAM问题的定义、基于概率框架的建模和求解方法；</li><li>algorithm-analysisage（2004-2015）：深入研究SLAM问题的一些性质，比如稀疏性、收敛性、一致性等，更多样、更高效的算法也被相继提出；</li><li>robust-perceptionage（2015-）：开始考虑算法的鲁棒性、可扩展性、资源约束下的高效算法、高层语义认知任务导向等；</li></ol><p>SALM系统主要包括前端和后端两部分，前端负责从传感器数据中提取特征、dataassociation（如特征提取、回环检测）等，后端负责最大后验估计、滤波等；</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/slam-1.png"alt="SLAM" /><figcaption aria-hidden="true">SLAM</figcaption></figure><p>根据<strong>感知手段</strong>可以分为几类：</p><ul><li>测距测角：传感器比如毫米波雷达、声纳等；</li><li>视觉相机：各种相机，比如RGB-D相机等；需要从图像中提取特征点，例如SIFT等；纯视觉导航有专门的研究方向，即VO（VisualOdometry），VO+全局地图优化（例如回环检测）=visual SLAM；</li><li>激光雷达；</li><li>惯性导航：IMU，配合视觉传感器可以实现VIO；</li></ul><p>根据<strong>地图结构</strong>可以分为几类（地图结构与感知手段紧密相关）：</p><ul><li>基于landmarkd的，传感器通常是测距测角的，或者视觉中提取特征点；</li><li>栅格地图（2D）、点云地图（3D），主要是激光雷达；</li><li>基于边/表面的几何地图；</li></ul><p>根据<strong>求解方法</strong>可以分为几类：</p><ul><li>基于贝叶斯框架递归滤波的：如EKF、PF、Information Filter等；</li><li>基于优化的：一种是光束平差法（用于视觉，实际上是最小二乘）；另一种是图优化（graphSLAM，实际上就是概率图模型，似乎是现在的主流）；</li><li>Set Membership 类的方法、以及定性方法等；</li></ul><p>要考虑的科学问题包括：</p><ul><li>地图构建和机器人位姿估计，因此实际上是参数估计/求解问题；</li><li>多传感器数据融合，以及与已有地图信息的融合；</li><li>回环检测，纠正累积误差；</li><li>降低复杂度，比如每次只更新相关的部分地图和状态，而不是所有参数一起更新；</li><li>数据关联；</li></ul><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2022/slam-2.jpg"alt="SLAM" /><figcaption aria-hidden="true">SLAM</figcaption></figure><p>除了基本的SLAM问题，还有一些发展方向：</p><ul><li>ActiveSLAM：同时考虑机器人的运动控制，与exploration-exploitation问题相关；</li><li>多机SLAM，相比于单机需要考虑的问题：<ul><li>多机协作的架构：集中式（online or offline？）、分布式；</li><li>相邻机器之间的数据交互，防止数据伦理问题，即一个数据在多个机器上重复使用多次；</li><li>每个机器的地图更新方法；</li><li>数据关联问题；</li><li>通信负载、数据压缩、地图结构优化等；</li></ul></li></ul><h2 id="reference">Reference</h2><ol type="1"><li>Dissanayake, MWM Gamini, et al. "A solution to the simultaneouslocalization and map building (SLAM) problem." <em>IEEE Transactions onrobotics and automation</em> 17.3 (2001): 229-241.</li><li>Durrant-Whyte, Hugh, and Tim Bailey. "Simultaneous localization andmapping: part I." <em>IEEE robotics &amp; automation magazine</em> 13.2(2006): 99-110.</li><li>Bailey, Tim, and Hugh Durrant-Whyte. "Simultaneous localization andmapping (SLAM): Part II." <em>IEEE robotics &amp; automationmagazine</em> 13.3 (2006): 108-117.</li><li>Bresson, Guillaume, et al. "Simultaneous localization and mapping: Asurvey of current trends in autonomous driving." <em>IEEE Transactionson Intelligent Vehicles</em> 2.3 (2017): 194-220.</li><li>Taketomi, Takafumi, Hideaki Uchiyama, and Sei Ikeda. "Visual SLAMalgorithms: A survey from 2010 to 2016." <em>IPSJ Transactions onComputer Vision and Applications</em> 9.1 (2017): 1-11.</li><li>Cadena, Cesar, et al. "Past, present, and future of simultaneouslocalization and mapping: Toward the robust-perception age." <em>IEEETransactions on robotics</em> 32.6 (2016): 1309-1332.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于SLAM（simultaneous localization and
mapping）问题一个很粗糙的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于SLAM的发展历程，Leonard和Reid大佬将SLAM到目前为止的发展过程总</summary>
      
    
    
    
    <category term="Research" scheme="https://glooow1024.github.io/categories/Research/"/>
    
    
    <category term="SLAM" scheme="https://glooow1024.github.io/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>我的电脑（不时更新）</title>
    <link href="https://glooow1024.github.io/2022/01/24/software/prepare-my-pc/"/>
    <id>https://glooow1024.github.io/2022/01/24/software/prepare-my-pc/</id>
    <published>2022-01-24T14:32:33.000Z</published>
    <updated>2022-02-21T01:05:53.362Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了电脑，很多软件都要重装，遂记录一下自己电脑常用的软件。</p><h2 id="日常必备">1. 日常必备</h2><ul><li><strong>通讯类</strong>：微信、TIM、Foxmail；</li><li><strong>办公类</strong>：Office、Onenote、Foxit、腾讯会议；</li><li><strong>浏览器</strong>：Edge、Chrome；</li><li><strong>影音娱乐</strong>：网易云音乐、PotPlayer、Irfan View；</li><li><strong>其他</strong>：WinRAR、KeePass2；</li></ul><h2 id="学习科研">2. 学习科研</h2><ul><li><strong>编程</strong>：VSCode、Matlab、Python、Emeditor、Git；</li><li><strong>阅读器</strong>：知云文献翻译、Pdf Xodo、CAJ Viewer；</li><li><strong>写作</strong>：Typora、Texlive + Summatra、Mathpix SnippingTool、IguanaTex（ppt插件）、Aurora（word插件）；</li><li><strong>云盘</strong>：百度云盘、Seafile、坚果云；</li></ul><h2 id="效率工具">3. 效率工具</h2><ul><li>MobaXterm：远程连接工具；</li><li>向日葵：远程桌面；</li><li>Everything：文件搜索；</li><li>Calibre：电子书阅读器；</li><li>Beyond Compare：文本文件对比；</li><li>Space Sniffer：磁盘空间统计；</li><li>Captura：录屏；</li><li>Hexo：个人静态博客（需要nodejs，最好装个nvm）；</li><li>Pic Go：图床管理工具；</li><li>Gitbook：个人书籍；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近换了电脑，很多软件都要重装，遂记录一下自己电脑常用的软件。&lt;/p&gt;
&lt;h2 id=&quot;日常必备&quot;&gt;1. 日常必备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通讯类&lt;/strong&gt;：微信、TIM、Foxmail；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;办公类&lt;/st</summary>
      
    
    
    
    <category term="Software" scheme="https://glooow1024.github.io/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>【高等数值分析】Krylov子空间方法</title>
    <link href="https://glooow1024.github.io/2022/01/24/advanced-numerical-analysis/ada-krylov/"/>
    <id>https://glooow1024.github.io/2022/01/24/advanced-numerical-analysis/ada-krylov/</id>
    <published>2022-01-24T13:35:19.000Z</published>
    <updated>2022-01-24T09:37:22.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>现在需要求解一个大规模稀疏方程组 <spanclass="math inline">\(Ax=b\)</span>，可以用迭代法比如 Jacobi迭代法、Gauss-Seidel 迭代法等，不过这一节要讨论的是 Krylov子空间方法，核心部分是 Arnoldi 迭代。</p><span id="more"></span><h3 id="krylov-子空间">1.1 Krylov 子空间</h3><p><strong>定理（Cayley-Hamilton）</strong>：设 <spanclass="math inline">\(A\in{\mathbb C}^{n\times n}\)</span>，则 <spanclass="math inline">\(A\)</span> 的特征多项式 <spanclass="math inline">\(\chi(z)\)</span> 是 <spanclass="math inline">\(A\)</span> 的零化多项式，也即 <spanclass="math inline">\(\chi(A)=0\)</span>。</p><p>假设特征多项式 <span class="math inline">\(\chi(z)=z^n +c_{n-1}z^{n-1} + \cdots + c_1 z+ c_0=(-1)^n\operatorname{det}(A)\)</span>，那么根据 <spanclass="math inline">\(\chi(A)=0\)</span> 可以得到 <spanclass="math display">\[A^{-1} = -\frac{1}{c_0} A^{n-1} - \frac{c_{n-1}}{c_0} A^{n-2} + \cdots-\frac{c_1}{c_0} I = q_{n-1}(A)\]</span> 利用这个等式，在求解线性方程组的时候，给定任意初值 <spanclass="math inline">\(x_0\)</span>，都有 <spanclass="math inline">\(Ax^{\ast}-Ax_0=b-Ax_0 \equiv r_0\)</span>，于是<span class="math inline">\(x^{\ast} = x_0 +q_{n-1}(A)r_0\)</span>，因此理论上可以在空间 <spanclass="math display">\[\mathcal{K}=\left\{\boldsymbol{r}_{0}, A \boldsymbol{r}_{0}, \cdots,A^{m} \boldsymbol{r}_{0}, \cdots, A^{n-1} \boldsymbol{r}_{0}\right\}\]</span> 中找到方程组的准确解，但是科学与工程计算问题中 <spanclass="math inline">\(n\)</span> 可以达到 <spanclass="math inline">\(10^6\)</span>量级，直接求解代价太高。因此希望在其一个低维子空间中搜索近似解。</p><p>定义 <span class="math inline">\(m\)</span> 维 <strong>Krylov子空间</strong>为 <span class="math display">\[\mathcal{K}_{m}=\operatorname{span}\left(\boldsymbol{r}_{0}, A\boldsymbol{r}_{0}, A^{2} \boldsymbol{r}_{0}, \cdots, A^{m-1}\boldsymbol{r}_{0}\right)\]</span> 方程组求解问题转化为 <span class="math display">\[\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} - x\Vert.\]</span></p><h3 id="最佳逼近">1.2 最佳逼近</h3><p>现在的问题就是在何种范数意义下求解问题 <spanclass="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} -x\Vert\)</span>。假设 <span class="math inline">\({\mathcalK}_m\)</span> 的一组基作为列向量构成矩阵 <spanclass="math inline">\(V_m\)</span>，最优解为 <spanclass="math inline">\(x_m = x_0 + V_m y^{\ast} \in x_0 + {\mathcal K}_m,~ y^{\ast}\in{\mathbb R}^{m}\)</span>。</p><h4 id="方法一最佳平方逼近">1.2.1 方法一：最佳平方逼近</h4><p>取 <span class="math inline">\(2\)</span> 范数 <spanclass="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \Vert x^{\ast} -x\Vert_2\)</span>，那么根据最佳平方逼近条件（对<spanclass="math inline">\(x\)</span>求导，取零点），或者 <strong>Galerkin正交条件</strong>，可以推出<strong>法方程</strong>为 <spanclass="math display">\[\begin{align}&amp;\langle x^{\ast} - x_m, y \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; V_m^{\rm T}(x^{\ast}-x_m) = 0\end{align}\]</span> 但是这个方法<strong>不可行</strong>！因为要求 <spanclass="math inline">\(x_m\)</span> 就需要知道 <spanclass="math inline">\(x^{\ast}\)</span>。</p><h4 id="方法二假设-a-对称正定">1.2.2 方法二：假设 <spanclass="math inline">\(A\)</span> 对称正定</h4><p>若 <span class="math inline">\(A\)</span>对称正定，那么可以改求解问题 <span class="math inline">\(\min_{x\inx_0+{\mathcal K}_m} \langle A(x-x^{\ast}),x-x^{\ast}\rangle\)</span>，根据<strong>Galerkin正交条件</strong>有法方程 <span class="math display">\[\begin{align}&amp;\langle A(x^{\ast} - x_m), y \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; r_m = A(x^{\ast}-x_m) \perp {\mathcal K}_m \\\iff &amp; V_m^{\rm T}(r_0 - Ax_m) = 0\end{align}\]</span>这个方法<strong>可行</strong>！后面需要做两件事情：1）求出一组基 <spanclass="math inline">\(V_m\)</span>；2）解法方程。</p><blockquote><p><strong>Note</strong>：这里为了得到法方程，需要假设 <spanclass="math inline">\(A\)</span> 对称正定。但是在后面的 FOM 方法中，不论<span class="math inline">\(A\)</span> 是否正定，都基于 Galerkin条件直接采用了这一法方程来求解线性方程组。至于这么做是否有理论支持我也不太清楚，就姑且相信它是合理的。</p></blockquote><h4 id="方法三残差2范数">1.2.3 方法三：残差2范数</h4><p>当 <span class="math inline">\(A\)</span> 非奇异，不去求解 <spanclass="math inline">\(\min \Vert x^{\ast} - x\Vert\)</span>，而是求解<span class="math inline">\(\min_{x\in x_0+{\mathcal K}_m} \VertA(x^{\ast} - x)\Vert_2\)</span>，那么再次根据 <strong>Galerkin条件</strong>，可以导出<strong>法方程</strong> <spanclass="math display">\[\begin{align}&amp;\langle A(x^{\ast} - x_m), Ay \rangle = 0, ~ \forall y\in {\mathcalK}_m \\\iff &amp; r_m = A(x^{\ast}-x_m) \perp A{\mathcal K}_m \\\iff &amp; V_m^{\rm T}A^{\rm T}(r_0 - Ax_m) = 0\end{align}\]</span> 这个方法也是<strong>可行</strong>的。</p><p>不论如何，上面几种方法最后都归结为两个问题：</p><ol type="1"><li>获得 <span class="math inline">\({\mathcal K}_m\)</span> 的基底<span class="math inline">\(V_m\)</span>：Gram-Schmidt 正交化方法；</li><li>求解法方程，并且计算残差：低维线性方程组求解。</li></ol><h2 id="基底正交化">2. 基底正交化</h2><p>获得正交基底的方法主要有 Arnoldi 过程（CGS）、改进 Arnoldi过程（MGS）、以及 Lanczos 过程。名字起的很fancy，别被吓到，其实他们都只是 Gram-Schmidt 正交化方法。</p><h3 id="arnoldi-过程cgs">2.1 Arnoldi 过程（CGS）</h3><p>迭代过程可以归结为 <span class="math display">\[\begin{aligned}\boldsymbol{v}_{1} &amp;= \boldsymbol{r}_{0} / \Vert \boldsymbol{r}_{0}\Vert \\\boldsymbol{w}_{j} &amp;=A \boldsymbol{v}_{j}-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{1}\rangle \boldsymbol{v}_{1}-\langleA \boldsymbol{v}_{j},\boldsymbol{v}_{2}\rangle  \boldsymbol{v}_{2}-\cdots-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{j}\rangle \boldsymbol{v}_{j} \\\boldsymbol{v}_{j+1}&amp;=\frac{\boldsymbol{w}_{j}}{\left\|\boldsymbol{w}_{j}\right\|_{2}},j=1,2, \cdots \\h_{i,j} &amp;= \langle A \boldsymbol{v}_{j}, \boldsymbol{v}_{i}\rangle\end{aligned}\]</span> 得到的 <span class="math inline">\(\{ v_1, v_2, ..., v_m,...,v_n \}\)</span> 是单位正交基。由 <spanclass="math inline">\(h_{i,j}\)</span> 作为元素构成矩阵 <spanclass="math inline">\(H_m \in {\mathbb R}^{m\times m}\)</span>，可以验证<span class="math inline">\(H_m\)</span> 为 Hessenberg 阵，并且 <spanclass="math inline">\(h_{i+1,i}=\Vert \boldsymbol{w}_{i}\Vert_2\)</span>。在 <span class="math inline">\(H_m\)</span>的基础上可以定义 <span class="math inline">\(\bar{H}_m \in {\mathbbR}^{(m+1)\times m}\)</span>，也就是在最后一行下面再加一行 <spanclass="math inline">\([0,...,0,h_{m+1,m}]\)</span>。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-cgs.png"alt="CGS-psudocode" /><figcaption aria-hidden="true">CGS-psudocode</figcaption></figure><p>可以验证他们满足如下等式，这三个式子在后面会频繁用到，极其重要！<span class="math display">\[\begin{align}AV_m &amp;= V_m H_m + \boldsymbol{w}_{m} \boldsymbol{e}_{m}^{\rm T} \\&amp;= V_{m+1} \bar{H}_m \\V_m^{\rm T} A V_m &amp;= H_m\end{align}\]</span> <imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-arnoldi.png"alt="Arnoldi" /></p><h3 id="改进-arnoldi-过程mgs">2.2 改进 Arnoldi 过程（MGS）</h3><p>前面的 Arnoldi 过程在计算 <spanclass="math inline">\(\boldsymbol{w}_{j}\)</span> 的时候，相当于把 <spanclass="math inline">\(A \boldsymbol{v}_{j}\)</span> 分别计算了 <spanclass="math inline">\(j\)</span> 次投影，每次都是向一个一维的子空间<span class="math inline">\(\operatorname{span}\{ \boldsymbol{v}_{i}\}\)</span>投影，可能会有计算不稳定的问题。对其进行改进的方法如下，交换顺序之后，每次都是向一个<span class="math inline">\(n-1\)</span> 维子空间投影。</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-mgs.png"alt="MGS-psudocode" /><figcaption aria-hidden="true">MGS-psudocode</figcaption></figure><h3 id="lanczos过程">2.3 Lanczos过程</h3><p>是 Arnoldi 过程的特殊情况，当 <span class="math inline">\(A=A^{\rmT}\)</span>，那么 <span class="math inline">\(H_m\)</span>为三对角矩阵，那么 <spanclass="math inline">\(\boldsymbol{w}_{j}\)</span> 的计算简化为 <spanclass="math display">\[\boldsymbol{w}_{j} = A \boldsymbol{v}_{j}-\langle A \boldsymbol{v}_{j},\boldsymbol{v}_{j-1}\rangle \boldsymbol{v}_{j-1}-\langle A\boldsymbol{v}_{j}, \boldsymbol{v}_{j}\rangle \boldsymbol{v}_{j}\]</span></p><h2 id="方程组求解">3. 方程组求解</h2><p>针对上面几种不同的迭代过程，可以有不同的求解方法。</p><h3 id="全正交方法-fom">3.1 全正交方法 (FOM)</h3><p>FOM (Full orthogonalization method) 根据 Galerkin 条件，<spanclass="math inline">\(r_m\perp {\mathcal K}_m\)</span>，根据法方程 <spanclass="math inline">\(V_m^{\rm T}(r_0 - AV_my)=0\)</span>，因此有 <spanclass="math display">\[\begin{align}&amp; r_m\perp {\mathcal K}_m \iff V_m^{\rm T}(r_0 - AV_my)=0\Longrightarrow H_m y = \Vert r_0\Vert \boldsymbol{e}_1\end{align}\]</span> 伪代码为</p><figure><imgsrc="https://raw.githubusercontent.com/Glooow1024/ImgHosting/master/hexo/2021/ada-fom.png"alt="FOM" /><figcaption aria-hidden="true">FOM</figcaption></figure><p>根据 <span class="math inline">\(x_m = x_0 + V_m y\)</span>，残差有<span class="math inline">\(r_m = r_0-AV_my=r_0-(V_m H_m +\boldsymbol{w}_{m} \boldsymbol{e}_{m}^{\rm T})y = -\boldsymbol{w}_{m}\boldsymbol{e}_{m}^{\rm T} y\)</span>。</p><h3 id="d-lanczos方法">3.2 D-Lanczos方法</h3><p>若 <span class="math inline">\(A\)</span> 对称，那么 <spanclass="math inline">\(H_m\)</span> 为三对角阵，特别地记为 <spanclass="math inline">\(T_m\)</span> <span class="math display">\[T_{m}=\left(\begin{array}{ccccc}\alpha_{1} &amp; \beta_{2} &amp; &amp; &amp; \\\beta_{2} &amp; \alpha_{2} &amp; \beta_{3} &amp; &amp; \\&amp; \ddots &amp; \ddots &amp; \ddots &amp; \\&amp; &amp; \beta_{m-1} &amp; \alpha_{m-1} &amp; \beta_{m} \\&amp; &amp; &amp; \beta_{m} &amp; \alpha_{m}\end{array}\right) \in \mathbb{R}^{m \times m}\]</span> 记 <span class="math inline">\(T_m\)</span> 的 LU 分解为 <spanclass="math display">\[T_{m}=L_{m} U_{m}=\left(\begin{array}{ccccc}1 &amp; &amp; &amp; &amp; \\\lambda_{2} &amp; 1 &amp; &amp; &amp; \\&amp; \ddots &amp; \ddots &amp; &amp; \\&amp; &amp; \lambda_{m-1} &amp; 1 &amp; \\&amp; &amp; &amp; \lambda_{m} &amp; 1\end{array}\right)\left(\begin{array}{ccccc}\eta_{1} &amp; \omega_{2} &amp; &amp; &amp; \\&amp; \eta_{2} &amp; \omega_{3} &amp; &amp; \\&amp; &amp; \ddots &amp; \ddots &amp; \\&amp; &amp; &amp; \eta_{m-1} &amp; \omega_{m} \\&amp; &amp; &amp; &amp; \eta_{m}\end{array}\right)\]</span> 其中 <spanclass="math inline">\(\omega_{m}=\beta_{m}\)</span>, <spanclass="math inline">\(\quad\lambda_{m}=\frac{\beta_{m}}{\eta_{m-1}}\)</span>, <spanclass="math inline">\(\quad \eta_{m}=\alpha_{m}-\lambda_{m}\omega_{m}\)</span>。那么根据下面这一性质，Lanczos过程可以迭代进行 <spanclass="math display">\[\begin{align}L_{m}=\left(\begin{array}{c|c}L_{m-1} &amp; \mathbf{0} \\\hline \boldsymbol{l}_{m-1}^{T} &amp; 1\end{array}\right), \quad&amp;U_{m}=\left(\begin{array}{c|c}U_{m-1} &amp; \boldsymbol{y}_{m-1} \\\hline \mathbf{0}^{T} &amp; \eta_{m}\end{array}\right) \\L_{m}^{-1} = \left(\begin{array}{c|c}L_{m-1}^{-1} &amp; \mathbf{0} \\\hline -\boldsymbol{l}_{m-1}^{T}L_{m-1}^{-1} &amp; 1\end{array}\right), \quad&amp; U_{m}^{-1}=\left(\begin{array}{c|c}U_{m-1}^{-1} &amp; -\frac{1}{\eta_m} U_{m-1}^{-1} \boldsymbol{y}_{m-1}\\\hline \mathbf{0}^{T} &amp; 1/\eta_{m}\end{array}\right)\end{align}\]</span>根据这个方法，还可以到处<strong>CG（共轭梯度）法</strong>的形式。</p><h3 id="广义极小残量法gmres">3.3 广义极小残量法（GMRES）</h3><p>Generalized minimal residual method (GMRES)实际上就是最小化参量的二范数，即 <span class="math inline">\(\min \Vertr_m \Vert_2 = \min_{x\in x_0+{\mathcal K}_m} \Vert A(x^{\ast} -x)\Vert_2\)</span>，根据 Galerkin 条件，应有 <spanclass="math inline">\(r_m\perp A{\mathcal K}_m \iff V_m^{\rm T}A^{\rmT}AV_my = V_m^{\rm T}A^{\rm T}r_0, ~ y\in{\mathbb R}^m\)</span>。</p><p>另个一思路是 <span class="math inline">\(\min\Vert r_0-AV_my\Vert =\min \Vert V_{m+1} (\Vert r_0\Vert e_1 - \bar{H}_my)\Vert = \min \Vert\Vert r_0\Vert e_1 - \bar{H}_my\Vert\)</span>，最小二乘解 <spanclass="math inline">\(\bar{H}_m^{\rm T}(\bar{H}_my - \Vert r_0\Verte_1)=0\)</span>。</p><h3 id="minres-方法">3.4 MINRES 方法</h3><p>是 GMRES 的特殊情况，当 <span class="math inline">\(A=A^{\rmT}\)</span> 的时候，<span class="math inline">\(H_m\)</span> 为三对角阵<span class="math inline">\(T_m\)</span>，<spanclass="math inline">\(\min \Vert r_m\Vert_2 = \min \Vert \Vert r_0\Verte_1 - T_m y \Vert\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;现在需要求解一个大规模稀疏方程组 &lt;span
class=&quot;math inline&quot;&gt;\(Ax=b\)&lt;/span&gt;，可以用迭代法比如 Jacobi
迭代法、Gauss-Seidel 迭代法等，不过这一节要讨论的是 Krylov
子空间方法，核心部分是 Arnoldi 迭代。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="线性方程组" scheme="https://glooow1024.github.io/tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    
    <category term="Arnoldi过程" scheme="https://glooow1024.github.io/tags/Arnoldi%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】连续参数马尔可夫链</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch7-s1-continuous-markov/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch7-s1-continuous-markov/</id>
    <published>2022-01-24T09:28:25.000Z</published>
    <updated>2022-01-24T09:37:07.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义与基本概念">7.1 定义与基本概念</h2><p><strong>定义</strong>：设随机过程 <spanclass="math inline">\(X=\{X(t),t\ge0\}\)</span>，状态空间 <spanclass="math inline">\(S\)</span>，对任意 <spanclass="math inline">\(0\le t_0 &lt; t_1 &lt; \cdots &lt; t_n &lt;t_{n+1}\)</span>，<span class="math inline">\(i_k\in S\)</span>，若<span class="math inline">\(P(X(T_k)=i_k,0\le k\le n) &gt; 0\)</span> 有<span class="math display">\[P(X(t_{n+1})=i_{n+1} | X(t_k)=i_k,0\le k\le n) = P(X(t_{n+1})=i_{n+1} |X(t_n)=i_n)\]</span> 则称 <span class="math inline">\(X\)</span>为<strong>连续参数的马氏链</strong>。若对任意的 <spanclass="math inline">\(s,t\ge0\)</span>，<spanclass="math inline">\(i,j\in S\)</span> 有 <span class="math display">\[P(X(s+t)=j | X(s)=i) = P(X(t)=j|X(0)=i) = P_{ij}(t)\]</span> 称 <span class="math inline">\(X\)</span>为<strong>齐次马氏链</strong>。</p><p>对于连续参数马氏链，在原点处有 <spanclass="math inline">\(P_{ij}(0)=\delta_{ij}\)</span>，因此 <spanclass="math inline">\(P(0)=I\)</span>。除此之外假设其在原点处连续，即<span class="math inline">\(\lim_{t\to 0}P_{ij}(t)=\delta_{ij},\lim_{t\to0}P(t)=I\)</span>。类比离散参数的马氏链，可以得到类似的C-K 方程 <span class="math inline">\(P(s+t)=P(s)P(t)\)</span>。</p><h2 id="转移概率矩阵">7.2 转移概率矩阵</h2><p>根据 C-K 方程可以猜测 <spanclass="math inline">\(P(t)=e^{tQ}\)</span>，泰勒展开表示为 <spanclass="math inline">\(P(t)=I + \sum_{n=1}^{\infty}\frac{t^n}{n!}Q^n\)</span>，<span class="math inline">\(P(t)\)</span>完全由 <span class="math inline">\(Q\)</span> 确定，并且有 <spanclass="math inline">\(P&#39;(0)=\lim_{t\to0}\frac{P(t)-I}{t}=Q\)</span>。</p><p>上面只是猜测，那么是否真的存在这样一个 <spanclass="math inline">\(Q\)</span> 呢？下面两个定理给出结论。</p><p><strong>定理 7.1</strong>：对 <span class="math inline">\(i\inS\)</span>，极限 <spanclass="math inline">\(-q_{ii}=\lim_{t\to0}\frac{1-P_{ii}(t)}{t}\)</span>存在，但可能是无穷。</p><p><strong>定理 7.2</strong>：对 <span class="math inline">\(i\inS\)</span>，极限 <spanclass="math inline">\(q_{ij}=\lim_{t\to0}\frac{P_{ij}(t)}{t}\)</span>存在且有限。</p><p>证明：略。</p><p><strong>Remark</strong>：实际应用中，<spanclass="math inline">\(P(t)\)</span> 很难获得，一般可以求得 <spanclass="math inline">\(Q\)</span>，此时 <spanclass="math inline">\(e^{tQ} = \lim_{n\to\infty}(I +Qt/n)^n\)</span>。如果取 <span class="math inline">\(n=2^k\)</span>的形式，只需要 <span class="math inline">\(k\)</span>次矩阵乘法即可。</p><p><strong>推论 7.1</strong>：对任意 <span class="math inline">\(i\inS\)</span>，<span class="math inline">\(0\le \sum_{i\ne j}q_{ij}\leq_{ii}\)</span>。</p><p>证明： <span class="math display">\[q_{ii}=\varliminf_{t\to0} \frac{1-P_{ii}(t)}{t} = \varliminf_{t\to0}\sum_{j\ne i}\frac{P_{ij}(t)}{t} \ge \sum_{j\nei}\varliminf_{t\to0}\frac{P_{ij}(t)}{t} = \sum_{j\ne i}q_{ij}\]</span> <strong>推论 7.2</strong>：当 <spanclass="math inline">\(S\)</span> 为有限状态空间时，<spanclass="math inline">\(\sum_{i\ne j}q_{ij}= q_{ii} &lt;\infty\)</span>。</p><h2 id="kolmogorov前向后向微分方程">7.3 Kolmogorov前向后向微分方程</h2><p><strong>定义</strong>：如果 <span class="math inline">\(Q\)</span>满足 <span class="math inline">\(\forall i\in S\)</span>，<spanclass="math inline">\(\sum_{j\ne i}q_{ij} = q_{ii} &lt;\infty\)</span>，则称 <span class="math inline">\(Q\)</span>为保守矩阵。</p><p><strong>定理 7.3</strong>：设马氏链 <spanclass="math inline">\(X=\{X(t),t\ge0\}\)</span>，<spanclass="math inline">\(Q=P&#39;(0)\)</span>，当 <spanclass="math inline">\(S\)</span> 为<strong>有限集</strong>时，<spanclass="math inline">\(P&#39;(t)=P(t)Q=QP(t)\)</span>。</p><p><strong>Remark</strong>：当 <span class="math inline">\(S\)</span>为可数状态时，前向方程与后向方程不一定成立，根据 Fatu 引理有 <spanclass="math inline">\(P&#39;(t)\ge P(t)Q,P&#39;(t)\ge QP(t)\)</span></p><p><strong>定理 7.4</strong>：当 <span class="math inline">\(S\)</span>为<strong>可列个状态</strong>，<span class="math inline">\(Q\)</span>为保守矩阵时，后向方程 <spanclass="math inline">\(P&#39;(t)=QP(t)\)</span> 成立。</p><h2 id="平稳分布与极限分布及其矩阵计算">7.4平稳分布与极限分布及其矩阵计算</h2><p>类似离散马氏链，可以定义状态的连通关系。</p><p><strong>定义</strong>：若 <span class="math inline">\(\int_0^\inftyP_{ii}(t)dt = +\infty\)</span>，则称状态 <spanclass="math inline">\(i\)</span>为<strong>常返态</strong>，否则称为非常返态。</p><p><strong>定义</strong>：设 <span class="math inline">\(i\)</span>为常返态，若 <span class="math inline">\(\lim_{t\to\infty}P_{ii}(t) &gt;0\)</span>，则称为正常返态，若 <spanclass="math inline">\(\lim_{t\to\infty}P_{ii}(t) =0\)</span>，称为零常返态。</p><p><strong>定义</strong>：若概率分布 <spanclass="math inline">\(\pi=\{\pi_i,i\in S\}\)</span> 满足 <spanclass="math inline">\(\pi=\pi P(t)\)</span>，称 <spanclass="math inline">\(\pi\)</span> 为 <spanclass="math inline">\(X\)</span> 的平稳分布。</p><p><strong>定理 7.5</strong>：设 <span class="math inline">\(X\)</span>是有限不可约连续马氏链，对任意 <span class="math inline">\(i,j\inS\)</span>，有 <spanclass="math inline">\(\lim_{t\to\infty}P_{ij}(t)=p_j\)</span>存在，且与状态 <span class="math inline">\(i\)</span> 无关。</p><p>证明：略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义与基本概念&quot;&gt;7.1 定义与基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：设随机过程 &lt;span
class=&quot;math inline&quot;&gt;\(X=\{X(t),t\ge0\}\)&lt;/span&gt;，状态空间 &lt;span
class=&quot;ma</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="平稳分布" scheme="https://glooow1024.github.io/tags/%E5%B9%B3%E7%A8%B3%E5%88%86%E5%B8%83/"/>
    
    <category term="极限分布" scheme="https://glooow1024.github.io/tags/%E6%9E%81%E9%99%90%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】马尔可夫过程2 | 状态空间</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s2-states/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s2-states/</id>
    <published>2022-01-24T09:28:24.000Z</published>
    <updated>2022-01-24T09:36:34.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态空间的分解">6.4 状态空间的分解</h2><p><strong>定义</strong>：设 <span class="math inline">\(A\subsetS\)</span>，若对任意 <span class="math inline">\(i\in A\)</span> 及<span class="math inline">\(j\notin A\)</span>，都有 <spanclass="math inline">\(p_{ij}=0\)</span>，称 <spanclass="math inline">\(A\)</span> 为<strong>闭集</strong>。若 <spanclass="math inline">\(A\)</span> 的状态是相通的，则 <spanclass="math inline">\(A\)</span> 为<strong>不可约</strong>的。</p><p><strong>引理 6.1</strong>：<span class="math inline">\(A\)</span>为闭集的充要条件为：任意 <span class="math inline">\(i\in A\)</span> 及<span class="math inline">\(j\notin A\)</span> 都有 <spanclass="math inline">\(p_{ij}^{(n)}=0,n\ge1\)</span>。</p><p><strong>推论</strong>：若 <span class="math inline">\(A\)</span>是闭集，对任意状态 <span class="math inline">\(i\in A\)</span> 恒有<span class="math inline">\(\sum_{j\in A}p_{ij}^{(n)}=1\)</span>。</p><blockquote><p><strong>定理 6.5</strong>：所有常返态构成一个闭集。</p><p><strong>推论</strong>：不可约马尔科夫链，所有状态都是常返的，或者所有状态都是非常返的。</p></blockquote><p><strong>定理 6.6</strong>：状态空间 <spanclass="math inline">\(S\)</span> 可以分解为 <spanclass="math inline">\(S = T\cup C = T\cup C_1 \cdots \cup C_h\cdots\)</span>，其中 <span class="math inline">\(T\)</span>表示非常返状态的集合，<span class="math inline">\(C_i\)</span>为基本的常返闭集，且有</p><ol type="1"><li>对任一确定的 <span class="math inline">\(k,C_k\)</span>中任意两个状态互通；</li><li><span class="math inline">\(C_k\cap C_l = \varnothing,\forall h\nel\)</span>。</li></ol><blockquote><p><strong>定理 6.7</strong>：有限状态马尔科夫链具有如下性质：</p><ol type="1"><li>状态空间 <span class="math inline">\(S\)</span> 可分解为 <spanclass="math inline">\(S = T\cup C = T\cup C_1 \cdots \cupC_h\)</span>，其中 <span class="math inline">\(T\)</span>表示非常返状态的集合，<span class="math inline">\(C_i\)</span>为基本的常返闭集；</li><li>非常返状态集合 <span class="math inline">\(T\)</span>一定不是闭集；</li><li>没有零常返状态；</li><li>必有正常返状态；</li><li>不可约马氏链的的状态都是正常返态；</li><li>任意闭集 <span class="math inline">\(C_i\)</span> 上的 <spanclass="math inline">\(n\)</span> 步转移矩阵为随机矩阵。</li></ol></blockquote><h2 id="极限特性与平稳分布">6.5 极限特性与平稳分布</h2><h3 id="极限特性">6.5.1 极限特性</h3><p><strong>定理 6.7</strong>：若状态 <spanclass="math inline">\(j\)</span> 为非常返态或零常返态，则对任意 <spanclass="math inline">\(i \in S\)</span>，有 <spanclass="math inline">\(\lim_{n\to\infty}p_{ij}^{(n)}=0\)</span>。</p><p><strong>推论6.7.1</strong>：若马尔科夫链有一个零常返态，则必有无穷多个零常返态。</p><h3 id="平稳分布">6.5.2 平稳分布</h3><p><strong>定义</strong>：一个定义在 <spanclass="math inline">\(S\)</span> 上的概率分布 <spanclass="math inline">\(\pi=(\pi_1,\pi_2,...,\pi_i,...)\)</span>称为马尔科夫链的平稳分布，如果有 <span class="math inline">\(\pi=\piP\)</span>。</p><p><strong>定理 6.9</strong>：若马尔科夫链是不可约的遍历链，则 <spanclass="math inline">\(\{\pi_i = 1 / \mu_i\}\)</span> 是 <spanclass="math inline">\(\pi=\pi P(\pi_i\ge0,\sum_{i\in S}\pi_i=1)\)</span>的<strong>唯一解</strong>。</p><p><strong>推论 6.9.1</strong>：不可约遍历链恒有唯一的平稳分布，且 <spanclass="math inline">\(\pi_j=\lim_{n\to\infty}p_{ij}^{(n)}\)</span>。</p><p><strong>定理 6.10</strong>：令 <spanclass="math inline">\(C_+\)</span>为马尔科夫链中全体正常返状态构成的集合，则有</p><ol type="1"><li>平稳分布不存在的充要条件为 <spanclass="math inline">\(C_+=\varnothing\)</span>；</li><li>平稳分布唯一存在的充要条件为只有一个基本正常返闭集；</li><li>若马尔科夫链有多于一个基本正常返闭集，则其平稳分布有无穷多个。</li></ol><p><strong>定理 6.11</strong>：关于有限状态的马尔科夫链</p><ol type="1"><li>有限状态马尔科夫链的平稳分布总存在；</li><li>有限不可约非周期的马尔科夫链存在唯一的平稳分布；</li><li>若有多于一个基本正常返闭集，则其平稳分布有无穷多个；</li></ol><p><em>栗子</em>（平衡方程及其应用）：对非周期正常返的离散马氏链，平稳分布存在且满足<span class="math inline">\(\pi P=\pi\)</span>，可以写成 <spanclass="math inline">\(\pi_j(1-P_{jj}) = \sum_{i\ne j,i\in S} \pi_iP_{ij}\)</span>，这被称为离散马氏链的平衡方程。左边表示从状态 <spanclass="math inline">\(j\)</span> 流出的量，右边表示从其他状态流入状态<span class="math inline">\(j\)</span>的量，在讨论一些实际工程问题时，可以借助平衡方程求解系统平稳分布。</p><h2 id="转移矩阵的平均极限">6.6 转移矩阵的平均极限</h2><p>一般情况下，<span class="math inline">\(n\to\infty\)</span> 时 <spanclass="math inline">\(P^n\)</span> 的极限未必存在，主要是因为 <spanclass="math inline">\(P^n\)</span>可能有周期性。为了消除周期性，最直接的方法就是取平均。</p><p><strong>定理 6.12</strong>：设 <span class="math inline">\(P\)</span>为有限马氏链的转移矩阵，则 <spanclass="math inline">\(L:=\lim_{n\to\infty}\frac{1}{n}(I+P+\cdots+P^{n-1})\)</span> 存在，且满足 <spanclass="math inline">\(LP = PL = L = L^2\)</span>。</p><p><strong>推论</strong>：设有限不可约马氏链的转移矩阵为 <spanclass="math inline">\(P\)</span>，平稳分布为 <spanclass="math inline">\(\pi\)</span>，<spanclass="math inline">\(L=(l_{ij})=\lim_{n\to\infty}\frac{1}{n}(I+P+\cdots+P^{n-1})\)</span>，则 <spanclass="math inline">\(\pi L=\pi\)</span>，且 <spanclass="math inline">\(\pi_j=l_{ij} / \sum_{k=1}^N l_{ik}\)</span>。</p><p><strong>定理 6.13</strong>：设 <span class="math inline">\(P\)</span>是有 <span class="math inline">\(m\)</span>个状态的不可约马氏链的转移矩阵，则平稳分布概率为</p><p><span class="math inline">\(\pi = (1,...,1)(I-P+{\mathbb1})^{-1}\)</span>，其中 <span class="math inline">\({\mathbb 1}\)</span>为全 1 的 <span class="math inline">\(m\times m\)</span> 矩阵。</p><p>证明：关键是要证明矩阵 <span class="math inline">\((I-P+{\mathbb1})\)</span> 可逆。</p><blockquote><p><strong>Note</strong>：马尔科夫链在随机过程里面是比较简单的部分，大部分结论都很直观，凭直观感觉就能得到。</p><p>实际上这章马尔科夫链的主要内容就是在讨论几种状态：非常返态、正常返态、零常返态。归结起来，现在想象一个马尔可夫链的状态转移图，有很多节点（状态）和有向边（转移概率）。</p><p>首先对于几种状态的区别：</p><ol type="1"><li>正常返态就是说从一个状态开始，经过有限步总能再次回到当前状态，并且这个平均回转时间是有限的（中华好男人，常回家看看）；</li><li>零常返态就是说从一个状态开始，经过有限步总能再次回到当前状态，但这个平均回转时间是无穷的（渣男海王，开空头支票）；</li><li>非常返态就是说从一个状态开始，经过有限步之后就再也不能返回当前状态了（恩断义绝）；</li></ol><p>如何判断每个节点的状态类型，基本只需要下面两条原则：</p><ol type="1"><li>如果两个状态相通，那么他们同为常返态或非常返态。<ol type="1"><li>那么如果两个节点之间有双向边，他们一定是同一类型态；要出现常返态和非常返态的区别一定是由于单向边的存在；</li><li>进一步的，一个连通子图里面的所有状态一定是同一类型；要出现常返态和非常返态的区别，一定是两个连通子图<span class="math inline">\(A,B\)</span> 之间只有单向边；</li><li>假如只有 <span class="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的单向边，那么连通子图 <spanclass="math inline">\(B\)</span> 中的节点一定都是非常返态。</li></ol></li><li>零常返态只可能出现在状态个数为无穷的时候。</li></ol><p>极限分布/平稳分布是怎样：</p><ol type="1"><li>极限分布与初始分布有关，平稳分布只与状态转移链本身的性质有关；</li><li>由于最终一定会收敛到常返态，平稳分布一定是只对常返态非零；</li><li>只考虑常返态的集合，平稳分布就是转移概率矩阵 <spanclass="math inline">\(P\)</span> 的左特征向量；</li></ol><p>下面讲个故事。</p><p>把概率想象成手里的money，初始分布概率就是每个节点手里的本钱；一个（不可约的）连通子图就是一个家族，家族里的每个人之间可以相互借钱来回周转；不同连通子图就是不同的家族。</p><p>（不可约的）连通子图内部，一个家族里面的钱再怎么周转也都是内部消化，每个人借出去的总能还回来，所以钱不会消失，总会有一个平衡。</p><p>如果有两个连通子图，并且它们之间只有单向边，相当于 <spanclass="math inline">\(A\)</span> 总是把一部分 money 白送给 <spanclass="math inline">\(B\)</span>，再厚的家底也得被掏空了。最后 <spanclass="math inline">\(A\)</span>家族就破产了（非常返态，不是闭集）。</p><p>如果 <span class="math inline">\(B\)</span>家族的钱只进不出，也就是没有向外的有向边（闭集），那么他们就会完成资本的积累，最终钱总会聚集到他们那里（常返态）。</p><p>如果有两个连通子图，他们相互之间没有任何边相联系，那就是他们互不打扰，两不相欠（各自有一个平稳分布）。100年之后各自有多少钱取决于现在各自有多少钱，不多不少（联合组成无穷个平稳分布，因为初始分布有无穷种情况）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;状态空间的分解&quot;&gt;6.4 状态空间的分解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：设 &lt;span class=&quot;math inline&quot;&gt;\(A\subset
S\)&lt;/span&gt;，若对任意 &lt;span class=&quot;math inline&quot;&gt;</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="平稳分布" scheme="https://glooow1024.github.io/tags/%E5%B9%B3%E7%A8%B3%E5%88%86%E5%B8%83/"/>
    
    <category term="极限分布" scheme="https://glooow1024.github.io/tags/%E6%9E%81%E9%99%90%E5%88%86%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】马尔可夫过程1 | 基本概念</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s1-concepts/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch6-s1-concepts/</id>
    <published>2022-01-24T09:28:23.000Z</published>
    <updated>2022-01-24T09:34:31.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">6.1 基本概念</h2><p>马尔科夫链的定义很常见了，在此不再赘述。简单而言就是 <spanclass="math display">\[P(X_{n+1}=s_{n+1}|X_0=s_0,...,X_{n}=s_n) = P(X_{n+1}=s_{n+1}|X_{n}=s_n)\]</span>还可以定义一步转移概率、转移概率矩。如果转移概率不随时间变化，就是时间齐次马尔科夫链。</p><p><strong>定理 6.1</strong>：设随机过程 <spanclass="math inline">\(\{X_n,n\ge0\}\)</span> 满足</p><ol type="1"><li><span class="math inline">\(X_n =f(X_{n-1},\xi_n)(n\ge1)\)</span>，其中 <spanclass="math inline">\(f:S\times S\to S\)</span>；</li><li><span class="math inline">\(\{\xi_n,n\ge1 \}\)</span>为独立同分布随机序列，且 <span class="math inline">\(X_0\)</span> 与<span class="math inline">\(\{\xi_n,n\ge1\}\)</span> 也相互独立；</li></ol><p>则 <span class="math inline">\(\{X_n,n\ge0\}\)</span>是马尔科夫链，并且一步转移概率为 <spanclass="math inline">\(p_{ij}=P(f(i,\xi_n)=j)\)</span>.</p><p>证明：根据条件 1 可知 <span class="math inline">\(\xi_{n+1}\)</span>与 <span class="math inline">\(X_0,...,X_n\)</span> 独立，从而有 <spanclass="math display">\[\begin{aligned}&amp;P(X_{n+1}=s_{n+1} | X_0=s_0,...,X_n=s_n) \\=&amp; P(f(X_n,\xi_{n+1})=s_{n+1} | X_0=s_0,...,X_n=s_n) \\=&amp; P(f(s_n,\xi_{n+1})=s_{n+1}) = P(X_{n+1}=s_{n+1} | X_n = s_n)\end{aligned}\]</span> 证毕。</p><blockquote><p><strong>Note</strong>：这个定理实际上是在说 <spanclass="math inline">\(X_n\)</span> 只由 <spanclass="math inline">\(X_{n-1}\)</span> 和一个与之完全独立的随机变量<span class="math inline">\(\xi_n\)</span>决定，这与马尔可夫性质异曲同工。并且如果 <spanclass="math inline">\(\xi_n,n\ge1\)</span>同分布，那么这个马尔可夫过程是时间齐次的，否则是非齐次的。</p><p>如果把随机变量看作是信息的话，<spanclass="math inline">\(\xi_n\)</span> 就可以看成是从 <spanclass="math inline">\(X_{n-1}\)</span> 到 <spanclass="math inline">\(X_n\)</span> 变化的信息量。</p></blockquote><p><em>栗子 1</em>：设 <spanclass="math inline">\(\{\xi_n,n\ge0\}\)</span>独立同分布，取值为非负整数，<spanclass="math inline">\(P(\xi_n=i)=a_i\)</span>。令 <spanclass="math inline">\(X_0=0,X_n=\sum_{k=1}^n \xi_k\)</span>，则易证<span class="math inline">\(\{X_n,n\ge0\}\)</span>是一个马尔科夫链，因为有 <span class="math inline">\(f(X_n,\xi_{n+1}) =X_n+\xi_{n+1}\)</span>。还可以得到转移概率为 <spanclass="math inline">\(p_{ij} = \begin{cases}a_{j-i}, &amp; i\ge i \\ 0,&amp; i &lt; i \end{cases}.\)</span></p><p><em>栗子2</em>（带吸收壁的随机游动）：对称随机游动，每次只能向左或向右移动一个单位，或者原地不动，随机移动限制在<span class="math inline">\(S=\{0,1,...,b\}\)</span> 内。用 <spanclass="math inline">\(\xi_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 次移动的距离，<spanclass="math inline">\(X_n\)</span> 为 <spanclass="math inline">\(n\)</span> 次移动后的位置，则 <spanclass="math inline">\(X_{n+1} = f(X_n,\xi_{n+1}) = X_n +(1-\delta(X_n-b)-\delta(X_n))\xi_{n+1}\)</span>。</p><p><em>栗子3</em>（G/M/1排队模型）：G表示顾客到达服务台的时间间隔，一般假设为独立同分布，分布函数为<spanclass="math inline">\(G(x)\)</span>；M表示服务时间，假设为独立同指数分布，且与顾客到达过程独立；1表示单个服务员。</p><p>记 <span class="math inline">\(X_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个顾客到达服务台时系统内的顾客数，<spanclass="math inline">\(T_n\)</span> 表示第 <spanclass="math inline">\(n\)</span> 个顾客到达时刻。易证 <spanclass="math inline">\(X_n\)</span> 为一个马尔科夫链。</p><p>各顾客服务时间独立，且服从参数为 <spanclass="math inline">\(\mu\)</span> 的指数分布，<spanclass="math inline">\((0,t)\)</span> 时间内服务完的顾客服从参数为 <spanclass="math inline">\(\mu\)</span> 的泊松分布，因此 <spanclass="math display">\[P(X_{n+1}=i+1-j | X_n=i) = \int_0^\infty e^{-\mu t}\frac{(\mu t)^j}{j!}dG(t)\]</span></p><h2 id="转移概率矩阵">6.2 转移概率矩阵</h2><p><strong>定义</strong>：若 <span class="math inline">\(a_{ij}\ge0, ~i,j\in S\)</span> 且满足 <span class="math inline">\(\sum_{j\in S}a_{ij} = 1\)</span>，则称矩阵 <spanclass="math inline">\(A=(a_{ij})\)</span> 为随机矩阵。</p><p>记 <span class="math inline">\(\pi_i(n)=P(X_n=i)\)</span>，向量 <spanclass="math inline">\(\pi(n)=(\pi_1(n),\pi_2(n),...)\)</span> 表示 <spanclass="math inline">\(n\)</span>时刻的概率分布向量。一个马尔科夫链的性质完全由初始分布向量和一步转移概率矩阵决定。</p><p><strong>定理 6.2（C-K方程）</strong>：<spanclass="math inline">\(P^{(m+n)} = P^{(m)} P^{(n)}\)</span>.</p><p><strong>Remark</strong>：上面的C-K方程可以联想到卷积形式，即 <spanclass="math inline">\(P_{ij}^{(n)}=\sum_{k}P_{ik}^{(l)}P_{kj}^{(n-l)}\)</span>，于是又可以联想到用傅里叶变换/ z变换进行处理，以避免卷积。</p><h2 id="markov链状态的分类">6.3 Markov链状态的分类</h2><h3 id="状态分类">6.3.1 状态分类</h3><p><strong>定义</strong>：对于 <span class="math inline">\(i,j\inS\)</span>，若存在自然数 <span class="math inline">\(n\)</span> 使得<span class="math inline">\(p_{ij}^{(n)} &gt; 0\)</span>，则称自状态<span class="math inline">\(i\)</span> 出发可达状态 <spanclass="math inline">\(j\)</span>，记为 <span class="math inline">\(i\toj\)</span>。若 <span class="math inline">\(i\to j\)</span> 且 <spanclass="math inline">\(j\to i\)</span>，则称 <spanclass="math inline">\(i,j\)</span> <strong>相通</strong>，记为 <spanclass="math inline">\(i\leftrightarrow j\)</span>。如果 Markov链的任意两个状态都相通，则称为<strong>不可约链</strong>。</p><p><strong>定义</strong>：<strong>首达时间</strong> <spanclass="math display">\[\tau_{ij}=\min \{n:n\ge1,X_n=j,X_0=i \}\]</span> 若右边为空集，则令 <spanclass="math inline">\(\tau_{ij}=\infty\)</span>。</p><p><strong>定义</strong>：<strong>首达概率</strong> <spanclass="math display">\[f_{ij}^{(n)}=P(\tau_{ij}=n | X_0=i)=P(X_n=j,X_k\ne j,1\le k\le n-1 |X_0=i)\]</span> <span class="math inline">\(f_{ij}=\sum_{n=1}^\inftyf_{ij}^{(n)}\)</span> 表示从 <span class="math inline">\(i\)</span>出发，经有限步首次到达 <span class="math inline">\(j\)</span>的概率。</p><p><strong>定义</strong>：若 <spanclass="math inline">\(f_{ii}=1\)</span>，则称 <spanclass="math inline">\(i\)</span> 为<strong>常返态</strong>；若 <spanclass="math inline">\(f_{ii} &lt; 1\)</span>，称状态 <spanclass="math inline">\(i\)</span> 为非常返态。</p><p><strong>定义</strong>：若 <spanclass="math inline">\(f_{ii}=1\)</span>，此时定义 <spanclass="math inline">\(\mu_i=\sum_{n=1}^\infty nf_{ii}^{(n)}\)</span>，则<span class="math inline">\(\mu_i\)</span> 表示从状态 <spanclass="math inline">\(i\)</span> 出发再回到状态 <spanclass="math inline">\(i\)</span> 的<strong>平均回转时间</strong>。若<span class="math inline">\(\mu_i &lt; \infty\)</span> 称 <spanclass="math inline">\(i\)</span> 为<strong>正常返态</strong>；若 <spanclass="math inline">\(\mu_i=\infty\)</span>称为<strong>零常返态</strong>。</p><p><strong>定义</strong>：若集合 <spanclass="math inline">\(\{n:n\ge1,p_{ii}^{(n)} &gt;0\}\ne\varnothing\)</span>，称该数集的最大公约数 <spanclass="math inline">\(d(i)\)</span> 为状态 <spanclass="math inline">\(i\)</span> 的周期。若 <spanclass="math inline">\(d(i) &gt; 1\)</span> 称状态 <spanclass="math inline">\(i\)</span> 为<strong>周期</strong>的；若 <spanclass="math inline">\(d(i)=1\)</span>称为<strong>非周期</strong>的。</p><p><strong>定义</strong>：若状态 <span class="math inline">\(i\)</span>为正常返态且为非周期的，则称状态 <span class="math inline">\(i\)</span>为<strong>遍历状态</strong>（ergodic state）。</p><h3 id="一些基本关系式">6.3.2 一些基本关系式</h3><p><strong>定理 6.3</strong>：对 <span class="math inline">\(\foralli,j\in S,n\ge1\)</span> 有</p><ol type="1"><li><span class="math inline">\(p_{ij}^{(n)} = \sum_{l=1}^nf_{ij}^{(l)}p_{jj}^{(n-l)}\)</span></li><li><span class="math inline">\(f_{ij}^{(n)} = \sum_{k\nej}p_{ik}f_{kj}^{(n-1)}I_{\{n &gt; 1\}} + p_{ij}I_{\{n=1\}}\)</span>.</li></ol><p>下面给出一些关于该定理的讨论。</p><p><strong>Discussion（常返性判定准则）</strong>：对于特殊情况 <spanclass="math inline">\(i=j\)</span> 时，上面的第 1 条变成 <spanclass="math inline">\(p_{ii}^{(n)} = \sum_{l=1}^nf_{ii}^{(l)}p_{ii}^{(n-l)}\)</span>，这是卷积的形式，取 z 变换 <spanclass="math inline">\(P_i(z)=\sum_{n=1}^{\infty}p_{ii}^{(n)}z^{-n}\)</span>，<spanclass="math inline">\(F_i(z)=\sum_{n=1}^{\infty}f_{ii}^{(n)}z^{-n}\)</span>，那么根据上式有<span class="math inline">\(P_i(z)=1+F_i(z)P_i(z)\)</span>，从而 <spanclass="math inline">\(P_i(z)=\frac{1}{1-F_i(z)}\)</span>。当 <spanclass="math inline">\(z\to1\)</span>时，有 <spanclass="math inline">\(P_i(z)\to\sum_{n=1}^{\infty}p_{ii}^{(n)}\)</span>，<spanclass="math inline">\(F_i(z)\to \sum_{n=1}^{\infty}f_{ii}^{(n)} =f_{ii}\)</span>。</p><p><strong>推论 6.3.1</strong>：状态 <spanclass="math inline">\(i\)</span> 为常返的充要条件为 <spanclass="math inline">\(\sum_{n=1}^{\infty}p_{ii}^{(n)}=+\infty\)</span>；状态<span class="math inline">\(i\)</span> 非常返的充要条件为 <spanclass="math inline">\(\sum_{n=1}^{\infty}p_{ii}^{(n)} &lt;\infty\)</span>。</p><p>如果记 <span class="math inline">\(I_n(i)=\begin{cases}0,&amp;X_n\nei \\ 1,&amp; X_n=i \end{cases}\)</span>，<spanclass="math inline">\(S(i)=\sum_{n=1}^\infty I_n(i)\)</span> 为到达状态<span class="math inline">\(i\)</span> 的次数，那么 <spanclass="math inline">\({\mathbb E}[S(i) |X_0=i]=\sum_{n=1}^{\infty}p_{ii}^{(n)}\)</span> 即表示从状态 <spanclass="math inline">\(i\)</span> 出发返回 <spanclass="math inline">\(i\)</span> 的平均次数。当 <spanclass="math inline">\(i\)</span> 为常返态，直观上即平均返回 <spanclass="math inline">\(i\)</span>的次数为无穷，与上面的推论是一致的。对于非常返态，平均返回次数有限。</p><p><strong>Discussion（<spanclass="math inline">\(p_{ii}^{(n)}\)</span>与正常返、零常返的关系）</strong>：</p><p>（1）当状态是非周期的，定义 <spanclass="math inline">\(v_n=p_{ii}^{(n)} - p_{ii}^{(n-1)},n &gt;1\)</span>，<spanclass="math inline">\(v_0=p_{ii}^{(0)}\)</span>，于是有 <spanclass="math inline">\(V(z)=\sum_{n=0}^{\infty} v_nz^{-n} =\frac{1-z^{-1} }{1-F_i(z)}\)</span>，利用洛必达法则有 <spanclass="math inline">\(\lim_{z\to 1}V(z) = -1/F_i&#39;(1) =1/\mu_i\)</span>。另一方面 <spanclass="math inline">\(\lim_{z\to1}V(z)=\lim_{n\to\infty}\sum_{k=0}^\inftyv_k=\lim_{n\to\infty} p_{ii}^{(n)}\)</span>，因此有 <spanclass="math display">\[\lim_{n\to\infty} p_{ii}^{(n)}=1/\mu_i\]</span></p><blockquote><p>根据正常返和零常返的定义知道：</p><p>当 <span class="math inline">\(i\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i\ne0\)</span>；</p><p>当 <span class="math inline">\(i\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i=0\)</span>。</p></blockquote><p>（2）当状态是周期的，记状态 <span class="math inline">\(i\)</span>的周期为 <span class="math inline">\(T\)</span>，当 <spanclass="math inline">\(n\)</span> 不是 <spanclass="math inline">\(T\)</span> 的整数倍时有 <spanclass="math inline">\(f_{ii}^{(n)}=0\)</span>，<spanclass="math inline">\(F_i(z)=\sum_{k=0}^\inftyf_{ii}^{(kT)}z^{-kT}=\psi(z^T)\)</span>，相应的 <spanclass="math inline">\(P_i(z)=\frac{1}{1-\psi(z^T)}\)</span>。类似非周期情况的讨论可以得到<span class="math display">\[p_{ii}^{(nT)}\to T/\mu_i\]</span></p><blockquote><p>当 <span class="math inline">\(i\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(nT)}=T/\mu_i\ne0\)</span>，<spanclass="math inline">\(\lim_{n\to\infty} p_{ii}^{(nT+k)}=0,0 &lt; k &lt;T\)</span>；</p><p>当 <span class="math inline">\(i\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty}p_{ii}^{(n)}=1/\mu_i=0\)</span>。</p></blockquote><p><strong>Discussion（<spanclass="math inline">\(p_{ij}^{(n)}\)</span>与正常返、零常返的关系）</strong>：由于<span class="math inline">\(p_{ij}^{(n)} = \sum_{l=1}^nf_{ij}^{(l)}p_{jj}^{(n-l)}\)</span>，定义相应的 z 变换可以得到 <spanclass="math inline">\(P_{ij}(z)=F_{ij}(z)P_j(z) =\frac{F_{ij}(z)}{1-F_j(z)}\)</span>。当 <spanclass="math inline">\(j\)</span> 为常返态时，利用洛必达法则有 <spanclass="math inline">\(\lim_{z\to1+}(1-z^{-1})P_{ij}(z) =\lim_{z\to1+}\frac{1}{F_j&#39;(z)}\lim_{z\to1+}F_{ij}(z) =f_{ij}/\mu_j\)</span>，而左端等于（利用Hardy-Littlewood引理） <spanclass="math inline">\(\lim_{z\to1+}(1-z^{-1})P_{ij}(z) =\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)}\)</span>，因此有 <span class="math display">\[\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\infty p_{ij}^{(k)} =\frac{f_{ij} }{\mu_j}\]</span></p><blockquote><p>当 <span class="math inline">\(j\)</span> 是正常返时，<spanclass="math inline">\(\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)} = {f_{ij} }/{\mu_j}\)</span> 为有限值；</p><p>当 <span class="math inline">\(j\)</span> 是零常返时，<spanclass="math inline">\(\lim_{n\to\infty} \frac{1}{n+1}\sum_{k=0}^\inftyp_{ij}^{(k)}=0\)</span>。</p></blockquote><h3 id="状态间的等价关系">6.3.3 状态间的等价关系</h3><p>对马尔科夫链而言，状态互通是一种等价关系，对于状态进行归类有助于简化后续分析过程。</p><p><strong>定理 6.4</strong>：</p><ol type="1"><li>若状态 <span class="math inline">\(i\)</span> 常返，并且 <spanclass="math inline">\(i\to j\)</span>，则状态 <spanclass="math inline">\(j\)</span> 也是常返的，并且 <spanclass="math inline">\(f_{ji}=1\)</span>；</li><li>如果 <span class="math inline">\(i\leftrightarrow j\)</span>，则状态<span class="math inline">\(i,j\)</span>同为常返或非常返态；若为常返态，则他们同为正常返或零常返；</li><li>如果 <span class="math inline">\(i\leftrightarrow j\)</span>，则状态<span class="math inline">\(i,j\)</span> 有相同的周期。</li></ol><p>证明：（1）存在 <span class="math inline">\(N\)</span> 使得 <spanclass="math inline">\(p_{ij}^{(N)} &gt; 0\)</span>，从 <spanclass="math inline">\(i\)</span> 出发到 <spanclass="math inline">\(j\)</span> 不返回 <spanclass="math inline">\(i\)</span> 的概率为 <spanclass="math inline">\(p_{ij}^{(N)}(1-f_{ji})=0\)</span>，因此 <spanclass="math inline">\(f_{ji}=1\)</span>。由于 <spanclass="math inline">\(i\leftrightarrow j\)</span>，存在 <spanclass="math inline">\(N_1,N_2\)</span> 有 <spanclass="math inline">\(p_{ij}^{(N_1)} &gt; 0,p_{ji}^{(N_2)} &gt;0\)</span>，那么 <span class="math inline">\(p_{jj}^{(N_1+n+N_2)} \gep_{ij}^{(N_1)}p_{ii}^{(n)}p_{ji}^{(N_2)}=abp_{ii}^{(n)}\)</span>，因此有<span class="math inline">\(\sum_{n=0}^{\infty} p_{jj}^{(n)} =\infty\)</span>，因此状态 <span class="math inline">\(j\)</span>是常返的。</p><p>（2，3）略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;6.1 基本概念&lt;/h2&gt;
&lt;p&gt;马尔科夫链的定义很常见了，在此不再赘述。简单而言就是 &lt;span
class=&quot;math display&quot;&gt;\[
P(X_{n+1}=s_{n+1}|X_0=s_0,...,X_{n}=s_n) = P(X_{n</summary>
      
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="Markov过程" scheme="https://glooow1024.github.io/tags/Markov%E8%BF%87%E7%A8%8B/"/>
    
    <category term="常返" scheme="https://glooow1024.github.io/tags/%E5%B8%B8%E8%BF%94/"/>
    
  </entry>
  
  <entry>
    <title>【随机过程2】布朗运动2 | 推广</title>
    <link href="https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch5-s2-brown-extension/"/>
    <id>https://glooow1024.github.io/2022/01/24/stochastic-process-2/ch5-s2-brown-extension/</id>
    <published>2022-01-24T09:28:21.000Z</published>
    <updated>2022-01-24T09:49:41.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大值与首中时的分布特性">5.4 最大值与首中时的分布特性</h2><p>设 <span class="math inline">\(\{B(t),t\ge0\}\)</span>是标准布朗运动，不妨设 <span class="math inline">\(B(0)=0\)</span>。</p><p><strong>定义</strong>：首次击中 <spanclass="math inline">\(a\)</span> 的时间 <spanclass="math inline">\(\tau_a=\inf\{t:t\ge0,B(t)=a\}\)</span></p><span id="more"></span><p><strong>定义</strong>：对 <span class="math inline">\(\forall t &gt;0, M(t)=\max_{0\le u\le t}B(u)\)</span> 表示 <spanclass="math inline">\([0,t]\)</span> 上的最大值。</p><p>当 <span class="math inline">\(a &gt; 0\)</span> 时，显然存在等价关系<span class="math inline">\(\{\tau_a \le t\} = \{M(t) \gea\}\)</span>，因此有 <span class="math inline">\(P(\tau_a \le t) =P(M(t) \ge a)\)</span>。</p><p><strong>Remark</strong>：事实上，这与泊松过程中定义的 <spanclass="math inline">\(\{S_n\le t\} = \{N(t)\ge n\}\)</span>类似。主要差别在于泊松过程中讨论离散点情况，这里讨论连续情况。</p><p><strong>定理 5.6</strong>：对任意 <spanclass="math inline">\(a&gt;0\)</span>，<spanclass="math inline">\(M(t)\)</span> 和 <spanclass="math inline">\(\tau_a\)</span> 的分布密度函数分别为 <spanclass="math display">\[\begin{aligned}f_{M(t)}(a) &amp;= \sqrt{\frac{2}{\pi t} } e^{-a^2/ 2t}I_{[0,\infty)}(a) \\f_{\tau_a}(t) &amp;= \frac{a}{\sqrt{2\pi} } e^{-a^2/2t} t^{-3/2}, \quadt &gt; 0\end{aligned}\]</span> <span class="math inline">\(\tau_a\)</span> 的 Laplace 变换为<span class="math inline">\({\mathbb E}[\exp(-s\tau_a)] =e^{-\sqrt{2s}a}, ~ s&gt;0\)</span>。</p><p>证明：<span class="math inline">\(P(B(t)\ge a) = P(B(t\ge a | \tau_a\le t))P(\tau_a \le t)\)</span>，由于 <spanclass="math inline">\(P(B(t)\ge a) | \tau_a\le t) = P(B(t)&lt; a) |\tau_a\le t)=1/2\)</span>，因此可以得到 <spanclass="math inline">\(P(M(t)\ge a) = P(\tau_a \le t) = 2P(B(t)\gea)=\frac{2}{\sqrt{2\pi t} }\int_a^{\infty} e^{-x^2 /2t}dx\)</span>。于是 <spanclass="math inline">\(f_{M(t)}(a)={d(1-P(M(t)\ge a))} /{da}\)</span>，<span class="math inline">\(f_{\tau_a}(t) = d(P(\tau_a\le t)) / da\)</span>，证毕。</p><p>利用上述定理可以到如下结果：</p><ol type="1"><li><span class="math inline">\(\tau_a\)</span> 几乎处处有限，即 <spanclass="math inline">\(P(\tau_a &lt; \infty)=1\)</span>；</li><li><span class="math inline">\({\mathbb E}\tau_a =\infty\)</span>。</li></ol><p>证明：1）<span class="math inline">\(P(\tau_a&lt;\infty) =\lim_{t\to\infty}=P(\tau_a \le t) = \lim_{t\to\infty}\frac{2}{\sqrt{2\pi} }\int_{a/\sqrt{t} }^{\infty} e^{-u^2/2}du =1\)</span>；2）<span class="math inline">\({\mathbbE}[\exp(-s\tau_a)]=e^{-\sqrt{2s}a}\)</span>，两边对 <spanclass="math inline">\(s\)</span> 求导得到 <spanclass="math inline">\({\mathbb E}[\tau_a \exp(-s\tau_a)] =\frac{\sqrt{2} }{2} a s^{-1/2} e^{-\sqrt{2s}a}\)</span>，令 <spanclass="math inline">\(s\to 0\)</span> 即可得到 <spanclass="math inline">\({\mathbb E}\tau_a = \infty\)</span>，证毕。</p><p><em>栗子 5.1</em>：</p><p><strong>定理 5.7</strong>：设 <spanclass="math inline">\(\{B(t)\}\)</span> 为标准布朗运动，<spanclass="math inline">\(\forall a &gt; 0, y\ge0\)</span> 有 <spanclass="math inline">\(P(B(t)\le a-y, M(t)\ge a) = P(B(t) \gea+y)\)</span></p><p>证明：根据反射性定义 <span class="math inline">\(B^{\ast}(t) =2a-B(t)\)</span>，则有 <span class="math inline">\(\tau_a =\tau^{\ast}_a = \inf\{B^{\ast}(t)=a\}\)</span>，又由于 <spanclass="math inline">\(\{M(t)\ge a\} = \{\tau_a \le t\}\)</span>，于是有<span class="math display">\[\begin{aligned}P(B(t)\le a-y, M(t)\ge a) &amp;= P(B(t)\le a-y, \tau_a\le t) \\&amp;= P(B^{\ast}(t) \le a-y, \tau_a \le t) \\&amp;= P(B(t) \ge a+y, \tau_a\le t) \\&amp;= P(B(t)\ge a+y)\end{aligned}\]</span> <strong>推论 5.7.1</strong>：设 <spanclass="math inline">\(\{B(t)\}\)</span> 为标准布朗运动，<spanclass="math inline">\(\forall a &gt; 0\)</span> 有 <spanclass="math inline">\(P(M(t)\ge a) = 2P(B(t)\ge a) = P(|B(t)|\gea)\)</span>.</p><p><strong>推论 5.7.2</strong>：<span class="math inline">\(\forall \xi&gt; 0, x\le\xi\)</span>，<span class="math inline">\(M(t)\)</span> 和<span class="math inline">\(B(t)\)</span> 的联合分布密度函数为 <spanclass="math inline">\(f_{M,B}(\xi,x) = \sqrt{\frac{2}{\pi}}(\frac{2\xi-x}{t^{3/2} }) \exp(-(2\xi-x)^2/2t)I_{[0,\infty)}(\xi)I_{(-\infty,\xi]}(x)\)</span>.</p><h2 id="过零点的反正弦定理">5.5 过零点的反正弦定理</h2><p><span class="math inline">\(\forall t_1 &lt; t_2\)</span>，记事件<span class="math inline">\(o(t_1,t_2)=\{\exists t\in(t_1,t_2),B(t)=0\}\)</span>，利用全概率公式有 <span class="math display">\[P(o(t_1,t_2)) = \int_{-\infty}^{\infty} P(o(t_1,t_2) | B(t_1)=x)\frac{1}{\sqrt{2\pi t_1} }e^{-x^2/2t_1} dx\]</span> 利用布朗运动的连续性和对称性有 <span class="math display">\[P(o(t_1,t_2)|B(t_1)=x) = P(\tau_x\le t_2-t_1) =\frac{2}{\sqrt{2\pi(t_2-t_1)} }\int_x^{\infty} e^{-u^2/2(t_2-t_1)} du\]</span> 于是有 <span class="math display">\[P(o(t_1,t_2)) = \frac{1}{\pi\sqrt{t_1(t_2-t_1)}}\int_0^{\infty}\int_x^{\infty} e^{-\frac{y^2}{2(t_2-t_1)} }dy \cdote^{-\frac{x^2}{2t_1} }dx\]</span>这个积分的直接求解非常困难，为求此积分，采用另外的方法，也即反正弦定理。</p><p><strong>定理 5.8（反正弦定理）</strong>：设 <spanclass="math inline">\(B(t)\)</span> 是标准布朗运动，记 <spanclass="math inline">\(\bar{o}(t_1,t_2)=\{B(t)\ne 0,\forallt\in(t_1,t_2)\}\)</span>，则 <spanclass="math inline">\(P(\bar{o}(t_1,t_2))=\frac{2}{\pi}\arcsin\sqrt{\frac{t_1}{t_2} }\)</span>，且当 <spanclass="math inline">\(t_1=xt, t_2=t, 0 &lt; x &lt; 1\)</span> 时，有<span class="math inline">\(P(\bar{o}(xt,t))=\frac{2}{\pi} \arcsin\sqrt{x}\)</span>.</p><p><strong>Remark</strong>：这说明布朗运动处处连续但处处不可导。</p><h2 id="布朗运动的推广">5.6 布朗运动的推广</h2><h3 id="带吸收点的布朗运动">5.6.1 带吸收点的布朗运动</h3><p>设 <span class="math inline">\(Z(t)=\begin{cases}B(t), &amp; t &lt;\tau_x \\ x, &amp; t\ge \tau_x \end{cases}\)</span>，为求 <spanclass="math inline">\(Z(t)\)</span> 的分布，不妨设 <spanclass="math inline">\(x &gt; 0\)</span></p><p>（1）当 <span class="math inline">\(y &gt; x\)</span> 时，<spanclass="math inline">\(P(Z(t) \le y)=1\)</span>；</p><p>（2）当 <span class="math inline">\(y=x\)</span> 时，<spanclass="math inline">\(P(Z(t)=x) = P(\tau_x\le t) = \frac{2}{\sqrt{2\pit} }\int_x^\infty e^{-u^2/2t} du\)</span>；</p><p>（3）当 <span class="math inline">\(y &lt; x\)</span> 时，</p><h3 id="原点反射的布朗运动">5.6.2 原点反射的布朗运动</h3><h3 id="几何布朗运动">5.6.3 几何布朗运动</h3><p>令 <spanclass="math inline">\(W(t)=e^{B(t)}\)</span>，称它为几何布朗运动，取<span class="math inline">\(B(t)\)</span> 的矩母函数 <spanclass="math inline">\(\phi(s)={\mathbb E}[e^{sB(t)}]\)</span>，则 <spanclass="math inline">\(\phi(s)=e^{ts^2/2}\)</span>，因此 <spanclass="math inline">\({\mathbb E}[W(t)]=\phi(1)=e^{t/2}\)</span>，<spanclass="math inline">\(D[W(t)] = {\mathbb E}[W^2(t)]-({\mathbbE}[W(t)])^2=\phi(2)-e^t = e^{2t}-e^t\)</span>.</p><p><em>栗子 5.2</em>：考虑股票市场收益率，<spanclass="math inline">\(S_0,S_n\)</span> 分别表示最初价位和最终价位，<spanclass="math inline">\(S_n=S_0 e^{B(t_1)-B(t_0)}\cdotse^{B(t_n)-B(t_{n-1})}\)</span>.</p><h3 id="布朗运动的积分">5.6.4 布朗运动的积分</h3><p>令 <span class="math inline">\(S(t)=\int_0^tB(u)du\)</span>，根据正态分布的性质知道他是正态过程，<spanclass="math inline">\({\mathbb E}S(t)=0\)</span>，<spanclass="math inline">\(\forall 0\le \delta \le t\)</span>，有 <spanclass="math display">\[\operatorname{cov}[S(\delta),S(t)] = {\mathbb E}[\int_0^\delta\int_0^tB(u)B(v)dudv] = \int_0^\delta\int_0^t(u\wedgev)dudv=\frac{\delta^2}{2}(t-\frac{\delta}{3})\]</span></p><h3 id="布朗运动的形式导数">5.6.5 布朗运动的形式导数</h3><p>考虑增量比，固定 <span class="math inline">\(\Delta t &gt;0\)</span>，令 <span class="math inline">\(\frac{B(t+\Deltat)-B(t)}{\Delta t} = \frac{\Delta B(t)}{\Delta t}\)</span>，</p><h2 id="布朗桥与经验分布">5.7 布朗桥与经验分布</h2><h3 id="布朗桥的基本概念与性质">5.7.1 布朗桥的基本概念与性质</h3><p><strong>定义</strong>：<spanclass="math inline">\(\{B(t),t\ge0\}\)</span> 为标准布朗运动，不妨设<span class="math inline">\(B(0)=0\)</span>，令 <spanclass="math inline">\(B_{00}(t)=B(t)-tB(1)\)</span>，则称 <spanclass="math inline">\(\{B_{00}(t), 0\le t\le 1\}\)</span>为<strong>布朗桥</strong>。</p><p>根据其定义，可以得到基本性质如下：</p><ol type="1"><li><spanclass="math inline">\(B_{00}(0)=B_{00}(1)=0\)</span>；（？？）</li><li><span class="math inline">\({\mathbb E}[B_{00}(t)]={\mathbbE}[B(t)-tB(1)]=0\)</span>；</li><li><span class="math inline">\(D[B_{00}(t)]={\mathbbE}[B_{00}^2(t)]=t(1-t)\)</span>；</li><li>设 <span class="math inline">\(s\le t\)</span>，<spanclass="math inline">\(\operatorname{cov}[B_{00}(s),B_{00}(t)]=s(1-t)\)</span>；</li><li><span class="math inline">\(\{B_{00}(t),0\le t\le1 \}\)</span>的分布与 <span class="math inline">\(\{B(t), t\ge0 \}\)</span> 在 <spanclass="math inline">\(B(1)=0\)</span> 下的条件分布相同。</li></ol><h3 id="经验分布与布朗桥的关系">5.7.2 经验分布与布朗桥的关系</h3><p>工程统计中，经常独立抽取多个样本 <spanclass="math inline">\(X_1,...,X_n\)</span>来统计某参量的统计特性，定义经验分布 <spanclass="math inline">\(\hat{F}_n(x) = \frac{1}{n}\sum_{i=1}^n I_{\{X_i\lex\} }\)</span>。假设 <span class="math inline">\(X_1,...,X_n\)</span>独立同分布，且 <span class="math inline">\(X_n\simF(x)\)</span>，则有：</p><ol type="1"><li><span class="math inline">\({\mathbb E}[\hat{F}_n(x)] =F(x)\)</span></li><li><spanclass="math inline">\(\operatorname{Var}[\hat{F}_n(x)]=\frac{1}{n}F(x)(1-F(x))\)</span></li><li>任意给定 <span class="math inline">\(x\)</span>，利用强大数定理得到任意给定 <span class="math inline">\(x\)</span>，利用强大数定理得到<spanclass="math inline">\(P(\lim_{n\to\infty}\hat{F}_n(x)=F(x))=1\)</span></li><li>任意给定 <spanclass="math inline">\(x\)</span>，利用中心极限定理得到 <spanclass="math inline">\(n\to\infty\)</span> 时有（依分布收敛）</li></ol><p><span class="math display">\[\frac{\sum_{i=1}^n (I_{\{X_i\le x\} }-F(x)) }{\sqrt{nF(x)(1-F(x))} }\overset{d}{=} {\mathcal N}(0,1)\]</span></p><p>证明：（2）<spanclass="math inline">\(\operatorname{Var}[\hat{F}_n(x)]={\mathbbE}[\hat{F}_n(x)^2] - F(x)^2 = \frac{1}{n^2}{\mathbb E}[\sum_{i=1}^nI_{\{X_i\le x\} } \sum_{j=1}^n I_{\{X_j\le x\} }]\)</span>，展开化简就可以得到性质 2.</p><p>（4）记 <spanclass="math inline">\(G_n(x)=\sqrt{n}(\hat{F}_n(x)-F(x))\)</span>，容易证明<span class="math inline">\({\mathbbE}G_n(x)=0,\operatorname{Var}G_n(x)=F(x)(1-F(x))\)</span>，特别的，根据中心极限定理，当<span class="math inline">\(n\to\infty\)</span> 时有 <spanclass="math inline">\(G_n(x)\overset{d}{=}G(x)\)</span>，其中 <spanclass="math inline">\(G(x)\sim {\mathcalN}(0,F(x)(1-F(x)))\)</span>。</p><p><strong>引理 5.1</strong>：如果 <span class="math inline">\(x_1 &lt;x_2\)</span>，则 <span class="math inline">\({\mathbbE}[G_n(x_1)G_n(x_2)] = F(x_1)(1-F(x_2))\)</span>。</p><p>证明：代入展开化简即可得到。</p><blockquote><p><strong>Remark</strong>：根据上述引理和 <spanclass="math inline">\(G_n(x)\)</span> 的性质可知，当 <spanclass="math inline">\(F_n(x)=x\)</span> 时，即 <spanclass="math inline">\(X_1,...,X_n\)</span> 服从 <spanclass="math inline">\([0,1]\)</span> 上的均匀分布时，<spanclass="math inline">\(G_n(x)\)</span> 的极限分别 <spanclass="math inline">\(G(x)\)</span> 是布朗桥。</p><p>事实上，对于一般的连续分布函数 <spanclass="math inline">\(F(x)\)</span>，<spanclass="math inline">\(G_n(x)\)</span> 的极限分布 <spanclass="math inline">\(G(x)\)</span>也可以用布朗桥表示。为此，首先给出如下引理。</p></blockquote><p><strong>引理 5.2</strong>：随机变量 <spanclass="math inline">\(X\)</span> 的分布函数 <spanclass="math inline">\(F(x)\)</span> 连续，则 <spanclass="math inline">\(Y=F(X)\)</span> 是一个 <spanclass="math inline">\([0,1]\)</span> 均匀分布的随机变量。</p><p>证明：<span class="math inline">\(\forall y\in[0,1]\)</span>，定义<span class="math inline">\(x=\inf\{u:F(u)\ge y\}\)</span>，因此有 <spanclass="math inline">\(P(F(X)\ge y)) = P(Y\gey)=1-F(x)=1-y\)</span>，从而有 <span class="math inline">\(P(Y &lt; y) =y\)</span>，证毕。</p><p>基于引理 5.2，可以定义 <span class="math inline">\(G^{ \#}(x)=B_{00}(F(x))\)</span>，利用布朗桥性质有 <spanclass="math inline">\(G^{ \# }(x)\)</span> 与 <spanclass="math inline">\(G(x)\)</span> 有相同的分布特性，从而可以推得 <spanclass="math inline">\(G_n(x)\)</span> 的极限分布为以 <spanclass="math inline">\(F(x)\)</span> 为参变量的布朗桥。</p><h3 id="经验分布的误差估计">5.7.3 经验分布的误差估计</h3><p>略。</p><h2 id="带漂移的布朗运动">5.8 带漂移的布朗运动</h2><p><strong>定义</strong>：设 <spanclass="math inline">\(\{B(t),t\ge0\}\)</span> 为标准布朗运动，记 <spanclass="math inline">\(X(t)=B(t)+\eta t\)</span>，其中 <spanclass="math inline">\(\eta\)</span> 为常数，称 <spanclass="math inline">\(\{X(t),t\ge0\}\)</span> 为带漂移的布朗运动。</p><h3 id="移出区间的概率计算">5.8.1 移出区间的概率计算</h3><p><strong>定理 5.9</strong>：对任意 <span class="math inline">\(A &gt;0, B &gt; 0\)</span>，定义停时 <spanclass="math inline">\(\tau=\inf\{t:X(t)=A ~ or ~ X(t)=-B \}\)</span>，则<span class="math inline">\(P_{A}=P(X(\tau)=A) = \frac{e^{2\etaB}-1}{e^{2\eta B}-e^{2\eta a} }\)</span>.</p><h3 id="首中时问题">5.8.2 首中时问题</h3><h2 id="布朗运动的轨道性质">5.9 布朗运动的轨道性质</h2><p><strong>轨道处处连续，几乎处处不可导</strong>。</p><p><strong>定理</strong>：标准布朗运动 <spanclass="math inline">\(B(t)\)</span>，对任意的 <spanclass="math inline">\(t\ge0\)</span>，有 <span class="math display">\[P(\lim_{h\to 0}\sup\left|\frac{B(t+h)-B(t)}{h}\right|=+\infty) = 1\]</span> 证明：略。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最大值与首中时的分布特性&quot;&gt;5.4 最大值与首中时的分布特性&lt;/h2&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(\{B(t),t\ge0\}\)&lt;/span&gt;
是标准布朗运动，不妨设 &lt;span class=&quot;math inline&quot;&gt;\(B(0)=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：首次击中 &lt;span
class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 的时间 &lt;span
class=&quot;math inline&quot;&gt;\(\tau_a=\inf\{t:t\ge0,B(t)=a\}\)&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随机过程2" scheme="https://glooow1024.github.io/categories/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B2/"/>
    
    
    <category term="首中时" scheme="https://glooow1024.github.io/tags/%E9%A6%96%E4%B8%AD%E6%97%B6/"/>
    
    <category term="布朗运动" scheme="https://glooow1024.github.io/tags/%E5%B8%83%E6%9C%97%E8%BF%90%E5%8A%A8/"/>
    
    <category term="反正弦定理" scheme="https://glooow1024.github.io/tags/%E5%8F%8D%E6%AD%A3%E5%BC%A6%E5%AE%9A%E7%90%86/"/>
    
    <category term="布朗桥" scheme="https://glooow1024.github.io/tags/%E5%B8%83%E6%9C%97%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://glooow1024.github.io/2022/01/23/hello-world/"/>
    <id>https://glooow1024.github.io/2022/01/23/hello-world/</id>
    <published>2022-01-23T11:47:05.001Z</published>
    <updated>2019-12-10T11:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【高等数值分析】常微分方程数值解</title>
    <link href="https://glooow1024.github.io/2022/01/14/advanced-numerical-analysis/ada-nsode/"/>
    <id>https://glooow1024.github.io/2022/01/14/advanced-numerical-analysis/ada-nsode/</id>
    <published>2022-01-14T01:26:08.000Z</published>
    <updated>2022-01-14T01:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>求解常微分方程初值问题数值解 <span class="math display">\[\begin{align}&amp;\frac{dy}{dx} = f(x,y), \quad a &lt; x &lt; b, |y| &lt; \infty \\&amp;y(a) = y_0\end{align}\]</span> 存在唯一性定理：若 <span class="math inline">\(f(x,y)\)</span>连续，对 <span class="math inline">\(y\)</span> 满足 Lipschitz条件，那么初值问题有唯一解。</p><span id="more"></span><p>对上面的常微分方程积分就有 <span class="math inline">\(y(t_{n+k}) -y(t_{n-j}) = \int_{t_{n-j}}^{t_{n+k}} f(t,y(t))dt\)</span>，所以实际上可以转化为数值积分的问题，所以这一节的方法和数值积分很类似。但是这里的问题在于被积函数值是不知道的。</p><h2 id="线性多步法">2. 线性多步法</h2><p>在数值积分里面 <span class="math inline">\(f(t_k,y(t_k))\)</span>是已知的，主要是在设计求积节点对应的系数。在这里还需要首先估计每个节点的函数值。对前面的式子采样求积就得到<span class="math inline">\(y(t_{n+k}) - y(t_{n-j}) = h\sum_i \beta_if_{n-i}\)</span>，就引出了下面要介绍的线性多步法。</p><h3 id="线性多步法-1">2.1 线性多步法</h3><p>记 <span class="math inline">\(f_n=f(t_n,y_n),y_n=y(t_n)\)</span>，线性多步法（线性 <spanclass="math inline">\(k\)</span> 步法）的一般表达式为 <spanclass="math display">\[\sum_{i=0}^k \alpha_i y_{n+i} = h\sum_{i=0}^{k} \beta_i f_{n+i}\]</span> 其中 <span class="math inline">\(\alpha_k=1,\alpha_0^2+\beta_0^2\ne0\)</span>。给一些特例：</p><ul><li><span class="math inline">\(\alpha_0=-1,\beta_0=1,\beta_1=0\)</span>时为显式Euler法 <span class="math inline">\(y_{n+1}=y_n +hf_n\)</span>；</li><li><span class="math inline">\(\alpha_0=-1,\beta_0=0,\beta_1=1\)</span>时为隐式Euler法 <span class="math inline">\(y_{n+1}=y_n +hf_{n+1}\)</span>；</li><li><span class="math inline">\(\alpha_0=-1,\beta_0=\beta_1=1/2\)</span>时为梯形法 <span class="math inline">\(y_{n+1} = y_n +h/2(f_n+f_{n+1})\)</span>。</li></ul><p>可以定义<strong>“特征多项式”</strong>，在后面分析稳定性和收敛性的时候会很有用<span class="math display">\[\rho(\xi) = \sum_{i=0}^k \alpha_i \xi^i, \quad \sigma(\xi)=\sum_{i=0}^k\beta_i\xi^i\]</span>如何衡量数值求解方法的精度呢？定义<strong>局部截断误差</strong>为 <spanclass="math display">\[T_{n+k} = \sum_{i=0}^k [\alpha_i y(t_{n+i}) - h\beta_i y&#39;(t_{n+i})]\]</span> 对上面的式子做Taylor展开，可以得到形如 <spanclass="math inline">\(T_{n+1} = -1/90 h^5y^{(5)}(x_n)+O(h^6)\)</span>（这是Simpson公式的局部截断误差），这个式子表明Simpson公式是4阶的。</p><p>对于线性 <span class="math inline">\(k\)</span>步法，要想设计一种迭代方法使得数值精度是 <spanclass="math inline">\(p\)</span>阶的，可以采用待定系数法，保证局部截断误差中 <spanclass="math inline">\(y^{(1)}(x),...,y^{(q)}(x)\)</span>前面的系数都是0。</p><h3 id="稳定性与收敛性">2.2 稳定性与收敛性</h3><h4 id="相容性">2.2.1 相容性</h4><p>首先引入相容性的概念。若某个多步法的截断误差满足 <spanclass="math inline">\(T(t,y(t),h)=o(h)\)</span>那么称其为<strong>相容的</strong>。若 <spanclass="math inline">\(T(t,y(t),h)=O(h^{q+1})\)</span>，则称其为 <spanclass="math inline">\(q\)</span> 阶的。</p><p>实际上，相容性就是说该方法至少是1阶的，也就是当 <spanclass="math inline">\(y\)</span>为一次线性函数时，该方法要能够得到准确解。</p><p><strong>定理</strong>：相容的多步法充要条件是 <spanclass="math inline">\(\rho(1)=0,\rho&#39;(1)=\sigma(1)\)</span>。</p><h4 id="零稳定性">2.2.2 零稳定性</h4><p><strong>根条件</strong>：若多项式 <spanclass="math inline">\(\rho(\xi)\)</span> 的 <spanclass="math inline">\(k\)</span> 个根的模长都<strong>不大于1</strong>，并且模值等于 1 的根都是单根，则称其满足根条件。</p><p><strong>Note</strong>：根条件考虑的是齐次差分方程的解。当 <spanclass="math inline">\(f\equiv 0\)</span>的时候，齐次差分方程的解具有指数形式 <spanclass="math inline">\(y(n)=\sum_i P(n) \xi_i^n\)</span>，其中 <spanclass="math inline">\(P(n)\)</span> 是一个多项式， <spanclass="math inline">\(\xi_i\)</span> 就是 <spanclass="math inline">\(\rho(\xi)\)</span>的根（这里没考虑重根的情况，不过是类似的），如果 <spanclass="math inline">\(|\xi_i|&lt;1\)</span> 就意味着 <spanclass="math inline">\(\lim_{n\to\infty}y(n) =0\)</span>，那么这跟稳定性有什么关系呢？</p><p><strong>定理</strong>：线性多步法关于初值稳定的充要条件是 <spanclass="math inline">\(\rho(\xi)\)</span> 满足根条件。</p><p><strong>Note</strong>：这个定理说明了根条件和（零）稳定性二者的等价关系。为什么呢？假设真实的初值为<span class="math inline">\(y_0=y(t_0)\)</span>，真实的解为 <spanclass="math inline">\(y(n)=y_0\xi_0^{(n-t_0)}\)</span>。而我们计算的时候由于各种原因拿到的初值是有误差的，也就是<span class="math inline">\(\hat{y}_0\)</span>，那么最后求得的误差就是<spanclass="math inline">\(\hat{y}(n)-y(n)=(\hat{y}_0-y_0)\xi_0^{(n-t_0)}\)</span>，如果不满足根条件，当<span class="math inline">\(n\to\infty\)</span> 的时候，<spanclass="math inline">\(\hat{y}(n)-y(n) \to\infty\)</span>，解就是不稳定的。</p><h4 id="收敛性">2.2.3 收敛性</h4><p><strong>定义</strong>：假设在区间 <spanclass="math inline">\([a,b]\)</span> 上等距划分 <spanclass="math inline">\(N\)</span> 个区间，<span class="math inline">\(x_n= a+nh,n=0,1,...,N\)</span>，求解初值问题得到的解为 <spanclass="math inline">\(y_n,n=0,1,...,N\)</span>，最大整体误差为 <spanclass="math inline">\(E(h) = \max_{n} |y(x_n) - y_n|\)</span>，如果满足<span class="math inline">\(\lim_{h\to0}E(h)=0\)</span>，则称方法是<strong>收敛</strong>的。如果 <spanclass="math inline">\(E(h) \le Ch^p\)</span>，则称方法是 <spanclass="math inline">\(p\)</span> 阶收敛的。</p><p><strong>定理</strong>：相容性 + 零稳定性 <spanclass="math inline">\(\iff\)</span> 收敛性。</p><h4 id="绝对稳定性">2.2.4 绝对稳定性</h4><p>前面的零稳定性是跟所选择的方法有关的。而这里的绝对稳定性研究的是微分方程本身的属性。如果方程本身性质很不好，那么可能无论选择什么方法都是不稳定的。</p><p>取 <span class="math inline">\(f(x,y)=\lambday\)</span>，再研究方法的稳定性。以试验方程为例 <spanclass="math display">\[\begin{cases}y&#39; = \lambda y, t\in[a,b] \\y(a) = \tilde{y}_0\end{cases}\]</span> 用Euler法得到 <span class="math inline">\(y_n =(1+h\lambda)y_{n-1}\)</span>，于是两个解的误差满足 <spanclass="math inline">\(y_n-z_n = (1+h\lambda)^n (y_0-z_0)\)</span>，若<spanclass="math inline">\(|1+h\lambda|&gt;1\)</span>，则误差总会放大，这是我们不希望的。</p><p>要保证稳定性，既与方程本身的性质（也即 <spanclass="math inline">\(\lambda\)</span>） 有关，也与所选择的步长 <spanclass="math inline">\(h\)</span>有关。从另一个角度而言，方程本身的性质（<spanclass="math inline">\(\lambda\)</span>）会影响可选择的 <spanclass="math inline">\(h\)</span> 的范围。由此引出绝对稳定性的概念。</p><p>对前面提到的线性多步法，把 <span class="math inline">\(f(x,y)=\lambday\)</span> 代回去就有 <span class="math display">\[\sum_{i=0}^k (\alpha_i - h\lambda \beta_i) y_{n+i} = 0\]</span> 称 <span class="math inline">\(\Pi(\xi;z) = \rho(\xi) -z\sigma(\xi)\)</span> 为<strong>稳定多项式</strong>。</p><p><strong>定理</strong>：对给定的 <spanclass="math inline">\(z\)</span>，若 <spanclass="math inline">\(\Pi(\xi;z)\)</span> 的 <spanclass="math inline">\(k\)</span> 个根的模都<strong>小于1</strong>，则其是绝对稳定的。（满足这样条件的 <spanclass="math inline">\(z\)</span>的集合构成<strong>绝对稳定区域</strong>。）</p><h2 id="runge-kutta方法">3. Runge-Kutta方法</h2><p>Runge-Kutta方法和线性多步法的主要区别在于，其在 <spanclass="math inline">\(x_n,x_{n+1}\)</span>中间又进行了采样、插值。这种方法大概可以表示为 <spanclass="math display">\[\begin{align}&amp; y_{n+1} = y_n + h\sum_{i=1}^{s} b_i k_i \\&amp; k_i = y_n + f(t_n + c_i h, y_n + \sum_{i=1}^s a_{ij} k_j)\end{align}\]</span> 其中 <span class="math inline">\(0\le c_i\le1\)</span>。实际上<span class="math inline">\(k_i \approx y(t_n+c_i h)\)</span>，就是在<span class="math inline">\([y_n,y_{n+1}]\)</span>中间又进行了采样插值。</p><p>这样提高了精度，同时也会增加计算复杂度。</p><p>除此之外，提高精度的方法还有 Richardson 外推方法。</p><h2 id="刚性问题">4. 刚性问题</h2><p>刚性问题也是方程本身的属性，主要是指某些情况下两个特解的尺度相差很大，比如两个指数衰减的过程混合在一起，但是其中一个衰减特别快（<spanclass="math inline">\(\exp(-\lambda t)\)</span> 的 <spanclass="math inline">\(\lambda\)</span>特别大），另一个则衰减特别慢，那么数值求解的时候很可能只能看到衰减慢的那个过程，另一个则被忽略。这在化学反应中是经常遇到的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;求解常微分方程初值问题数值解 &lt;span class=&quot;math display&quot;&gt;\[
\begin{align}
&amp;amp;\frac{dy}{dx} = f(x,y), \quad a &amp;lt; x &amp;lt; b, |y| &amp;lt; \infty \\
&amp;amp;y(a) = y_0
\end{align}
\]&lt;/span&gt; 存在唯一性定理：若 &lt;span class=&quot;math inline&quot;&gt;\(f(x,y)\)&lt;/span&gt;
连续，对 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 满足 Lipschitz
条件，那么初值问题有唯一解。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="常微分方程" scheme="https://glooow1024.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
    <category term="刚性问题" scheme="https://glooow1024.github.io/tags/%E5%88%9A%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【高等数值分析】数值积分和数值微分</title>
    <link href="https://glooow1024.github.io/2022/01/09/advanced-numerical-analysis/ada-integration/"/>
    <id>https://glooow1024.github.io/2022/01/09/advanced-numerical-analysis/ada-integration/</id>
    <published>2022-01-09T13:55:54.000Z</published>
    <updated>2022-01-09T13:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>根据Newton-Leibniz公式有 <span class="math inline">\(\int_a^x f(t)dt=F(x)-F(a)\)</span>，但是绝大部分情况很难解析求解，需要数值积分。例如<strong>中点公式</strong><span class="math display">\[\int_a^b f(x)dx \approx f(\frac{a+b}{2})(b-a)\]</span> 若 <span class="math inline">\(f(x)\inC^2[a,b]\)</span>，则中点公式<strong>截断误差</strong>为 <spanclass="math display">\[\int_a^b f(x)dx - f(\frac{a+b}{2})(b-a) = \frac{(b-a)^2}{24}f&#39;&#39;(\xi), \quad \xi\in(a,b)\]</span> <span id="more"></span></p><h2 id="插值型求积公式">2. 插值型求积公式</h2><p>顾名思义，就是先插值再求积分。方法为给定求积节点 <spanclass="math inline">\(x_k,k=0,1,...,n\)</span> 和求积系数 <spanclass="math inline">\(A_k,k=0,1,...,n\)</span>，插值型求积公式表示为<span class="math display">\[\int_a^b f(x)dx \approx \sum_{k=0}^n A_k f(x_k)\]</span> 根据多项式插值中的理论，余项可表示为 <spanclass="math display">\[E_n(f) = \frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x)) w_{n+1}(x) dx\]</span> 当 <span class="math inline">\(f(x)\in{\mathcal P}_n\)</span>时都有 <spanclass="math inline">\(E_n(f)=0\)</span>。由此可以定义代数精度，如果对所有<span class="math inline">\(p\in{\mathcal P}_m\)</span> 有 <spanclass="math inline">\(E_n(p)=0\)</span>，而对某个 <spanclass="math inline">\(q\in{\mathcal P}_{m+1}\)</span> 有 <spanclass="math inline">\(E_n(q)\ne 0\)</span>，称求积公式具有 <spanclass="math inline">\(m\)</span> 次<strong>代数精度</strong>。</p><p>插值型求积公式主要分为两类：Newton-Cotes求积公式和Gauss型求积公式。前者等距选取插值节点，后者则未必。</p><h3 id="newton-cotes求积公式">2.1 Newton-Cotes求积公式</h3><p>方法是将区间 <span class="math inline">\([a,b]\)</span> <spanclass="math inline">\(n\)</span> 等分，得到 <spanclass="math inline">\(h =\frac{b-a}{n},x_k=a+kh,k=0,...,n\)</span>，再利用Lagrange插值公式 <spanclass="math inline">\(l_k(x)\)</span>，得到 <spanclass="math display">\[\int_a^b f(x)dx = (b-a)\sum_{k} \frac{f(x_k)}{b-a}\int_a^b l_k(x)dx =(b-a)\sum_k C_k^{(n)} f(x_k)\]</span> 其中 <spanclass="math inline">\(C_k^{(n)}=\frac{1}{b-a}\int_a^b \prod_{j\nek}\frac{x-x_j}{x_k-x_j}dx = \frac{1}{n}\int_a^b \prod_{j\nek}\frac{t-j}{k-j}dx\)</span> 称为 Cotes求积系数，不仅<strong>与被积函数无关</strong>，<strong>与求积区间也无关</strong>。</p><p>该方法有如下性质：</p><ul><li><span class="math inline">\(\sum_{k=0}^n C_k^{(n)} = 1\)</span>（取<span class="math inline">\(f\equiv1\)</span> 即可得证）；</li><li><span class="math inline">\(E_n(f) = \frac{1}{(n+1)!}\int_a^bf^{(n+1)}(\xi(x)) w_{n+1}(x) dx\)</span>；</li><li>当 <span class="math inline">\(n\)</span> 为偶数时，代数精度为 <spanclass="math inline">\(n+1\)</span>；当 <spanclass="math inline">\(n\)</span> 为奇数时，代数精度为 <spanclass="math inline">\(n\)</span>。（直观理解是因为奇次多项式的奇对称性积分后恰好为0）</li></ul><p>下面是 <span class="math inline">\(n\)</span> 取不同数值的特例。</p><p><span class="math inline">\(n=1\)</span> 时为梯形公式，代数精度为<span class="math inline">\(1\)</span>： <span class="math display">\[\begin{align}&amp;\int_a^b f(x)dx \approx \frac{b-a}{2}[f(a)+f(b)] \\&amp;E_1(f) = -\frac{(b-a)^3}{12} f&#39;&#39;(\xi), \xi\in[a,b]\end{align}\]</span> <span class="math inline">\(n = 2\)</span> 时为 Simpson公式，代数精度为 <span class="math inline">\(3\)</span>： <spanclass="math display">\[\begin{align}&amp;\int_a^b f(x)dx \approx \frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]\\&amp;E_1(f) = -\frac{(b-a)^5}{2880} f^{(4)}(\xi), \xi\in[a,b]\end{align}\]</span></p><h3 id="gauss型求积公式">2.2 Gauss型求积公式</h3><p>求积公式也表示为 <span class="math display">\[\int_a^b f(x)dx \approx \sum_{k=0}^n A_k f(x_k)\]</span>但与Newton-Cotes方法不同的是求积节点并非等距选取，而是将参数待定，解出使代数精度最高的参数<span class="math inline">\(A_k\)</span> 和 <spanclass="math inline">\(x_k\)</span>。共有 <spanclass="math inline">\(2n+2\)</span> 个参数待定，分别取 <spanclass="math inline">\(f(x)=1,x,x^2,...,x^{2n+1}\)</span>列方程组，因此代数精度最高可以达到 <spanclass="math inline">\(2n+1\)</span>。</p><p>从理论上也可以证明代数精度至多为 <spanclass="math inline">\(2n+1\)</span>。</p><p>证明：取 <spanclass="math inline">\(f(x)=\prod_{k=0}^n(x-x_k)^2\)</span>，那么上面等式左边一定有<span class="math inline">\(\int_a^b f(x)dx &gt;0\)</span>，但是等式右边有 <span class="math inline">\(\sum_{k} A_kf(x_k)=0\)</span>，显然不相等。证毕。</p><p>除此之外，Gauss型求积公式还可以拓展到带权积分的情况，也即 <spanclass="math display">\[\int_a^b \rho(x)f(x)dx = \sum_{k=0}^n A_k f(x_k) +\frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x)) w_{n+1}(x) dx\]</span> 关键问题是如何求解 <spanclass="math inline">\(A_k,x_k\)</span> 呢？</p><p>由于代数精度为 <span class="math inline">\(2n+1\)</span>，对 <spanclass="math inline">\(\forall f\in{\mathcalP}_{2n+1}\)</span>，截断误差应满足 <spanclass="math inline">\(\frac{1}{(n+1)!}\int_a^b f^{(n+1)}(\xi(x))w_{n+1}(x) dx=0\)</span>。又由于 <spanclass="math inline">\(f^{(n+1)}\in{\mathcal P}_n\)</span>，那么只需要取<span class="math inline">\(w_{n+1}(x)\)</span> 为 <spanclass="math inline">\(n+1\)</span> 阶正交多项式（权函数为 <spanclass="math inline">\(\rho\)</span>）即可满足该条件。因此Gauss型求积公式的求解方法为：</p><ol type="1"><li>权函数为 <span class="math inline">\(\rho\)</span>，求 <spanclass="math inline">\(n+1\)</span> 阶正交多项式；</li><li>求 <span class="math inline">\(n+1\)</span> 个根 <spanclass="math inline">\(x_k\)</span>（在逼近一章中已经证明了一定存在 <spanclass="math inline">\(n+1\)</span> 个不同的根）；</li><li>取 <span class="math inline">\(f(x)=1,x,...,x^n\)</span>列线性方程组求 <span class="math inline">\(A_k\)</span>。</li></ol><p>Gauss型求积公式有如下性质：</p><ul><li><span class="math inline">\(A_k &gt; 0,k=0,1,...,n\)</span>（取<span class="math inline">\(f(x)=l_i(x)\)</span> 即可证明）；</li><li><span class="math inline">\(\sum_{k=0}^n A_k = \int_a^b\rho(x)dx\)</span>（取 <span class="math inline">\(f\equiv\)</span>即可证明）；</li><li>余项 <span class="math inline">\(E_n(f) =\frac{1}{(2n+2)!}f^{(2n+2)}(\eta)\int_a^b \rho(x) [w_{n+1}(x)]^2dx\)</span>。</li></ul><h2 id="数值微分">3. 数值微分</h2><p>数值微分和数值积分类似，也有插值型微分公式，即先进性多项式插值，再求导数值。</p><p>还可以利用Richardson外推公式提高精度。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;根据Newton-Leibniz公式有 &lt;span class=&quot;math inline&quot;&gt;\(\int_a^x f(t)dt
=
F(x)-F(a)\)&lt;/span&gt;，但是绝大部分情况很难解析求解，需要数值积分。例如&lt;strong&gt;中点公式&lt;/strong&gt;
&lt;span class=&quot;math display&quot;&gt;\[
\int_a^b f(x)dx \approx f(\frac{a+b}{2})(b-a)
\]&lt;/span&gt; 若 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\in
C^2[a,b]\)&lt;/span&gt;，则中点公式&lt;strong&gt;截断误差&lt;/strong&gt;为 &lt;span
class=&quot;math display&quot;&gt;\[
\int_a^b f(x)dx - f(\frac{a+b}{2})(b-a) = \frac{(b-a)^2}{24}
f&amp;#39;&amp;#39;(\xi), \quad \xi\in(a,b)
\]&lt;/span&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数值积分" scheme="https://glooow1024.github.io/tags/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【高等数值分析】函数逼近</title>
    <link href="https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-approximation/"/>
    <id>https://glooow1024.github.io/2022/01/07/advanced-numerical-analysis/ada-approximation/</id>
    <published>2022-01-07T15:47:30.000Z</published>
    <updated>2022-01-07T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备理论">1. 预备理论</h2><p>函数插值当中我们只有几个离散的的插值节点及其函数值，在函数逼近里我们考虑的是有一个<span class="math inline">\(f(x),x\in[a,b]\)</span>已知，但是希望用一组简单的基函数 <spanclass="math inline">\(\{\phi_0,...,\phi_n\}\)</span> 逼近 <spanclass="math inline">\(f(x)\)</span>。</p><span id="more"></span><p>首先定义加权内积为 <span class="math inline">\(\langlef,g\rangle_\rho = \int_a^b \rho(x)f(x)g(x)dx\)</span>，其中 <spanclass="math inline">\(\rho(x)\ge0\)</span>为权函数。相应的可以导出范数定义为 <span class="math inline">\(\Vertf\Vert_\rho = \sqrt{\langlef,f\rangle_\rho}\)</span>。后面为了符号简洁都默认省略下标 <spanclass="math inline">\(\rho\)</span>。</p><p>一般考虑最佳平方逼近问题，即 <spanclass="math inline">\(\min_{s\in\Phi} \Vert f-s\Vert\)</span>，其中<span class="math inline">\(\Phi\)</span>为某个函数空间，一般为代数多项式、三角多项式或有理多项式组。</p><h2 id="多项式逼近">2. 多项式逼近</h2><h3 id="总体框架">2.1 总体框架</h3><p>若 <spanclass="math inline">\(\Phi=\operatorname{span}\{\phi_0,...,\phi_n\}\)</span>，<spanclass="math inline">\(\{\phi_j,j=0,...,n\}\)</span>为一组线性无关的的基函数，那么 <span class="math inline">\(\foralls\in\Phi\)</span> 可以表示为 <span class="math inline">\(s(x) =\sum_{j=0}^n a_j\phi_j(x)\)</span>，最佳平方逼近问题变为 <spanclass="math display">\[\min_{s\in\Phi} F(a_0,...,a_n) \triangleq \Vert f-\sum a_j\phi_j \Vert^2\]</span> 令 <span class="math inline">\(\partial F/\partiala_k=0\)</span> 即可得到下面的法方程，再求解线性方程组即可得到 <spanclass="math inline">\(a_k\)</span> <span class="math display">\[\sum_{i=0}^n \langle \phi_i, \phi_k\rangle a_i = \langlef,\phi_k\rangle, \quad k=0,1,...,n\]</span>除了前面的求导得到法方程，还可以利用<strong>Galerkin条件</strong>（实际上与法方程等价）<span class="math display">\[\langle f-s^{\ast}, s\rangle = 0, \quad s\in\Phi\]</span> 根据前面的结论，要想求得 <spanclass="math inline">\(a_k\)</span> 需要解法方程 <spanclass="math inline">\({\Psi}\boldsymbol{a}=\boldsymbol{b}\)</span>，为了进一步简化该问题，可以选择基函数<span class="math inline">\(\phi_j\)</span> 相互正交，那么 <spanclass="math inline">\(\Psi\)</span> 就会退化为对角阵，并且此时有 <spanclass="math display">\[s^{\ast} = \sum_{k=0}^n \frac{\langle f,\phi_k\rangle}{\Vert\phi_k\Vert^2} \phi_k\]</span> 后面的关键就是如何获得相互正交的一组基函数？</p><h3 id="正交多项式">2.2 正交多项式</h3><p>答案就是Gram-Schmidt正交化。对于多项式基函数 <spanclass="math inline">\(\phi_k\in{\mathcal P}_k\)</span>，只需要对 <spanclass="math inline">\(\{1,x,x^2,...\}\)</span>逐次进行Gram-Schmidt正交化即可。 <span class="math display">\[\phi_k = x^k - \sum_{j=0}^{k-1} \frac{\langle x^k,\phi_j\rangle}{\langle\phi_j,\phi_j\rangle} \phi_j\]</span> 后面将介绍几种不同的正交多项式，他们的区别就在于支撑区间 <spanclass="math inline">\([a,b]\)</span> 和权函数 <spanclass="math inline">\(\rho(x)\)</span> 的不同。</p><h4 id="lengdre多项式">2.2.1 Lengdre多项式</h4><p><spanclass="math inline">\(\rho(x)=1,x\in[-1,1],\phi_0(x)=1\)</span>，有如下性质：</p><ul><li>递推关系：<span class="math inline">\((n+1)P_{n+1}(x) =(2n+1)xP_n(x) - n P_{n-1}(x)\)</span></li><li>奇偶性：<span class="math inline">\(P_n(-x) = (-1)^nP_n(x)\)</span></li><li><span class="math inline">\([-1,1]\)</span> 上Lengdre多项式与 <spanclass="math inline">\(f\equiv0\)</span> 的平方误差最小</li></ul><h4 id="chebyshev多项式">2.2.2 Chebyshev多项式</h4><p><spanclass="math inline">\(\rho(x)=1/\sqrt{1-x^2},x\in[-1,1],\phi_0=1\)</span>，有如下性质：</p><ul><li>递推关系：<span class="math inline">\(T_{n+1}(x) =2xT_n(x)-T_{n-1}(x)\)</span></li><li>奇偶性：<span class="math inline">\(P_n(-x) = (-1)^nP_n(x)\)</span></li><li><span class="math inline">\(T_n(x)\)</span> 在 <spanclass="math inline">\((-1,1)\)</span> 上有 <spanclass="math inline">\(n\)</span> 个不同的零点 <spanclass="math inline">\(x_k=\cos\frac{(2k-1)\pi}{2n},k=1,2,..,n\)</span></li></ul><h4 id="lagurre多项式">2.2.3 Lagurre多项式</h4><p><spanclass="math inline">\(\rho(x)=e^{-x},x\in(0,+\infty),\phi_0=1\)</span></p><h4 id="hermite多项式">2.2.4 Hermite多项式</h4><p><spanclass="math inline">\(\rho(x)=\exp(-x^2),x\in(-\infty,\infty),\phi_0=1\)</span></p><h2 id="pade逼近">3. Pade逼近</h2><p>Pade逼近是用有理多项式 <span class="math inline">\(R_{n,m}(x) =\frac{R_n(x)}{Q_m(x)}\)</span> 逼近 <spanclass="math inline">\(f(x)\)</span>，其中 <spanclass="math inline">\(P_n\in{\mathcal P}_n,Q_m\in{\mathcalP}_m\)</span>。如果对 <span class="math inline">\(f(x)\)</span> 做Taylor 展开的话，能得到 <span class="math display">\[f(x)Q_m(x) - P_n(x) = \sum_{i=0}^\infty c_ix^i\]</span> 理论上有 <span class="math inline">\(n+m+1\)</span>个待定系数，因此可以列出方程 <spanclass="math inline">\(c_0=c_1=\cdots=c_{n+m}=0\)</span>，即可得到 <spanclass="math inline">\(R_{n,m}\)</span>。</p><h2 id="最小二乘">4. 最小二乘</h2><p>如果给定了很多个节点函数值 <spanclass="math inline">\(f(x_i)\)</span>，但是不要求满足插值条件 <spanclass="math inline">\(f(x_i)=\phi(x_i)\)</span>，而只要求最小化平方误差<span class="math inline">\(\sum_i(f(x_i)-\phi(x_i))^2\)</span>，那么就是最小二乘问题 <spanclass="math display">\[\min \Vert b-Ax\Vert \Rightarrow x^{\ast} = (A^TA)^{-1}A^Tb\]</span> 也可以对 <span class="math inline">\(A\)</span>做QR分解，那么就有 <spanclass="math inline">\(Rx^{\ast}=Q^Tb\)</span>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;预备理论&quot;&gt;1. 预备理论&lt;/h2&gt;
&lt;p&gt;函数插值当中我们只有几个离散的的插值节点及其函数值，在函数逼近里我们考虑的是有一个
&lt;span class=&quot;math inline&quot;&gt;\(f(x),x\in[a,b]\)&lt;/span&gt;
已知，但是希望用一组简单的基函数 &lt;span
class=&quot;math inline&quot;&gt;\(\{\phi_0,...,\phi_n\}\)&lt;/span&gt; 逼近 &lt;span
class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="高等数值分析" scheme="https://glooow1024.github.io/categories/%E9%AB%98%E7%AD%89%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="多项式逼近" scheme="https://glooow1024.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%80%BC%E8%BF%91/"/>
    
    <category term="Pade逼近" scheme="https://glooow1024.github.io/tags/Pade%E9%80%BC%E8%BF%91/"/>
    
    <category term="Lengdre多项式" scheme="https://glooow1024.github.io/tags/Lengdre%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
    <category term="Chebyshev多项式" scheme="https://glooow1024.github.io/tags/Chebyshev%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
</feed>
